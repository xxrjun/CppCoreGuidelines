
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../f-functions/">
      
      
        <link rel="next" href="../enum-enumerations/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>C: Classes and class hierarchies - C++ Core Guidelines</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#c-classes-and-class-hierarchies-s-class" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="C++ Core Guidelines" class="md-header__button md-logo" aria-label="C++ Core Guidelines" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            C++ Core Guidelines
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              C: Classes and class hierarchies
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/xxrjun/CppCoreGuidelines" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    xxrjun/CppCoreGuidelines
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="C++ Core Guidelines" class="md-nav__button md-logo" aria-label="C++ Core Guidelines" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    C++ Core Guidelines
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/xxrjun/CppCoreGuidelines" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    xxrjun/CppCoreGuidelines
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../NOTICE/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    NOTICE
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../abstract/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Abstract
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../in-introduction/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    In: Introduction
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../p-philosophy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    P: Philosophy
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../i-interfaces/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    I: Interfaces
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../f-functions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    F: Functions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    C: Classes and class hierarchies
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    C: Classes and class hierarchies
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#c1-organize-related-data-into-structures-structs-or-classes" class="md-nav__link">
    <span class="md-ellipsis">
      C.1: Organize related data into structures (structs or classes)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently" class="md-nav__link">
    <span class="md-ellipsis">
      C.2: Use class if the class has an invariant; use struct if the data members can vary independently
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c3-represent-the-distinction-between-an-interface-and-an-implementation-using-a-class" class="md-nav__link">
    <span class="md-ellipsis">
      C.3: Represent the distinction between an interface and an implementation using a class
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class" class="md-nav__link">
    <span class="md-ellipsis">
      C.4: Make a function a member only if it needs direct access to the representation of a class
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c5-place-helper-functions-in-the-same-namespace-as-the-class-they-support" class="md-nav__link">
    <span class="md-ellipsis">
      C.5: Place helper functions in the same namespace as the class they support
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement" class="md-nav__link">
    <span class="md-ellipsis">
      C.7: Don't define a class or enum and declare a variable of its type in the same statement
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c8-use-class-rather-than-struct-if-any-member-is-non-public" class="md-nav__link">
    <span class="md-ellipsis">
      C.8: Use class rather than struct if any member is non-public
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c9-minimize-exposure-of-members" class="md-nav__link">
    <span class="md-ellipsis">
      C.9: Minimize exposure of members
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cconcrete-concrete-types" class="md-nav__link">
    <span class="md-ellipsis">
      C.concrete: Concrete types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.concrete: Concrete types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c10-prefer-concrete-types-over-class-hierarchies" class="md-nav__link">
    <span class="md-ellipsis">
      C.10: Prefer concrete types over class hierarchies
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c11-make-concrete-types-regular" class="md-nav__link">
    <span class="md-ellipsis">
      C.11: Make concrete types regular
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c12-dont-make-data-members-const-or-references-in-a-copyable-or-movable-type" class="md-nav__link">
    <span class="md-ellipsis">
      C.12: Don't make data members const or references in a copyable or movable type
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cctor-constructors-assignments-and-destructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.ctor: Constructors, assignments, and destructors
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cdefop-default-operations" class="md-nav__link">
    <span class="md-ellipsis">
      C.defop: Default Operations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.defop: Default Operations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c20-if-you-can-avoid-defining-default-operations-do" class="md-nav__link">
    <span class="md-ellipsis">
      C.20: If you can avoid defining default operations, do
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c21-if-you-define-or-delete-any-copy-move-or-destructor-function-define-or-delete-them-all" class="md-nav__link">
    <span class="md-ellipsis">
      C.21: If you define or =delete any copy, move, or destructor function, define or =delete them all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c22-make-default-operations-consistent" class="md-nav__link">
    <span class="md-ellipsis">
      C.22: Make default operations consistent
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cdtor-destructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.dtor: Destructors
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.dtor: Destructors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction" class="md-nav__link">
    <span class="md-ellipsis">
      C.30: Define a destructor if a class needs an explicit action at object destruction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c31-all-resources-acquired-by-a-class-must-be-released-by-the-classs-destructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.31: All resources acquired by a class must be released by the class's destructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c32-if-a-class-has-a-raw-pointer-t-or-reference-t-consider-whether-it-might-be-owning" class="md-nav__link">
    <span class="md-ellipsis">
      C.32: If a class has a raw pointer (T*) or reference (T&amp;), consider whether it might be owning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c33-if-a-class-has-an-owning-pointer-member-define-a-destructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.33: If a class has an owning pointer member, define a destructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual" class="md-nav__link">
    <span class="md-ellipsis">
      C.35: A base class destructor should be either public and virtual, or protected and non-virtual
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c36-a-destructor-must-not-fail" class="md-nav__link">
    <span class="md-ellipsis">
      C.36: A destructor must not fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c37-make-destructors-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.37: Make destructors noexcept
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cctor-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.ctor: Constructors
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.ctor: Constructors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c40-define-a-constructor-if-a-class-has-an-invariant" class="md-nav__link">
    <span class="md-ellipsis">
      C.40: Define a constructor if a class has an invariant
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c41-a-constructor-should-create-a-fully-initialized-object" class="md-nav__link">
    <span class="md-ellipsis">
      C.41: A constructor should create a fully initialized object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c42-if-a-constructor-cannot-construct-a-valid-object-throw-an-exception" class="md-nav__link">
    <span class="md-ellipsis">
      C.42: If a constructor cannot construct a valid object, throw an exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c43-ensure-that-a-copyable-class-has-a-default-constructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.43: Ensure that a copyable class has a default constructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c44-prefer-default-constructors-to-be-simple-and-non-throwing" class="md-nav__link">
    <span class="md-ellipsis">
      C.44: Prefer default constructors to be simple and non-throwing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c45-dont-define-a-default-constructor-that-only-initializes-data-members-use-default-member-initializers-instead" class="md-nav__link">
    <span class="md-ellipsis">
      C.45: Don't define a default constructor that only initializes data members; use default member initializers instead
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c46-by-default-declare-single-argument-constructors-explicit" class="md-nav__link">
    <span class="md-ellipsis">
      C.46: By default, declare single-argument constructors explicit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c47-define-and-initialize-data-members-in-the-order-of-member-declaration" class="md-nav__link">
    <span class="md-ellipsis">
      C.47: Define and initialize data members in the order of member declaration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c48-prefer-default-member-initializers-to-member-initializers-in-constructors-for-constant-initializers" class="md-nav__link">
    <span class="md-ellipsis">
      C.48: Prefer default member initializers to member initializers in constructors for constant initializers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c49-prefer-initialization-to-assignment-in-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.49: Prefer initialization to assignment in constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization" class="md-nav__link">
    <span class="md-ellipsis">
      C.50: Use a factory function if you need "virtual behavior" during initialization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c51-use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class" class="md-nav__link">
    <span class="md-ellipsis">
      C.51: Use delegating constructors to represent common actions for all constructors of a class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c52-use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization" class="md-nav__link">
    <span class="md-ellipsis">
      C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ccopy-copy-and-move" class="md-nav__link">
    <span class="md-ellipsis">
      C.copy: Copy and move
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.copy: Copy and move">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const" class="md-nav__link">
    <span class="md-ellipsis">
      C.60: Make copy assignment non-virtual, take the parameter by const&amp;, and return by non-const&amp;
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c61-a-copy-operation-should-copy" class="md-nav__link">
    <span class="md-ellipsis">
      C.61: A copy operation should copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c62-make-copy-assignment-safe-for-self-assignment" class="md-nav__link">
    <span class="md-ellipsis">
      C.62: Make copy assignment safe for self-assignment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c63-make-move-assignment-non-virtual-take-the-parameter-by-and-return-by-non-const" class="md-nav__link">
    <span class="md-ellipsis">
      C.63: Make move assignment non-virtual, take the parameter by &amp;&amp;, and return by non-const&amp;
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state" class="md-nav__link">
    <span class="md-ellipsis">
      C.64: A move operation should move and leave its source in a valid state
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c65-make-move-assignment-safe-for-self-assignment" class="md-nav__link">
    <span class="md-ellipsis">
      C.65: Make move assignment safe for self-assignment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c66-make-move-operations-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.66: Make move operations noexcept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c67-a-polymorphic-class-should-suppress-public-copymove" class="md-nav__link">
    <span class="md-ellipsis">
      C.67: A polymorphic class should suppress public copy/move
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cother-other-default-operation-rules" class="md-nav__link">
    <span class="md-ellipsis">
      C.other: Other default operation rules
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.other: Other default operation rules">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c80-use-default-if-you-have-to-be-explicit-about-using-the-default-semantics" class="md-nav__link">
    <span class="md-ellipsis">
      C.80: Use =default if you have to be explicit about using the default semantics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c81-use-delete-when-you-want-to-disable-default-behavior-without-wanting-an-alternative" class="md-nav__link">
    <span class="md-ellipsis">
      C.81: Use =delete when you want to disable default behavior (without wanting an alternative)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c82-dont-call-virtual-functions-in-constructors-and-destructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.82: Don't call virtual functions in constructors and destructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c83-for-value-like-types-consider-providing-a-noexcept-swap-function" class="md-nav__link">
    <span class="md-ellipsis">
      C.83: For value-like types, consider providing a noexcept swap function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c84-a-swap-function-must-not-fail" class="md-nav__link">
    <span class="md-ellipsis">
      C.84: A swap function must not fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c85-make-swap-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.85: Make swap noexcept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c86-make-symmetric-with-respect-to-operand-types-and-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.86: Make == symmetric with respect to operand types and noexcept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c87-beware-of-on-base-classes" class="md-nav__link">
    <span class="md-ellipsis">
      C.87: Beware of == on base classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c89-make-a-hash-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.89: Make a hash noexcept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c90-rely-on-constructors-and-assignment-operators-not-memset-and-memcpy" class="md-nav__link">
    <span class="md-ellipsis">
      C.90: Rely on constructors and assignment operators, not memset and memcpy
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ccon-containers-and-other-resource-handles" class="md-nav__link">
    <span class="md-ellipsis">
      C.con: Containers and other resource handles
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.con: Containers and other resource handles">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c100-follow-the-stl-when-defining-a-container" class="md-nav__link">
    <span class="md-ellipsis">
      C.100: Follow the STL when defining a container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c101-give-a-container-value-semantics" class="md-nav__link">
    <span class="md-ellipsis">
      C.101: Give a container value semantics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c102-give-a-container-move-operations" class="md-nav__link">
    <span class="md-ellipsis">
      C.102: Give a container move operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c103-give-a-container-an-initializer-list-constructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.103: Give a container an initializer list constructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c104-give-a-container-a-default-constructor-that-sets-it-to-empty" class="md-nav__link">
    <span class="md-ellipsis">
      C.104: Give a container a default constructor that sets it to empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c109-if-a-resource-handle-has-pointer-semantics-provide-and-" class="md-nav__link">
    <span class="md-ellipsis">
      C.109: If a resource handle has pointer semantics, provide * and -&gt;
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#clambdas-function-objects-and-lambdas" class="md-nav__link">
    <span class="md-ellipsis">
      C.lambdas: Function objects and lambdas
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chier-class-hierarchies-oop" class="md-nav__link">
    <span class="md-ellipsis">
      C.hier: Class hierarchies (OOP)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.hier: Class hierarchies (OOP)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c120-use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only" class="md-nav__link">
    <span class="md-ellipsis">
      C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c121-if-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class" class="md-nav__link">
    <span class="md-ellipsis">
      C.121: If a base class is used as an interface, make it a pure abstract class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c122-use-abstract-classes-as-interfaces-when-complete-separation-of-interface-and-implementation-is-needed" class="md-nav__link">
    <span class="md-ellipsis">
      C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chierclass-designing-classes-in-a-hierarchy" class="md-nav__link">
    <span class="md-ellipsis">
      C.hierclass: Designing classes in a hierarchy:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.hierclass: Designing classes in a hierarchy:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c126-an-abstract-class-typically-doesnt-need-a-user-written-constructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.126: An abstract class typically doesn't need a user-written constructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.127: A class with a virtual function should have a virtual or protected destructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final" class="md-nav__link">
    <span class="md-ellipsis">
      C.128: Virtual functions should specify exactly one of virtual, override, or final
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c129-when-designing-a-class-hierarchy-distinguish-between-implementation-inheritance-and-interface-inheritance" class="md-nav__link">
    <span class="md-ellipsis">
      C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c130-for-making-deep-copies-of-polymorphic-classes-prefer-a-virtual-clone-function-instead-of-public-copy-constructionassignment" class="md-nav__link">
    <span class="md-ellipsis">
      C.130: For making deep copies of polymorphic classes prefer a virtual clone function instead of public copy construction/assignment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c131-avoid-trivial-getters-and-setters" class="md-nav__link">
    <span class="md-ellipsis">
      C.131: Avoid trivial getters and setters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c132-dont-make-a-function-virtual-without-reason" class="md-nav__link">
    <span class="md-ellipsis">
      C.132: Don't make a function virtual without reason
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c133-avoid-protected-data" class="md-nav__link">
    <span class="md-ellipsis">
      C.133: Avoid protected data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c134-ensure-all-non-const-data-members-have-the-same-access-level" class="md-nav__link">
    <span class="md-ellipsis">
      C.134: Ensure all non-const data members have the same access level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c135-use-multiple-inheritance-to-represent-multiple-distinct-interfaces" class="md-nav__link">
    <span class="md-ellipsis">
      C.135: Use multiple inheritance to represent multiple distinct interfaces
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c136-use-multiple-inheritance-to-represent-the-union-of-implementation-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      C.136: Use multiple inheritance to represent the union of implementation attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c137-use-virtual-bases-to-avoid-overly-general-base-classes" class="md-nav__link">
    <span class="md-ellipsis">
      C.137: Use virtual bases to avoid overly general base classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c138-create-an-overload-set-for-a-derived-class-and-its-bases-with-using" class="md-nav__link">
    <span class="md-ellipsis">
      C.138: Create an overload set for a derived class and its bases with using
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c139-use-final-on-classes-sparingly" class="md-nav__link">
    <span class="md-ellipsis">
      C.139: Use final on classes sparingly
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider" class="md-nav__link">
    <span class="md-ellipsis">
      C.140: Do not provide different default arguments for a virtual function and an overrider
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chier-access-accessing-objects-in-a-hierarchy" class="md-nav__link">
    <span class="md-ellipsis">
      C.hier-access: Accessing objects in a hierarchy
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.hier-access: Accessing objects in a hierarchy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c145-access-polymorphic-objects-through-pointers-and-references" class="md-nav__link">
    <span class="md-ellipsis">
      C.145: Access polymorphic objects through pointers and references
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c146-use-dynamic_cast-where-class-hierarchy-navigation-is-unavoidable" class="md-nav__link">
    <span class="md-ellipsis">
      C.146: Use dynamic_cast where class hierarchy navigation is unavoidable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c147-use-dynamic_cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error" class="md-nav__link">
    <span class="md-ellipsis">
      C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c148-use-dynamic_cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative" class="md-nav__link">
    <span class="md-ellipsis">
      C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new" class="md-nav__link">
    <span class="md-ellipsis">
      C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c150-use-make_unique-to-construct-objects-owned-by-unique_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      C.150: Use make_unique() to construct objects owned by unique_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c151-use-make_shared-to-construct-objects-owned-by-shared_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      C.151: Use make_shared() to construct objects owned by shared_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base" class="md-nav__link">
    <span class="md-ellipsis">
      C.152: Never assign a pointer to an array of derived class objects to a pointer to its base
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c153-prefer-virtual-function-to-casting" class="md-nav__link">
    <span class="md-ellipsis">
      C.153: Prefer virtual function to casting
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cover-overloading-and-overloaded-operators" class="md-nav__link">
    <span class="md-ellipsis">
      C.over: Overloading and overloaded operators
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.over: Overloading and overloaded operators">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c160-define-operators-primarily-to-mimic-conventional-usage" class="md-nav__link">
    <span class="md-ellipsis">
      C.160: Define operators primarily to mimic conventional usage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c161-use-non-member-functions-for-symmetric-operators" class="md-nav__link">
    <span class="md-ellipsis">
      C.161: Use non-member functions for symmetric operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c162-overload-operations-that-are-roughly-equivalent" class="md-nav__link">
    <span class="md-ellipsis">
      C.162: Overload operations that are roughly equivalent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c163-overload-only-for-operations-that-are-roughly-equivalent" class="md-nav__link">
    <span class="md-ellipsis">
      C.163: Overload only for operations that are roughly equivalent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c164-avoid-implicit-conversion-operators" class="md-nav__link">
    <span class="md-ellipsis">
      C.164: Avoid implicit conversion operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c165-use-using-for-customization-points" class="md-nav__link">
    <span class="md-ellipsis">
      C.165: Use using for customization points
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c166-overload-unary-only-as-part-of-a-system-of-smart-pointers-and-references" class="md-nav__link">
    <span class="md-ellipsis">
      C.166: Overload unary &amp; only as part of a system of smart pointers and references
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c167-use-an-operator-for-an-operation-with-its-conventional-meaning" class="md-nav__link">
    <span class="md-ellipsis">
      C.167: Use an operator for an operation with its conventional meaning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c168-define-overloaded-operators-in-the-namespace-of-their-operands" class="md-nav__link">
    <span class="md-ellipsis">
      C.168: Define overloaded operators in the namespace of their operands
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c170-if-you-feel-like-overloading-a-lambda-use-a-generic-lambda" class="md-nav__link">
    <span class="md-ellipsis">
      C.170: If you feel like overloading a lambda, use a generic lambda
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cunion-unions" class="md-nav__link">
    <span class="md-ellipsis">
      C.union: Unions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.union: Unions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c180-use-unions-to-save-memory" class="md-nav__link">
    <span class="md-ellipsis">
      C.180: Use unions to save memory
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c181-avoid-naked-unions" class="md-nav__link">
    <span class="md-ellipsis">
      C.181: Avoid "naked" unions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c182-use-anonymous-unions-to-implement-tagged-unions" class="md-nav__link">
    <span class="md-ellipsis">
      C.182: Use anonymous unions to implement tagged unions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c183-dont-use-a-union-for-type-punning" class="md-nav__link">
    <span class="md-ellipsis">
      C.183: Don't use a union for type punning
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../enum-enumerations/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Enum: Enumerations
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../r-resource-management/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    R: Resource management
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../es-expressions-and-statements/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ES: Expressions and statements
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../per-performance/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Per: Performance
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cp-concurrency-and-parallelism/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    CP: Concurrency and parallelism
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../e-error-handling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    E: Error handling
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../con-constants-and-immutability/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Con: Constants and immutability
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../t-templates-and-generic-programming/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    T: Templates and generic programming
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cpl-c-style-programming/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    CPL: C-style programming
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../sf-source-files/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    SF: Source files
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../sl-the-standard-library/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    SL: The Standard Library
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../a-architectural-ideas/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    A: Architectural ideas
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../nr-non-rules-and-myths/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    NR: Non-Rules and myths
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../rf-references/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    RF: References
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../pro-profiles/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Pro: Profiles
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../gsl-guidelines-support-library/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    GSL: Guidelines support library
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../nl-naming-and-layout-suggestions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    NL: Naming and layout suggestions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq-answers-to-frequently-asked-questions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FAQ: Answers to frequently asked questions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-a-libraries/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Appendix A: Libraries
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-b-modernizing-code/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Appendix B: Modernizing code
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-c-discussion/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Appendix C: Discussion
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-d-supporting-tools/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Appendix D: Supporting tools
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../glossary/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Glossary
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../to-do-unclassified-proto-rules/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    To-do: Unclassified proto-rules
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../bibliography/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Bibliography
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#c1-organize-related-data-into-structures-structs-or-classes" class="md-nav__link">
    <span class="md-ellipsis">
      C.1: Organize related data into structures (structs or classes)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently" class="md-nav__link">
    <span class="md-ellipsis">
      C.2: Use class if the class has an invariant; use struct if the data members can vary independently
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c3-represent-the-distinction-between-an-interface-and-an-implementation-using-a-class" class="md-nav__link">
    <span class="md-ellipsis">
      C.3: Represent the distinction between an interface and an implementation using a class
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class" class="md-nav__link">
    <span class="md-ellipsis">
      C.4: Make a function a member only if it needs direct access to the representation of a class
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c5-place-helper-functions-in-the-same-namespace-as-the-class-they-support" class="md-nav__link">
    <span class="md-ellipsis">
      C.5: Place helper functions in the same namespace as the class they support
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement" class="md-nav__link">
    <span class="md-ellipsis">
      C.7: Don't define a class or enum and declare a variable of its type in the same statement
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c8-use-class-rather-than-struct-if-any-member-is-non-public" class="md-nav__link">
    <span class="md-ellipsis">
      C.8: Use class rather than struct if any member is non-public
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c9-minimize-exposure-of-members" class="md-nav__link">
    <span class="md-ellipsis">
      C.9: Minimize exposure of members
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cconcrete-concrete-types" class="md-nav__link">
    <span class="md-ellipsis">
      C.concrete: Concrete types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.concrete: Concrete types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c10-prefer-concrete-types-over-class-hierarchies" class="md-nav__link">
    <span class="md-ellipsis">
      C.10: Prefer concrete types over class hierarchies
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c11-make-concrete-types-regular" class="md-nav__link">
    <span class="md-ellipsis">
      C.11: Make concrete types regular
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c12-dont-make-data-members-const-or-references-in-a-copyable-or-movable-type" class="md-nav__link">
    <span class="md-ellipsis">
      C.12: Don't make data members const or references in a copyable or movable type
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cctor-constructors-assignments-and-destructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.ctor: Constructors, assignments, and destructors
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cdefop-default-operations" class="md-nav__link">
    <span class="md-ellipsis">
      C.defop: Default Operations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.defop: Default Operations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c20-if-you-can-avoid-defining-default-operations-do" class="md-nav__link">
    <span class="md-ellipsis">
      C.20: If you can avoid defining default operations, do
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c21-if-you-define-or-delete-any-copy-move-or-destructor-function-define-or-delete-them-all" class="md-nav__link">
    <span class="md-ellipsis">
      C.21: If you define or =delete any copy, move, or destructor function, define or =delete them all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c22-make-default-operations-consistent" class="md-nav__link">
    <span class="md-ellipsis">
      C.22: Make default operations consistent
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cdtor-destructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.dtor: Destructors
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.dtor: Destructors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction" class="md-nav__link">
    <span class="md-ellipsis">
      C.30: Define a destructor if a class needs an explicit action at object destruction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c31-all-resources-acquired-by-a-class-must-be-released-by-the-classs-destructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.31: All resources acquired by a class must be released by the class's destructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c32-if-a-class-has-a-raw-pointer-t-or-reference-t-consider-whether-it-might-be-owning" class="md-nav__link">
    <span class="md-ellipsis">
      C.32: If a class has a raw pointer (T*) or reference (T&amp;), consider whether it might be owning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c33-if-a-class-has-an-owning-pointer-member-define-a-destructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.33: If a class has an owning pointer member, define a destructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual" class="md-nav__link">
    <span class="md-ellipsis">
      C.35: A base class destructor should be either public and virtual, or protected and non-virtual
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c36-a-destructor-must-not-fail" class="md-nav__link">
    <span class="md-ellipsis">
      C.36: A destructor must not fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c37-make-destructors-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.37: Make destructors noexcept
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cctor-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.ctor: Constructors
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.ctor: Constructors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c40-define-a-constructor-if-a-class-has-an-invariant" class="md-nav__link">
    <span class="md-ellipsis">
      C.40: Define a constructor if a class has an invariant
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c41-a-constructor-should-create-a-fully-initialized-object" class="md-nav__link">
    <span class="md-ellipsis">
      C.41: A constructor should create a fully initialized object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c42-if-a-constructor-cannot-construct-a-valid-object-throw-an-exception" class="md-nav__link">
    <span class="md-ellipsis">
      C.42: If a constructor cannot construct a valid object, throw an exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c43-ensure-that-a-copyable-class-has-a-default-constructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.43: Ensure that a copyable class has a default constructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c44-prefer-default-constructors-to-be-simple-and-non-throwing" class="md-nav__link">
    <span class="md-ellipsis">
      C.44: Prefer default constructors to be simple and non-throwing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c45-dont-define-a-default-constructor-that-only-initializes-data-members-use-default-member-initializers-instead" class="md-nav__link">
    <span class="md-ellipsis">
      C.45: Don't define a default constructor that only initializes data members; use default member initializers instead
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c46-by-default-declare-single-argument-constructors-explicit" class="md-nav__link">
    <span class="md-ellipsis">
      C.46: By default, declare single-argument constructors explicit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c47-define-and-initialize-data-members-in-the-order-of-member-declaration" class="md-nav__link">
    <span class="md-ellipsis">
      C.47: Define and initialize data members in the order of member declaration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c48-prefer-default-member-initializers-to-member-initializers-in-constructors-for-constant-initializers" class="md-nav__link">
    <span class="md-ellipsis">
      C.48: Prefer default member initializers to member initializers in constructors for constant initializers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c49-prefer-initialization-to-assignment-in-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.49: Prefer initialization to assignment in constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization" class="md-nav__link">
    <span class="md-ellipsis">
      C.50: Use a factory function if you need "virtual behavior" during initialization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c51-use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class" class="md-nav__link">
    <span class="md-ellipsis">
      C.51: Use delegating constructors to represent common actions for all constructors of a class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c52-use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization" class="md-nav__link">
    <span class="md-ellipsis">
      C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ccopy-copy-and-move" class="md-nav__link">
    <span class="md-ellipsis">
      C.copy: Copy and move
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.copy: Copy and move">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const" class="md-nav__link">
    <span class="md-ellipsis">
      C.60: Make copy assignment non-virtual, take the parameter by const&amp;, and return by non-const&amp;
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c61-a-copy-operation-should-copy" class="md-nav__link">
    <span class="md-ellipsis">
      C.61: A copy operation should copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c62-make-copy-assignment-safe-for-self-assignment" class="md-nav__link">
    <span class="md-ellipsis">
      C.62: Make copy assignment safe for self-assignment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c63-make-move-assignment-non-virtual-take-the-parameter-by-and-return-by-non-const" class="md-nav__link">
    <span class="md-ellipsis">
      C.63: Make move assignment non-virtual, take the parameter by &amp;&amp;, and return by non-const&amp;
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state" class="md-nav__link">
    <span class="md-ellipsis">
      C.64: A move operation should move and leave its source in a valid state
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c65-make-move-assignment-safe-for-self-assignment" class="md-nav__link">
    <span class="md-ellipsis">
      C.65: Make move assignment safe for self-assignment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c66-make-move-operations-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.66: Make move operations noexcept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c67-a-polymorphic-class-should-suppress-public-copymove" class="md-nav__link">
    <span class="md-ellipsis">
      C.67: A polymorphic class should suppress public copy/move
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cother-other-default-operation-rules" class="md-nav__link">
    <span class="md-ellipsis">
      C.other: Other default operation rules
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.other: Other default operation rules">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c80-use-default-if-you-have-to-be-explicit-about-using-the-default-semantics" class="md-nav__link">
    <span class="md-ellipsis">
      C.80: Use =default if you have to be explicit about using the default semantics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c81-use-delete-when-you-want-to-disable-default-behavior-without-wanting-an-alternative" class="md-nav__link">
    <span class="md-ellipsis">
      C.81: Use =delete when you want to disable default behavior (without wanting an alternative)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c82-dont-call-virtual-functions-in-constructors-and-destructors" class="md-nav__link">
    <span class="md-ellipsis">
      C.82: Don't call virtual functions in constructors and destructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c83-for-value-like-types-consider-providing-a-noexcept-swap-function" class="md-nav__link">
    <span class="md-ellipsis">
      C.83: For value-like types, consider providing a noexcept swap function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c84-a-swap-function-must-not-fail" class="md-nav__link">
    <span class="md-ellipsis">
      C.84: A swap function must not fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c85-make-swap-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.85: Make swap noexcept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c86-make-symmetric-with-respect-to-operand-types-and-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.86: Make == symmetric with respect to operand types and noexcept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c87-beware-of-on-base-classes" class="md-nav__link">
    <span class="md-ellipsis">
      C.87: Beware of == on base classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c89-make-a-hash-noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      C.89: Make a hash noexcept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c90-rely-on-constructors-and-assignment-operators-not-memset-and-memcpy" class="md-nav__link">
    <span class="md-ellipsis">
      C.90: Rely on constructors and assignment operators, not memset and memcpy
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ccon-containers-and-other-resource-handles" class="md-nav__link">
    <span class="md-ellipsis">
      C.con: Containers and other resource handles
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.con: Containers and other resource handles">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c100-follow-the-stl-when-defining-a-container" class="md-nav__link">
    <span class="md-ellipsis">
      C.100: Follow the STL when defining a container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c101-give-a-container-value-semantics" class="md-nav__link">
    <span class="md-ellipsis">
      C.101: Give a container value semantics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c102-give-a-container-move-operations" class="md-nav__link">
    <span class="md-ellipsis">
      C.102: Give a container move operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c103-give-a-container-an-initializer-list-constructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.103: Give a container an initializer list constructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c104-give-a-container-a-default-constructor-that-sets-it-to-empty" class="md-nav__link">
    <span class="md-ellipsis">
      C.104: Give a container a default constructor that sets it to empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c109-if-a-resource-handle-has-pointer-semantics-provide-and-" class="md-nav__link">
    <span class="md-ellipsis">
      C.109: If a resource handle has pointer semantics, provide * and -&gt;
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#clambdas-function-objects-and-lambdas" class="md-nav__link">
    <span class="md-ellipsis">
      C.lambdas: Function objects and lambdas
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chier-class-hierarchies-oop" class="md-nav__link">
    <span class="md-ellipsis">
      C.hier: Class hierarchies (OOP)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.hier: Class hierarchies (OOP)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c120-use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only" class="md-nav__link">
    <span class="md-ellipsis">
      C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c121-if-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class" class="md-nav__link">
    <span class="md-ellipsis">
      C.121: If a base class is used as an interface, make it a pure abstract class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c122-use-abstract-classes-as-interfaces-when-complete-separation-of-interface-and-implementation-is-needed" class="md-nav__link">
    <span class="md-ellipsis">
      C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chierclass-designing-classes-in-a-hierarchy" class="md-nav__link">
    <span class="md-ellipsis">
      C.hierclass: Designing classes in a hierarchy:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.hierclass: Designing classes in a hierarchy:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c126-an-abstract-class-typically-doesnt-need-a-user-written-constructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.126: An abstract class typically doesn't need a user-written constructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor" class="md-nav__link">
    <span class="md-ellipsis">
      C.127: A class with a virtual function should have a virtual or protected destructor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final" class="md-nav__link">
    <span class="md-ellipsis">
      C.128: Virtual functions should specify exactly one of virtual, override, or final
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c129-when-designing-a-class-hierarchy-distinguish-between-implementation-inheritance-and-interface-inheritance" class="md-nav__link">
    <span class="md-ellipsis">
      C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c130-for-making-deep-copies-of-polymorphic-classes-prefer-a-virtual-clone-function-instead-of-public-copy-constructionassignment" class="md-nav__link">
    <span class="md-ellipsis">
      C.130: For making deep copies of polymorphic classes prefer a virtual clone function instead of public copy construction/assignment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c131-avoid-trivial-getters-and-setters" class="md-nav__link">
    <span class="md-ellipsis">
      C.131: Avoid trivial getters and setters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c132-dont-make-a-function-virtual-without-reason" class="md-nav__link">
    <span class="md-ellipsis">
      C.132: Don't make a function virtual without reason
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c133-avoid-protected-data" class="md-nav__link">
    <span class="md-ellipsis">
      C.133: Avoid protected data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c134-ensure-all-non-const-data-members-have-the-same-access-level" class="md-nav__link">
    <span class="md-ellipsis">
      C.134: Ensure all non-const data members have the same access level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c135-use-multiple-inheritance-to-represent-multiple-distinct-interfaces" class="md-nav__link">
    <span class="md-ellipsis">
      C.135: Use multiple inheritance to represent multiple distinct interfaces
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c136-use-multiple-inheritance-to-represent-the-union-of-implementation-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      C.136: Use multiple inheritance to represent the union of implementation attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c137-use-virtual-bases-to-avoid-overly-general-base-classes" class="md-nav__link">
    <span class="md-ellipsis">
      C.137: Use virtual bases to avoid overly general base classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c138-create-an-overload-set-for-a-derived-class-and-its-bases-with-using" class="md-nav__link">
    <span class="md-ellipsis">
      C.138: Create an overload set for a derived class and its bases with using
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c139-use-final-on-classes-sparingly" class="md-nav__link">
    <span class="md-ellipsis">
      C.139: Use final on classes sparingly
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider" class="md-nav__link">
    <span class="md-ellipsis">
      C.140: Do not provide different default arguments for a virtual function and an overrider
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chier-access-accessing-objects-in-a-hierarchy" class="md-nav__link">
    <span class="md-ellipsis">
      C.hier-access: Accessing objects in a hierarchy
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.hier-access: Accessing objects in a hierarchy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c145-access-polymorphic-objects-through-pointers-and-references" class="md-nav__link">
    <span class="md-ellipsis">
      C.145: Access polymorphic objects through pointers and references
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c146-use-dynamic_cast-where-class-hierarchy-navigation-is-unavoidable" class="md-nav__link">
    <span class="md-ellipsis">
      C.146: Use dynamic_cast where class hierarchy navigation is unavoidable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c147-use-dynamic_cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error" class="md-nav__link">
    <span class="md-ellipsis">
      C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c148-use-dynamic_cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative" class="md-nav__link">
    <span class="md-ellipsis">
      C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new" class="md-nav__link">
    <span class="md-ellipsis">
      C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c150-use-make_unique-to-construct-objects-owned-by-unique_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      C.150: Use make_unique() to construct objects owned by unique_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c151-use-make_shared-to-construct-objects-owned-by-shared_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      C.151: Use make_shared() to construct objects owned by shared_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base" class="md-nav__link">
    <span class="md-ellipsis">
      C.152: Never assign a pointer to an array of derived class objects to a pointer to its base
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c153-prefer-virtual-function-to-casting" class="md-nav__link">
    <span class="md-ellipsis">
      C.153: Prefer virtual function to casting
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cover-overloading-and-overloaded-operators" class="md-nav__link">
    <span class="md-ellipsis">
      C.over: Overloading and overloaded operators
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.over: Overloading and overloaded operators">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c160-define-operators-primarily-to-mimic-conventional-usage" class="md-nav__link">
    <span class="md-ellipsis">
      C.160: Define operators primarily to mimic conventional usage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c161-use-non-member-functions-for-symmetric-operators" class="md-nav__link">
    <span class="md-ellipsis">
      C.161: Use non-member functions for symmetric operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c162-overload-operations-that-are-roughly-equivalent" class="md-nav__link">
    <span class="md-ellipsis">
      C.162: Overload operations that are roughly equivalent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c163-overload-only-for-operations-that-are-roughly-equivalent" class="md-nav__link">
    <span class="md-ellipsis">
      C.163: Overload only for operations that are roughly equivalent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c164-avoid-implicit-conversion-operators" class="md-nav__link">
    <span class="md-ellipsis">
      C.164: Avoid implicit conversion operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c165-use-using-for-customization-points" class="md-nav__link">
    <span class="md-ellipsis">
      C.165: Use using for customization points
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c166-overload-unary-only-as-part-of-a-system-of-smart-pointers-and-references" class="md-nav__link">
    <span class="md-ellipsis">
      C.166: Overload unary &amp; only as part of a system of smart pointers and references
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c167-use-an-operator-for-an-operation-with-its-conventional-meaning" class="md-nav__link">
    <span class="md-ellipsis">
      C.167: Use an operator for an operation with its conventional meaning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c168-define-overloaded-operators-in-the-namespace-of-their-operands" class="md-nav__link">
    <span class="md-ellipsis">
      C.168: Define overloaded operators in the namespace of their operands
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c170-if-you-feel-like-overloading-a-lambda-use-a-generic-lambda" class="md-nav__link">
    <span class="md-ellipsis">
      C.170: If you feel like overloading a lambda, use a generic lambda
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cunion-unions" class="md-nav__link">
    <span class="md-ellipsis">
      C.union: Unions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="C.union: Unions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c180-use-unions-to-save-memory" class="md-nav__link">
    <span class="md-ellipsis">
      C.180: Use unions to save memory
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c181-avoid-naked-unions" class="md-nav__link">
    <span class="md-ellipsis">
      C.181: Avoid "naked" unions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c182-use-anonymous-unions-to-implement-tagged-unions" class="md-nav__link">
    <span class="md-ellipsis">
      C.182: Use anonymous unions to implement tagged unions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c183-dont-use-a-union-for-type-punning" class="md-nav__link">
    <span class="md-ellipsis">
      C.183: Don't use a union for type punning
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="c-classes-and-class-hierarchies-s-class">C: Classes and class hierarchies {#S-class}<a class="headerlink" href="#c-classes-and-class-hierarchies-s-class" title="Permanent link">&para;</a></h1>
<p>A class is a user-defined type, for which a programmer can define the representation, operations, and interfaces.
Class hierarchies are used to organize related classes into hierarchical structures.</p>
<p>Class rule summary:</p>
<ul>
<li><a href="#Rc-org">C.1: Organize related data into structures (<code>struct</code>s or <code>class</code>es)</a></li>
<li><a href="#Rc-struct">C.2: Use <code>class</code> if the class has an invariant; use <code>struct</code> if the data members can vary independently</a></li>
<li><a href="#Rc-interface">C.3: Represent the distinction between an interface and an implementation using a class</a></li>
<li><a href="#Rc-member">C.4: Make a function a member only if it needs direct access to the representation of a class</a></li>
<li><a href="#Rc-helper">C.5: Place helper functions in the same namespace as the class they support</a></li>
<li><a href="#Rc-standalone">C.7: Don't define a class or enum and declare a variable of its type in the same statement</a></li>
<li><a href="#Rc-class">C.8: Use <code>class</code> rather than <code>struct</code> if any member is non-public</a></li>
<li><a href="#Rc-private">C.9: Minimize exposure of members</a></li>
</ul>
<p>Subsections:</p>
<ul>
<li><a href="#SS-concrete">C.concrete: Concrete types</a></li>
<li><a href="#S-ctor">C.ctor: Constructors, assignments, and destructors</a></li>
<li><a href="#SS-containers">C.con: Containers and other resource handles</a></li>
<li><a href="#SS-lambdas">C.lambdas: Function objects and lambdas</a></li>
<li><a href="#SS-hier">C.hier: Class hierarchies (OOP)</a></li>
<li><a href="#SS-overload">C.over: Overloading and overloaded operators</a></li>
<li><a href="#SS-union">C.union: Unions</a></li>
</ul>
<h3 id="c1-organize-related-data-into-structures-structs-or-classes"><a name="Rc-org"></a>C.1: Organize related data into structures (<code>struct</code>s or <code>class</code>es)<a class="headerlink" href="#c1-organize-related-data-into-structures-structs-or-classes" title="Permanent link">&para;</a></h3>
<h5 id="reason">Reason<a class="headerlink" href="#reason" title="Permanent link">&para;</a></h5>
<p>Ease of comprehension.
If data is related (for fundamental reasons), that fact should be reflected in code.</p>
<h5 id="example">Example<a class="headerlink" href="#example" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void draw(int x, int y, int x2, int y2);  // BAD: unnecessary implicit relationships
void draw(Point from, Point to);          // better
</code></pre></div>
<h5 id="note">Note<a class="headerlink" href="#note" title="Permanent link">&para;</a></h5>
<p>A simple class without virtual functions implies no space or time overhead.</p>
<h5 id="note_1">Note<a class="headerlink" href="#note_1" title="Permanent link">&para;</a></h5>
<p>From a language perspective <code>class</code> and <code>struct</code> differ only in the default visibility of their members.</p>
<h5 id="enforcement">Enforcement<a class="headerlink" href="#enforcement" title="Permanent link">&para;</a></h5>
<p>Probably impossible. Maybe a heuristic looking for data items used together is possible.</p>
<h3 id="c2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently"><a name="Rc-struct"></a>C.2: Use <code>class</code> if the class has an invariant; use <code>struct</code> if the data members can vary independently<a class="headerlink" href="#c2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently" title="Permanent link">&para;</a></h3>
<h5 id="reason_1">Reason<a class="headerlink" href="#reason_1" title="Permanent link">&para;</a></h5>
<p>Readability.
Ease of comprehension.
The use of <code>class</code> alerts the programmer to the need for an invariant.
This is a useful convention.</p>
<h5 id="note_2">Note<a class="headerlink" href="#note_2" title="Permanent link">&para;</a></h5>
<p>An invariant is a logical condition for the members of an object that a constructor must establish for the public member functions to assume.
After the invariant is established (typically by a constructor) every member function can be called for the object.
An invariant can be stated informally (e.g., in a comment) or more formally using <code>Expects</code>.</p>
<p>If all data members can vary independently of each other, no invariant is possible.</p>
<h5 id="example_1">Example<a class="headerlink" href="#example_1" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Pair {  // the members can vary independently
    string name;
    int volume;
};
</code></pre></div>
<p>but:</p>
<div class="language-text highlight"><pre><span></span><code>class Date {
public:
    // validate that {yy, mm, dd} is a valid date and initialize
    Date(int yy, Month mm, char dd);
    // ...
private:
    int y;
    Month m;
    char d;    // day
};
</code></pre></div>
<h5 id="note_3">Note<a class="headerlink" href="#note_3" title="Permanent link">&para;</a></h5>
<p>If a class has any <code>private</code> data, a user cannot completely initialize an object without the use of a constructor.
Hence, the class definer will provide a constructor and must specify its meaning.
This effectively means the definer need to define an invariant.</p>
<p><strong>See also</strong>:</p>
<ul>
<li><a href="#Rc-class">define a class with private data as <code>class</code></a></li>
<li><a href="#Rl-order">Prefer to place the interface first in a class</a></li>
<li><a href="#Rc-private">minimize exposure of members</a></li>
<li><a href="#Rh-protected">Avoid <code>protected</code> data</a></li>
</ul>
<h5 id="enforcement_1">Enforcement<a class="headerlink" href="#enforcement_1" title="Permanent link">&para;</a></h5>
<p>Look for <code>struct</code>s with all data private and <code>class</code>es with public members.</p>
<h3 id="c3-represent-the-distinction-between-an-interface-and-an-implementation-using-a-class"><a name="Rc-interface"></a>C.3: Represent the distinction between an interface and an implementation using a class<a class="headerlink" href="#c3-represent-the-distinction-between-an-interface-and-an-implementation-using-a-class" title="Permanent link">&para;</a></h3>
<h5 id="reason_2">Reason<a class="headerlink" href="#reason_2" title="Permanent link">&para;</a></h5>
<p>An explicit distinction between interface and implementation improves readability and simplifies maintenance.</p>
<h5 id="example_2">Example<a class="headerlink" href="#example_2" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Date {
public:
    Date();
    // validate that {yy, mm, dd} is a valid date and initialize
    Date(int yy, Month mm, char dd);

    int day() const;
    Month month() const;
    // ...
private:
    // ... some representation ...
};
</code></pre></div>
<p>For example, we can now change the representation of a <code>Date</code> without affecting its users (recompilation is likely, though).</p>
<h5 id="note_4">Note<a class="headerlink" href="#note_4" title="Permanent link">&para;</a></h5>
<p>Using a class in this way to represent the distinction between interface and implementation is of course not the only way.
For example, we can use a set of declarations of freestanding functions in a namespace, an abstract base class, or a function template with concepts to represent an interface.
The most important issue is to explicitly distinguish between an interface and its implementation "details."
Ideally, and typically, an interface is far more stable than its implementation(s).</p>
<h5 id="enforcement_2">Enforcement<a class="headerlink" href="#enforcement_2" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class"><a name="Rc-member"></a>C.4: Make a function a member only if it needs direct access to the representation of a class<a class="headerlink" href="#c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class" title="Permanent link">&para;</a></h3>
<h5 id="reason_3">Reason<a class="headerlink" href="#reason_3" title="Permanent link">&para;</a></h5>
<p>Less coupling than with member functions, fewer functions that can cause trouble by modifying object state, reduces the number of functions that needs to be modified after a change in representation.</p>
<h5 id="example_3">Example<a class="headerlink" href="#example_3" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Date {
    // ... relatively small interface ...
};

// helper functions:
Date next_weekday(Date);
bool operator==(Date, Date);
</code></pre></div>
<p>The "helper functions" have no need for direct access to the representation of a <code>Date</code>.</p>
<h5 id="note_5">Note<a class="headerlink" href="#note_5" title="Permanent link">&para;</a></h5>
<p>This rule becomes even better if C++ gets <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf">"uniform function call"</a>.</p>
<h5 id="exception">Exception<a class="headerlink" href="#exception" title="Permanent link">&para;</a></h5>
<p>The language requires <code>virtual</code> functions to be members, and not all <code>virtual</code> functions directly access data.
In particular, members of an abstract class rarely do.</p>
<p>Note <a href="https://web.archive.org/web/20200605021759/https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf">multi-methods</a>.</p>
<h5 id="exception_1">Exception<a class="headerlink" href="#exception_1" title="Permanent link">&para;</a></h5>
<p>The language requires operators <code>=</code>, <code>()</code>, <code>[]</code>, and <code>-&gt;</code> to be members.</p>
<h5 id="exception_2">Exception<a class="headerlink" href="#exception_2" title="Permanent link">&para;</a></h5>
<p>An overload set could have some members that do not directly access <code>private</code> data:</p>
<div class="language-text highlight"><pre><span></span><code>class Foobar {
public:
    void foo(long x) { /* manipulate private data */ }
    void foo(double x) { foo(std::lround(x)); }
    // ...
private:
    // ...
};
</code></pre></div>
<h5 id="exception_3">Exception<a class="headerlink" href="#exception_3" title="Permanent link">&para;</a></h5>
<p>Similarly, a set of functions could be designed to be used in a chain:</p>
<div class="language-text highlight"><pre><span></span><code>x.scale(0.5).rotate(45).set_color(Color::red);
</code></pre></div>
<p>Typically, some but not all of such functions directly access <code>private</code> data.</p>
<h5 id="enforcement_3">Enforcement<a class="headerlink" href="#enforcement_3" title="Permanent link">&para;</a></h5>
<ul>
<li>Look for non-<code>virtual</code> member functions that do not touch data members directly.
The snag is that many member functions that do not need to touch data members directly do.</li>
<li>Ignore <code>virtual</code> functions.</li>
<li>Ignore functions that are part of an overload set out of which at least one function accesses <code>private</code> members.</li>
<li>Ignore functions returning <code>this</code>.</li>
</ul>
<h3 id="c5-place-helper-functions-in-the-same-namespace-as-the-class-they-support"><a name="Rc-helper"></a>C.5: Place helper functions in the same namespace as the class they support<a class="headerlink" href="#c5-place-helper-functions-in-the-same-namespace-as-the-class-they-support" title="Permanent link">&para;</a></h3>
<h5 id="reason_4">Reason<a class="headerlink" href="#reason_4" title="Permanent link">&para;</a></h5>
<p>A helper function is a function (usually supplied by the writer of a class) that does not need direct access to the representation of the class, yet is seen as part of the useful interface to the class.
Placing them in the same namespace as the class makes their relationship to the class obvious and allows them to be found by argument dependent lookup.</p>
<h5 id="example_4">Example<a class="headerlink" href="#example_4" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>namespace Chrono { // here we keep time-related services

    class Time { /* ... */ };
    class Date { /* ... */ };

    // helper functions:
    bool operator==(Date, Date);
    Date next_weekday(Date);
    // ...
}
</code></pre></div>
<h5 id="note_6">Note<a class="headerlink" href="#note_6" title="Permanent link">&para;</a></h5>
<p>This is especially important for <a href="#Ro-namespace">overloaded operators</a>.</p>
<h5 id="enforcement_4">Enforcement<a class="headerlink" href="#enforcement_4" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag global functions taking argument types from a single namespace.</li>
</ul>
<h3 id="c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement"><a name="Rc-standalone"></a>C.7: Don't define a class or enum and declare a variable of its type in the same statement<a class="headerlink" href="#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement" title="Permanent link">&para;</a></h3>
<h5 id="reason_5">Reason<a class="headerlink" href="#reason_5" title="Permanent link">&para;</a></h5>
<p>Mixing a type definition and the definition of another entity in the same declaration is confusing and unnecessary.</p>
<h5 id="example-bad">Example, bad<a class="headerlink" href="#example-bad" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Data { /*...*/ } data{ /*...*/ };
</code></pre></div>
<h5 id="example-good">Example, good<a class="headerlink" href="#example-good" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Data { /*...*/ };
Data data{ /*...*/ };
</code></pre></div>
<h5 id="enforcement_5">Enforcement<a class="headerlink" href="#enforcement_5" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag if the <code>}</code> of a class or enumeration definition is not followed by a <code>;</code>. The <code>;</code> is missing.</li>
</ul>
<h3 id="c8-use-class-rather-than-struct-if-any-member-is-non-public"><a name="Rc-class"></a>C.8: Use <code>class</code> rather than <code>struct</code> if any member is non-public<a class="headerlink" href="#c8-use-class-rather-than-struct-if-any-member-is-non-public" title="Permanent link">&para;</a></h3>
<h5 id="reason_6">Reason<a class="headerlink" href="#reason_6" title="Permanent link">&para;</a></h5>
<p>Readability.
To make it clear that something is being hidden/abstracted.
This is a useful convention.</p>
<h5 id="example-bad_1">Example, bad<a class="headerlink" href="#example-bad_1" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Date {
    int d, m;

    Date(int i, Month m);
    // ... lots of functions ...
private:
    int y;  // year
};
</code></pre></div>
<p>There is nothing wrong with this code as far as the C++ language rules are concerned,
but nearly everything is wrong from a design perspective.
The private data is hidden far from the public data.
The data is split in different parts of the class declaration.
Different parts of the data have different access.
All of this decreases readability and complicates maintenance.</p>
<h5 id="note_7">Note<a class="headerlink" href="#note_7" title="Permanent link">&para;</a></h5>
<p>Prefer to place the interface first in a class, <a href="#Rl-order">see NL.16</a>.</p>
<h5 id="enforcement_6">Enforcement<a class="headerlink" href="#enforcement_6" title="Permanent link">&para;</a></h5>
<p>Flag classes declared with <code>struct</code> if there is a <code>private</code> or <code>protected</code> member.</p>
<h3 id="c9-minimize-exposure-of-members"><a name="Rc-private"></a>C.9: Minimize exposure of members<a class="headerlink" href="#c9-minimize-exposure-of-members" title="Permanent link">&para;</a></h3>
<h5 id="reason_7">Reason<a class="headerlink" href="#reason_7" title="Permanent link">&para;</a></h5>
<p>Encapsulation.
Information hiding.
Minimize the chance of unintended access.
This simplifies maintenance.</p>
<h5 id="example_5">Example<a class="headerlink" href="#example_5" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T, typename U&gt;
struct pair {
    T a;
    U b;
    // ...
};
</code></pre></div>
<p>Whatever we do in the <code>//</code>-part, an arbitrary user of a <code>pair</code> can arbitrarily and independently change its <code>a</code> and <code>b</code>.
In a large code base, we cannot easily find which code does what to the members of <code>pair</code>.
This might be exactly what we want, but if we want to enforce a relation among members, we need to make them <code>private</code>
and enforce that relation (invariant) through constructors and member functions.
For example:</p>
<div class="language-text highlight"><pre><span></span><code>class Distance {
public:
    // ...
    double meters() const { return magnitude*unit; }
    void set_unit(double u)
    {
            // ... check that u is a factor of 10 ...
            // ... change magnitude appropriately ...
            unit = u;
    }
    // ...
private:
    double magnitude;
    double unit;    // 1 is meters, 1000 is kilometers, 0.001 is millimeters, etc.
};
</code></pre></div>
<h5 id="note_8">Note<a class="headerlink" href="#note_8" title="Permanent link">&para;</a></h5>
<p>If the set of direct users of a set of variables cannot be easily determined, the type or usage of that set cannot be (easily) changed/improved.
For <code>public</code> and <code>protected</code> data, that's usually the case.</p>
<h5 id="example_6">Example<a class="headerlink" href="#example_6" title="Permanent link">&para;</a></h5>
<p>A class can provide two interfaces to its users.
One for derived classes (<code>protected</code>) and one for general users (<code>public</code>).
For example, a derived class might be allowed to skip a run-time check because it has already guaranteed correctness:</p>
<div class="language-text highlight"><pre><span></span><code>class Foo {
public:
    int bar(int x) { check(x); return do_bar(x); }
    // ...
protected:
    int do_bar(int x); // do some operation on the data
    // ...
private:
    // ... data ...
};

class Dir : public Foo {
    //...
    int mem(int x, int y)
    {
        /* ... do something ... */
        return do_bar(x + y); // OK: derived class can bypass check
    }
};

void user(Foo&amp; x)
{
    int r1 = x.bar(1);      // OK, will check
    int r2 = x.do_bar(2);   // error: would bypass check
    // ...
}
</code></pre></div>
<h5 id="note_9">Note<a class="headerlink" href="#note_9" title="Permanent link">&para;</a></h5>
<p><a href="#Rh-protected"><code>protected</code> data is a bad idea</a>.</p>
<h5 id="note_10">Note<a class="headerlink" href="#note_10" title="Permanent link">&para;</a></h5>
<p>Prefer the order <code>public</code> members before <code>protected</code> members before <code>private</code> members; see <a href="#Rl-order">NL.16</a>.</p>
<h5 id="enforcement_7">Enforcement<a class="headerlink" href="#enforcement_7" title="Permanent link">&para;</a></h5>
<ul>
<li><a href="#Rh-protected">Flag protected data</a>.</li>
<li>Flag mixtures of <code>public</code> and <code>private</code> data</li>
</ul>
<h2 id="cconcrete-concrete-types"><a name="SS-concrete"></a>C.concrete: Concrete types<a class="headerlink" href="#cconcrete-concrete-types" title="Permanent link">&para;</a></h2>
<p>Concrete type rule summary:</p>
<ul>
<li><a href="#Rc-concrete">C.10: Prefer concrete types over class hierarchies</a></li>
<li><a href="#Rc-regular">C.11: Make concrete types regular</a></li>
<li><a href="#Rc-constref">C.12: Don't make data members <code>const</code> or references in a copyable or movable type</a></li>
</ul>
<h3 id="c10-prefer-concrete-types-over-class-hierarchies"><a name="Rc-concrete"></a>C.10: Prefer concrete types over class hierarchies<a class="headerlink" href="#c10-prefer-concrete-types-over-class-hierarchies" title="Permanent link">&para;</a></h3>
<h5 id="reason_8">Reason<a class="headerlink" href="#reason_8" title="Permanent link">&para;</a></h5>
<p>A concrete type is fundamentally simpler than a type in a class hierarchy:
easier to design, easier to implement, easier to use, easier to reason about, smaller, and faster.
You need a reason (use cases) for using a hierarchy.</p>
<h5 id="example_7">Example<a class="headerlink" href="#example_7" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Point1 {
    int x, y;
    // ... operations ...
    // ... no virtual functions ...
};

class Point2 {
    int x, y;
    // ... operations, some virtual ...
    virtual ~Point2();
};

void use()
{
    Point1 p11 {1, 2};   // make an object on the stack
    Point1 p12 {p11};    // a copy

    auto p21 = make_unique&lt;Point2&gt;(1, 2);   // make an object on the free store
    auto p22 = p21-&gt;clone();                // make a copy
    // ...
}
</code></pre></div>
<p>If a class is part of a hierarchy, we (in real code if not necessarily in small examples) must manipulate its objects through pointers or references.
That implies more memory overhead, more allocations and deallocations, and more run-time overhead to perform the resulting indirections.</p>
<h5 id="note_11">Note<a class="headerlink" href="#note_11" title="Permanent link">&para;</a></h5>
<p>Concrete types can be stack-allocated and be members of other classes.</p>
<h5 id="note_12">Note<a class="headerlink" href="#note_12" title="Permanent link">&para;</a></h5>
<p>The use of indirection is fundamental for run-time polymorphic interfaces.
The allocation/deallocation overhead is not (that's just the most common case).
We can use a base class as the interface of a scoped object of a derived class.
This is done where dynamic allocation is prohibited (e.g. hard-real-time) and to provide a stable interface to some kinds of plug-ins.</p>
<h5 id="enforcement_8">Enforcement<a class="headerlink" href="#enforcement_8" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c11-make-concrete-types-regular"><a name="Rc-regular"></a>C.11: Make concrete types regular<a class="headerlink" href="#c11-make-concrete-types-regular" title="Permanent link">&para;</a></h3>
<h5 id="reason_9">Reason<a class="headerlink" href="#reason_9" title="Permanent link">&para;</a></h5>
<p>Regular types are easier to understand and reason about than types that are not regular (irregularities requires extra effort to understand and use).</p>
<p>The C++ built-in types are regular, and so are standard-library classes such as <code>string</code>, <code>vector</code>, and <code>map</code>. Concrete classes without assignment and equality can be defined, but they are (and should be) rare.</p>
<h5 id="example_8">Example<a class="headerlink" href="#example_8" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Bundle {
    string name;
    vector&lt;Record&gt; vr;
};

bool operator==(const Bundle&amp; a, const Bundle&amp; b)
{
    return a.name == b.name &amp;&amp; a.vr == b.vr;
}

Bundle b1 { &quot;my bundle&quot;, {r1, r2, r3}};
Bundle b2 = b1;
if (!(b1 == b2)) error(&quot;impossible!&quot;);
b2.name = &quot;the other bundle&quot;;
if (b1 == b2) error(&quot;No!&quot;);
</code></pre></div>
<p>In particular, if a concrete type is copyable, prefer to also give it an equality comparison operator, and ensure that <code>a = b</code> implies <code>a == b</code>.</p>
<h5 id="note_13">Note<a class="headerlink" href="#note_13" title="Permanent link">&para;</a></h5>
<p>For structs intended to be shared with C code, defining <code>operator==</code> may not be feasible.</p>
<h5 id="note_14">Note<a class="headerlink" href="#note_14" title="Permanent link">&para;</a></h5>
<p>Handles for resources that cannot be cloned, e.g., a <code>scoped_lock</code> for a <code>mutex</code>, are concrete types but typically cannot be copied (instead, they can usually be moved),
so they can't be regular; instead, they tend to be move-only.</p>
<h5 id="enforcement_9">Enforcement<a class="headerlink" href="#enforcement_9" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c12-dont-make-data-members-const-or-references-in-a-copyable-or-movable-type"><a name="Rc-constref"></a>C.12: Don't make data members <code>const</code> or references in a copyable or movable type<a class="headerlink" href="#c12-dont-make-data-members-const-or-references-in-a-copyable-or-movable-type" title="Permanent link">&para;</a></h3>
<h5 id="reason_10">Reason<a class="headerlink" href="#reason_10" title="Permanent link">&para;</a></h5>
<p><code>const</code> and reference data members are not useful in a copyable or movable type, and make such types difficult to use by making them at least partly uncopyable/unmovable for subtle reasons.</p>
<h5 id="example-bad_2">Example; bad<a class="headerlink" href="#example-bad_2" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class bad {
    const int i;    // bad
    string&amp; s;      // bad
    // ...
};
</code></pre></div>
<p>The <code>const</code> and <code>&amp;</code> data members make this class "only-sort-of-copyable" -- copy-constructible but not copy-assignable.</p>
<h5 id="note_15">Note<a class="headerlink" href="#note_15" title="Permanent link">&para;</a></h5>
<p>If you need a member to point to something, use a pointer (raw or smart, and <code>gsl::not_null</code> if it should not be null) instead of a reference.</p>
<h5 id="enforcement_10">Enforcement<a class="headerlink" href="#enforcement_10" title="Permanent link">&para;</a></h5>
<p>Flag a data member that is <code>const</code>, <code>&amp;</code>, or <code>&amp;&amp;</code> in a type that has any copy or move operation.</p>
<h2 id="cctor-constructors-assignments-and-destructors"><a name="S-ctor"></a>C.ctor: Constructors, assignments, and destructors<a class="headerlink" href="#cctor-constructors-assignments-and-destructors" title="Permanent link">&para;</a></h2>
<p>These functions control the lifecycle of objects: creation, copy, move, and destruction.
Define constructors to guarantee and simplify initialization of classes.</p>
<p>These are <em>default operations</em>:</p>
<ul>
<li>a default constructor: <code>X()</code></li>
<li>a copy constructor: <code>X(const X&amp;)</code></li>
<li>a copy assignment: <code>operator=(const X&amp;)</code></li>
<li>a move constructor: <code>X(X&amp;&amp;)</code></li>
<li>a move assignment: <code>operator=(X&amp;&amp;)</code></li>
<li>a destructor: <code>~X()</code></li>
</ul>
<p>By default, the compiler defines each of these operations if it is used, but the default can be suppressed.</p>
<p>The default operations are a set of related operations that together implement the lifecycle semantics of an object.
By default, C++ treats classes as value-like types, but not all types are value-like.</p>
<p>Set of default operations rules:</p>
<ul>
<li><a href="#Rc-zero">C.20: If you can avoid defining any default operations, do</a></li>
<li><a href="#Rc-five">C.21: If you define or <code>=delete</code> any copy, move, or destructor function, define or <code>=delete</code> them all</a></li>
<li><a href="#Rc-matched">C.22: Make default operations consistent</a></li>
</ul>
<p>Destructor rules:</p>
<ul>
<li><a href="#Rc-dtor">C.30: Define a destructor if a class needs an explicit action at object destruction</a></li>
<li><a href="#Rc-dtor-release">C.31: All resources acquired by a class must be released by the class's destructor</a></li>
<li><a href="#Rc-dtor-ptr">C.32: If a class has a raw pointer (<code>T*</code>) or reference (<code>T&amp;</code>), consider whether it might be owning</a></li>
<li><a href="#Rc-dtor-ptr2">C.33: If a class has an owning pointer member, define a destructor</a></li>
<li><a href="#Rc-dtor-virtual">C.35: A base class destructor should be either public and virtual, or protected and non-virtual</a></li>
<li><a href="#Rc-dtor-fail">C.36: A destructor must not fail</a></li>
<li><a href="#Rc-dtor-noexcept">C.37: Make destructors <code>noexcept</code></a></li>
</ul>
<p>Constructor rules:</p>
<ul>
<li><a href="#Rc-ctor">C.40: Define a constructor if a class has an invariant</a></li>
<li><a href="#Rc-complete">C.41: A constructor should create a fully initialized object</a></li>
<li><a href="#Rc-throw">C.42: If a constructor cannot construct a valid object, throw an exception</a></li>
<li><a href="#Rc-default0">C.43: Ensure that a copyable class has a default constructor</a></li>
<li><a href="#Rc-default00">C.44: Prefer default constructors to be simple and non-throwing</a></li>
<li><a href="#Rc-default">C.45: Don't define a default constructor that only initializes data members; use member initializers instead</a></li>
<li><a href="#Rc-explicit">C.46: By default, declare single-argument constructors <code>explicit</code></a></li>
<li><a href="#Rc-order">C.47: Define and initialize data members in the order of member declaration</a></li>
<li><a href="#Rc-in-class-initializer">C.48: Prefer default member initializers to member initializers in constructors for constant initializers</a></li>
<li><a href="#Rc-initialize">C.49: Prefer initialization to assignment in constructors</a></li>
<li><a href="#Rc-factory">C.50: Use a factory function if you need "virtual behavior" during initialization</a></li>
<li><a href="#Rc-delegating">C.51: Use delegating constructors to represent common actions for all constructors of a class</a></li>
<li><a href="#Rc-inheriting">C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization</a></li>
</ul>
<p>Copy and move rules:</p>
<ul>
<li><a href="#Rc-copy-assignment">C.60: Make copy assignment non-<code>virtual</code>, take the parameter by <code>const&amp;</code>, and return by non-<code>const&amp;</code></a></li>
<li><a href="#Rc-copy-semantic">C.61: A copy operation should copy</a></li>
<li><a href="#Rc-copy-self">C.62: Make copy assignment safe for self-assignment</a></li>
<li><a href="#Rc-move-assignment">C.63: Make move assignment non-<code>virtual</code>, take the parameter by <code>&amp;&amp;</code>, and return by non-<code>const&amp;</code></a></li>
<li><a href="#Rc-move-semantic">C.64: A move operation should move and leave its source in a valid state</a></li>
<li><a href="#Rc-move-self">C.65: Make move assignment safe for self-assignment</a></li>
<li><a href="#Rc-move-noexcept">C.66: Make move operations <code>noexcept</code></a></li>
<li><a href="#Rc-copy-virtual">C.67: A polymorphic class should suppress public copy/move</a></li>
</ul>
<p>Other default operations rules:</p>
<ul>
<li><a href="#Rc-eqdefault">C.80: Use <code>=default</code> if you have to be explicit about using the default semantics</a></li>
<li><a href="#Rc-delete">C.81: Use <code>=delete</code> when you want to disable default behavior (without wanting an alternative)</a></li>
<li><a href="#Rc-ctor-virtual">C.82: Don't call virtual functions in constructors and destructors</a></li>
<li><a href="#Rc-swap">C.83: For value-like types, consider providing a <code>noexcept</code> swap function</a></li>
<li><a href="#Rc-swap-fail">C.84: A <code>swap</code> must not fail</a></li>
<li><a href="#Rc-swap-noexcept">C.85: Make <code>swap</code> <code>noexcept</code></a></li>
<li><a href="#Rc-eq">C.86: Make <code>==</code> symmetric with respect of operand types and <code>noexcept</code></a></li>
<li><a href="#Rc-eq-base">C.87: Beware of <code>==</code> on base classes</a></li>
<li><a href="#Rc-hash">C.89: Make a <code>hash</code> <code>noexcept</code></a></li>
<li><a href="#Rc-memset">C.90: Rely on constructors and assignment operators, not memset and memcpy</a></li>
</ul>
<h2 id="cdefop-default-operations"><a name="SS-defop"></a>C.defop: Default Operations<a class="headerlink" href="#cdefop-default-operations" title="Permanent link">&para;</a></h2>
<p>By default, the language supplies the default operations with their default semantics.
However, a programmer can disable or replace these defaults.</p>
<h3 id="c20-if-you-can-avoid-defining-default-operations-do"><a name="Rc-zero"></a>C.20: If you can avoid defining default operations, do<a class="headerlink" href="#c20-if-you-can-avoid-defining-default-operations-do" title="Permanent link">&para;</a></h3>
<h5 id="reason_11">Reason<a class="headerlink" href="#reason_11" title="Permanent link">&para;</a></h5>
<p>It's the simplest and gives the cleanest semantics.</p>
<h5 id="example_9">Example<a class="headerlink" href="#example_9" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Named_map {
public:
    explicit Named_map(const string&amp; n) : name(n) {}
    // no copy/move constructors
    // no copy/move assignment operators
    // no destructor
private:
    string name;
    map&lt;int, int&gt; rep;
};

Named_map nm(&quot;map&quot;); // construct
Named_map nm2 {nm};  // copy construct
</code></pre></div>
<p>Since <code>std::map</code> and <code>string</code> have all the special functions, no further work is needed.</p>
<h5 id="note_16">Note<a class="headerlink" href="#note_16" title="Permanent link">&para;</a></h5>
<p>This is known as "the rule of zero".</p>
<h5 id="enforcement_11">Enforcement<a class="headerlink" href="#enforcement_11" title="Permanent link">&para;</a></h5>
<p>(Not enforceable) While not enforceable, a good static analyzer can detect patterns that indicate a possible improvement to meet this rule.
For example, a class with a (pointer, size) pair of members and a destructor that <code>delete</code>s the pointer could probably be converted to a <code>vector</code>.</p>
<h3 id="c21-if-you-define-or-delete-any-copy-move-or-destructor-function-define-or-delete-them-all"><a name="Rc-five"></a>C.21: If you define or <code>=delete</code> any copy, move, or destructor function, define or <code>=delete</code> them all<a class="headerlink" href="#c21-if-you-define-or-delete-any-copy-move-or-destructor-function-define-or-delete-them-all" title="Permanent link">&para;</a></h3>
<h5 id="reason_12">Reason<a class="headerlink" href="#reason_12" title="Permanent link">&para;</a></h5>
<p>The semantics of copy, move, and destruction are closely related, so if one needs to be declared, the odds are that others need consideration too.</p>
<p>Declaring any copy/move/destructor function,
even as <code>=default</code> or <code>=delete</code>, will suppress the implicit declaration
of a move constructor and move assignment operator.
Declaring a move constructor or move assignment operator, even as
<code>=default</code> or <code>=delete</code>, will cause an implicitly generated copy constructor
or implicitly generated copy assignment operator to be defined as deleted.
So as soon as any of these are declared, the others should
all be declared to avoid unwanted effects like turning all potential moves
into more expensive copies, or making a class move-only.</p>
<h5 id="example-bad_3">Example, bad<a class="headerlink" href="#example-bad_3" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct M2 {   // bad: incomplete set of copy/move/destructor operations
public:
    // ...
    // ... no copy or move operations ...
    ~M2() { delete[] rep; }
private:
    pair&lt;int, int&gt;* rep;  // zero-terminated set of pairs
};

void use()
{
    M2 x;
    M2 y;
    // ...
    x = y;   // the default assignment
    // ...
}
</code></pre></div>
<p>Given that "special attention" was needed for the destructor (here, to deallocate), the likelihood that the implicitly-defined copy and move assignment operators will be correct is low (here, we would get double deletion).</p>
<h5 id="note_17">Note<a class="headerlink" href="#note_17" title="Permanent link">&para;</a></h5>
<p>This is known as "the rule of five."</p>
<h5 id="note_18">Note<a class="headerlink" href="#note_18" title="Permanent link">&para;</a></h5>
<p>If you want a default implementation (while defining another), write <code>=default</code> to show you're doing so intentionally for that function.
If you don't want a generated default function, suppress it with <code>=delete</code>.</p>
<h5 id="example-good_1">Example, good<a class="headerlink" href="#example-good_1" title="Permanent link">&para;</a></h5>
<p>When a destructor needs to be declared just to make it <code>virtual</code>, it can be
defined as defaulted.</p>
<div class="language-text highlight"><pre><span></span><code>class AbstractBase {
public:
    virtual void foo() = 0;  // at least one abstract method to make the class abstract
    virtual ~AbstractBase() = default;
    // ...
};
</code></pre></div>
<p>To prevent slicing as per <a href="#Rc-copy-virtual">C.67</a>,
make the copy and move operations protected or <code>=delete</code>d, and add a <code>clone</code>:</p>
<div class="language-text highlight"><pre><span></span><code>class CloneableBase {
public:
    virtual unique_ptr&lt;CloneableBase&gt; clone() const;
    virtual ~CloneableBase() = default;
    CloneableBase() = default;
    CloneableBase(const CloneableBase&amp;) = delete;
    CloneableBase&amp; operator=(const CloneableBase&amp;) = delete;
    CloneableBase(CloneableBase&amp;&amp;) = delete;
    CloneableBase&amp; operator=(CloneableBase&amp;&amp;) = delete;
    // ... other constructors and functions ...
};
</code></pre></div>
<p>Defining only the move operations or only the copy operations would have the
same effect here, but stating the intent explicitly for each special member
makes it more obvious to the reader.</p>
<h5 id="note_19">Note<a class="headerlink" href="#note_19" title="Permanent link">&para;</a></h5>
<p>Compilers enforce much of this rule and ideally warn about any violation.</p>
<h5 id="note_20">Note<a class="headerlink" href="#note_20" title="Permanent link">&para;</a></h5>
<p>Relying on an implicitly generated copy operation in a class with a destructor is deprecated.</p>
<h5 id="note_21">Note<a class="headerlink" href="#note_21" title="Permanent link">&para;</a></h5>
<p>Writing these functions can be error-prone.
Note their argument types:</p>
<div class="language-text highlight"><pre><span></span><code>class X {
public:
    // ...
    virtual ~X() = default;               // destructor (virtual if X is meant to be a base class)
    X(const X&amp;) = default;                // copy constructor
    X&amp; operator=(const X&amp;) = default;     // copy assignment
    X(X&amp;&amp;) noexcept = default;            // move constructor
    X&amp; operator=(X&amp;&amp;) noexcept = default; // move assignment
};
</code></pre></div>
<p>A minor mistake (such as a misspelling, leaving out a <code>const</code>, using <code>&amp;</code> instead of <code>&amp;&amp;</code>, or leaving out a special function) can lead to errors or warnings.
To avoid the tedium and the possibility of errors, try to follow the <a href="#Rc-zero">rule of zero</a>.</p>
<h5 id="enforcement_12">Enforcement<a class="headerlink" href="#enforcement_12" title="Permanent link">&para;</a></h5>
<p>(Simple) A class should have a declaration (even a <code>=delete</code> one) for either all or none of the copy/move/destructor functions.</p>
<h3 id="c22-make-default-operations-consistent"><a name="Rc-matched"></a>C.22: Make default operations consistent<a class="headerlink" href="#c22-make-default-operations-consistent" title="Permanent link">&para;</a></h3>
<h5 id="reason_13">Reason<a class="headerlink" href="#reason_13" title="Permanent link">&para;</a></h5>
<p>The default operations are conceptually a matched set. Their semantics are interrelated.
Users will be surprised if copy/move construction and copy/move assignment do logically different things. Users will be surprised if constructors and destructors do not provide a consistent view of resource management. Users will be surprised if copy and move don't reflect the way constructors and destructors work.</p>
<h5 id="example-bad_4">Example, bad<a class="headerlink" href="#example-bad_4" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Silly {   // BAD: Inconsistent copy operations
    class Impl {
        // ...
    };
    shared_ptr&lt;Impl&gt; p;
public:
    Silly(const Silly&amp; a) : p(make_shared&lt;Impl&gt;()) { *p = *a.p; }   // deep copy
    Silly&amp; operator=(const Silly&amp; a) { p = a.p; return *this; }   // shallow copy
    // ...
};
</code></pre></div>
<p>These operations disagree about copy semantics. This will lead to confusion and bugs.</p>
<h5 id="enforcement_13">Enforcement<a class="headerlink" href="#enforcement_13" title="Permanent link">&para;</a></h5>
<ul>
<li>(Complex) A copy/move constructor and the corresponding copy/move assignment operator should write to the same data members at the same level of dereference.</li>
<li>(Complex) Any data members written in a copy/move constructor should also be initialized by all other constructors.</li>
<li>(Complex) If a copy/move constructor performs a deep copy of a data member, then the destructor should modify the data member.</li>
<li>(Complex) If a destructor is modifying a data member, that data member should be written in any copy/move constructors or assignment operators.</li>
</ul>
<h2 id="cdtor-destructors"><a name="SS-dtor"></a>C.dtor: Destructors<a class="headerlink" href="#cdtor-destructors" title="Permanent link">&para;</a></h2>
<p>"Does this class need a destructor?" is a surprisingly insightful design question.
For most classes the answer is "no" either because the class holds no resources or because destruction is handled by <a href="#Rc-zero">the rule of zero</a>;
that is, its members can take care of themselves as concerns destruction.
If the answer is "yes", much of the design of the class follows (see <a href="#Rc-five">the rule of five</a>).</p>
<h3 id="c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction"><a name="Rc-dtor"></a>C.30: Define a destructor if a class needs an explicit action at object destruction<a class="headerlink" href="#c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction" title="Permanent link">&para;</a></h3>
<h5 id="reason_14">Reason<a class="headerlink" href="#reason_14" title="Permanent link">&para;</a></h5>
<p>A destructor is implicitly invoked at the end of an object's lifetime.
If the default destructor is sufficient, use it.
Only define a non-default destructor if a class needs to execute code that is not already part of its members' destructors.</p>
<h5 id="example_10">Example<a class="headerlink" href="#example_10" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename A&gt;
struct final_action {   // slightly simplified
    A act;
    final_action(A a) : act{a} {}
    ~final_action() { act(); }
};

template&lt;typename A&gt;
final_action&lt;A&gt; finally(A act)   // deduce action type
{
    return final_action&lt;A&gt;{act};
}

void test()
{
    auto act = finally([] { cout &lt;&lt; &quot;Exit test\n&quot;; });  // establish exit action
    // ...
    if (something) return;   // act done here
    // ...
} // act done here
</code></pre></div>
<p>The whole purpose of <code>final_action</code> is to get a piece of code (usually a lambda) executed upon destruction.</p>
<h5 id="note_22">Note<a class="headerlink" href="#note_22" title="Permanent link">&para;</a></h5>
<p>There are two general categories of classes that need a user-defined destructor:</p>
<ul>
<li>A class with a resource that is not already represented as a class with a destructor, e.g., a <code>vector</code> or a transaction class.</li>
<li>A class that exists primarily to execute an action upon destruction, such as a tracer or <code>final_action</code>.</li>
</ul>
<h5 id="example-bad_5">Example, bad<a class="headerlink" href="#example-bad_5" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Foo {   // bad; use the default destructor
public:
    // ...
    ~Foo() { s = &quot;&quot;; i = 0; vi.clear(); }  // clean up
private:
    string s;
    int i;
    vector&lt;int&gt; vi;
};
</code></pre></div>
<p>The default destructor does it better, more efficiently, and can't get it wrong.</p>
<h5 id="enforcement_14">Enforcement<a class="headerlink" href="#enforcement_14" title="Permanent link">&para;</a></h5>
<p>Look for likely "implicit resources", such as pointers and references. Look for classes with destructors even though all their data members have destructors.</p>
<h3 id="c31-all-resources-acquired-by-a-class-must-be-released-by-the-classs-destructor"><a name="Rc-dtor-release"></a>C.31: All resources acquired by a class must be released by the class's destructor<a class="headerlink" href="#c31-all-resources-acquired-by-a-class-must-be-released-by-the-classs-destructor" title="Permanent link">&para;</a></h3>
<h5 id="reason_15">Reason<a class="headerlink" href="#reason_15" title="Permanent link">&para;</a></h5>
<p>Prevention of resource leaks, especially in error cases.</p>
<h5 id="note_23">Note<a class="headerlink" href="#note_23" title="Permanent link">&para;</a></h5>
<p>For resources represented as classes with a complete set of default operations, this happens automatically.</p>
<h5 id="example_11">Example<a class="headerlink" href="#example_11" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X {
    ifstream f;   // might own a file
    // ... no default operations defined or =deleted ...
};
</code></pre></div>
<p><code>X</code>'s <code>ifstream</code> implicitly closes any file it might have open upon destruction of its <code>X</code>.</p>
<h5 id="example-bad_6">Example, bad<a class="headerlink" href="#example-bad_6" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X2 {     // bad
    FILE* f;   // might own a file
    // ... no default operations defined or =deleted ...
};
</code></pre></div>
<p><code>X2</code> might leak a file handle.</p>
<h5 id="note_24">Note<a class="headerlink" href="#note_24" title="Permanent link">&para;</a></h5>
<p>What about a socket that won't close? A destructor, close, or cleanup operation <a href="#Rc-dtor-fail">should never fail</a>.
If it does nevertheless, we have a problem that has no really good solution.
For starters, the writer of a destructor does not know why the destructor is called and cannot "refuse to act" by throwing an exception.
See <a href="#Sd-never-fail">discussion</a>.
To make the problem worse, many "close/release" operations are not retryable.
Many have tried to solve this problem, but no general solution is known.
If at all possible, consider failure to close/cleanup a fundamental design error and terminate.</p>
<h5 id="note_25">Note<a class="headerlink" href="#note_25" title="Permanent link">&para;</a></h5>
<p>A class can hold pointers and references to objects that it does not own.
Obviously, such objects should not be <code>delete</code>d by the class's destructor.
For example:</p>
<div class="language-text highlight"><pre><span></span><code>Preprocessor pp { /* ... */ };
Parser p { pp, /* ... */ };
Type_checker tc { p, /* ... */ };
</code></pre></div>
<p>Here <code>p</code> refers to <code>pp</code> but does not own it.</p>
<h5 id="enforcement_15">Enforcement<a class="headerlink" href="#enforcement_15" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) If a class has pointer or reference members that are owners
  (e.g., deemed owners by using <code>gsl::owner</code>), then they should be referenced in its destructor.</li>
<li>(Hard) Determine if pointer or reference members are owners when there is no explicit statement of ownership
  (e.g., look into the constructors).</li>
</ul>
<h3 id="c32-if-a-class-has-a-raw-pointer-t-or-reference-t-consider-whether-it-might-be-owning"><a name="Rc-dtor-ptr"></a>C.32: If a class has a raw pointer (<code>T*</code>) or reference (<code>T&amp;</code>), consider whether it might be owning<a class="headerlink" href="#c32-if-a-class-has-a-raw-pointer-t-or-reference-t-consider-whether-it-might-be-owning" title="Permanent link">&para;</a></h3>
<h5 id="reason_16">Reason<a class="headerlink" href="#reason_16" title="Permanent link">&para;</a></h5>
<p>There is a lot of code that is non-specific about ownership.</p>
<h5 id="example_12">Example<a class="headerlink" href="#example_12" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class legacy_class
{
    foo* m_owning;   // Bad: change to unique_ptr&lt;T&gt; or owner&lt;T*&gt;
    bar* m_observer; // OK: keep
}
</code></pre></div>
<p>The only way to determine ownership may be code analysis.</p>
<h5 id="note_26">Note<a class="headerlink" href="#note_26" title="Permanent link">&para;</a></h5>
<p>Ownership should be clear in new code (and refactored legacy code) according to <a href="#Rr-owner">R.20</a> for owning
pointers and <a href="#Rr-ptr">R.3</a> for non-owning pointers.  References should never own <a href="#Rr-ref">R.4</a>.</p>
<h5 id="enforcement_16">Enforcement<a class="headerlink" href="#enforcement_16" title="Permanent link">&para;</a></h5>
<p>Look at the initialization of raw member pointers and member references and see if an allocation is used.</p>
<h3 id="c33-if-a-class-has-an-owning-pointer-member-define-a-destructor"><a name="Rc-dtor-ptr2"></a>C.33: If a class has an owning pointer member, define a destructor<a class="headerlink" href="#c33-if-a-class-has-an-owning-pointer-member-define-a-destructor" title="Permanent link">&para;</a></h3>
<h5 id="reason_17">Reason<a class="headerlink" href="#reason_17" title="Permanent link">&para;</a></h5>
<p>An owned object must be <code>deleted</code> upon destruction of the object that owns it.</p>
<h5 id="example_13">Example<a class="headerlink" href="#example_13" title="Permanent link">&para;</a></h5>
<p>A pointer member could represent a resource.
<a href="#Rr-ptr">A <code>T*</code> should not do so</a>, but in older code, that's common.
Consider a <code>T*</code> a possible owner and therefore suspect.</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
class Smart_ptr {
    T* p;   // BAD: vague about ownership of *p
    // ...
public:
    // ... no user-defined default operations ...
};

void use(Smart_ptr&lt;int&gt; p1)
{
    // error: p2.p leaked (if not nullptr and not owned by some other code)
    auto p2 = p1;
}
</code></pre></div>
<p>Note that if you define a destructor, you must define or delete <a href="#Rc-five">all default operations</a>:</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
class Smart_ptr2 {
    T* p;   // BAD: vague about ownership of *p
    // ...
public:
    // ... no user-defined copy operations ...
    ~Smart_ptr2() { delete p; }  // p is an owner!
};

void use(Smart_ptr2&lt;int&gt; p1)
{
    auto p2 = p1;   // error: double deletion
}
</code></pre></div>
<p>The default copy operation will just copy the <code>p1.p</code> into <code>p2.p</code> leading to a double destruction of <code>p1.p</code>. Be explicit about ownership:</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
class Smart_ptr3 {
    owner&lt;T*&gt; p;   // OK: explicit about ownership of *p
    // ...
public:
    // ...
    // ... copy and move operations ...
    ~Smart_ptr3() { delete p; }
};

void use(Smart_ptr3&lt;int&gt; p1)
{
    auto p2 = p1;   // OK: no double deletion
}
</code></pre></div>
<h5 id="note_27">Note<a class="headerlink" href="#note_27" title="Permanent link">&para;</a></h5>
<p>Often the simplest way to get a destructor is to replace the pointer with a smart pointer (e.g., <code>std::unique_ptr</code>) and let the compiler arrange for proper destruction to be done implicitly.</p>
<h5 id="note_28">Note<a class="headerlink" href="#note_28" title="Permanent link">&para;</a></h5>
<p>Why not just require all owning pointers to be "smart pointers"?
That would sometimes require non-trivial code changes and might affect ABIs.</p>
<h5 id="enforcement_17">Enforcement<a class="headerlink" href="#enforcement_17" title="Permanent link">&para;</a></h5>
<ul>
<li>A class with a pointer data member is suspect.</li>
<li>A class with an <code>owner&lt;T&gt;</code> should define its default operations.</li>
</ul>
<h3 id="c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual"><a name="Rc-dtor-virtual"></a>C.35: A base class destructor should be either public and virtual, or protected and non-virtual<a class="headerlink" href="#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual" title="Permanent link">&para;</a></h3>
<h5 id="reason_18">Reason<a class="headerlink" href="#reason_18" title="Permanent link">&para;</a></h5>
<p>To prevent undefined behavior.
If the destructor is public, then calling code can attempt to destroy a derived class object through a base class pointer, and the result is undefined if the base class's destructor is non-virtual.
If the destructor is protected, then calling code cannot destroy through a base class pointer and the destructor does not need to be virtual; it does need to be protected, not private, so that derived destructors can invoke it.
In general, the writer of a base class does not know the appropriate action to be done upon destruction.</p>
<h5 id="discussion">Discussion<a class="headerlink" href="#discussion" title="Permanent link">&para;</a></h5>
<p>See <a href="#Sd-dtor">this in the Discussion section</a>.</p>
<h5 id="example-bad_7">Example, bad<a class="headerlink" href="#example-bad_7" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Base {  // BAD: implicitly has a public non-virtual destructor
    virtual void f();
};

struct D : Base {
    string s {&quot;a resource needing cleanup&quot;};
    ~D() { /* ... do some cleanup ... */ }
    // ...
};

void use()
{
    unique_ptr&lt;Base&gt; p = make_unique&lt;D&gt;();
    // ...
} // p&#39;s destruction calls ~Base(), not ~D(), which leaks D::s and possibly more
</code></pre></div>
<h5 id="note_29">Note<a class="headerlink" href="#note_29" title="Permanent link">&para;</a></h5>
<p>A virtual function defines an interface to derived classes that can be used without looking at the derived classes.
If the interface allows destroying, it should be safe to do so.</p>
<h5 id="note_30">Note<a class="headerlink" href="#note_30" title="Permanent link">&para;</a></h5>
<p>A destructor must be non-private or it will prevent using the type:</p>
<div class="language-text highlight"><pre><span></span><code>class X {
    ~X();   // private destructor
    // ...
};

void use()
{
    X a;                        // error: cannot destroy
    auto p = make_unique&lt;X&gt;();  // error: cannot destroy
}
</code></pre></div>
<h5 id="exception_4">Exception<a class="headerlink" href="#exception_4" title="Permanent link">&para;</a></h5>
<p>We can imagine one case where you could want a protected virtual destructor: When an object of a derived type (and only of such a type) should be allowed to destroy <em>another</em> object (not itself) through a pointer to base. We haven't seen such a case in practice, though.</p>
<h5 id="enforcement_18">Enforcement<a class="headerlink" href="#enforcement_18" title="Permanent link">&para;</a></h5>
<ul>
<li>A class with any virtual functions should have a destructor that is either public and virtual or else protected and non-virtual.</li>
<li>If a class inherits publicly from a base class, the base class should have a destructor that is either public and virtual or else protected and non-virtual.</li>
</ul>
<h3 id="c36-a-destructor-must-not-fail"><a name="Rc-dtor-fail"></a>C.36: A destructor must not fail<a class="headerlink" href="#c36-a-destructor-must-not-fail" title="Permanent link">&para;</a></h3>
<h5 id="reason_19">Reason<a class="headerlink" href="#reason_19" title="Permanent link">&para;</a></h5>
<p>In general we do not know how to write error-free code if a destructor should fail.
The standard library requires that all classes it deals with have destructors that do not exit by throwing.</p>
<h5 id="example_14">Example<a class="headerlink" href="#example_14" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X {
public:
    ~X() noexcept;
    // ...
};

X::~X() noexcept
{
    // ...
    if (cannot_release_a_resource) terminate();
    // ...
}
</code></pre></div>
<h5 id="note_31">Note<a class="headerlink" href="#note_31" title="Permanent link">&para;</a></h5>
<p>Many have tried to devise a fool-proof scheme for dealing with failure in destructors.
None have succeeded to come up with a general scheme.
This can be a real practical problem: For example, what about a socket that won't close?
The writer of a destructor does not know why the destructor is called and cannot "refuse to act" by throwing an exception.
See <a href="#Sd-never-fail">discussion</a>.
To make the problem worse, many "close/release" operations are not retryable.
If at all possible, consider failure to close/cleanup a fundamental design error and terminate.</p>
<h5 id="note_32">Note<a class="headerlink" href="#note_32" title="Permanent link">&para;</a></h5>
<p>Declare a destructor <code>noexcept</code>. That will ensure that it either completes normally or terminates the program.</p>
<h5 id="note_33">Note<a class="headerlink" href="#note_33" title="Permanent link">&para;</a></h5>
<p>If a resource cannot be released and the program must not fail, try to signal the failure to the rest of the system somehow
(maybe even by modifying some global state and hope something will notice and be able to take care of the problem).
Be fully aware that this technique is special-purpose and error-prone.
Consider the "my connection will not close" example.
Probably there is a problem at the other end of the connection and only a piece of code responsible for both ends of the connection can properly handle the problem.
The destructor could send a message (somehow) to the responsible part of the system, consider that to have closed the connection, and return normally.</p>
<h5 id="note_34">Note<a class="headerlink" href="#note_34" title="Permanent link">&para;</a></h5>
<p>If a destructor uses operations that could fail, it can catch exceptions and in some cases still complete successfully
(e.g., by using a different clean-up mechanism from the one that threw an exception).</p>
<h5 id="enforcement_19">Enforcement<a class="headerlink" href="#enforcement_19" title="Permanent link">&para;</a></h5>
<p>(Simple) A destructor should be declared <code>noexcept</code> if it could throw.</p>
<h3 id="c37-make-destructors-noexcept"><a name="Rc-dtor-noexcept"></a>C.37: Make destructors <code>noexcept</code><a class="headerlink" href="#c37-make-destructors-noexcept" title="Permanent link">&para;</a></h3>
<h5 id="reason_20">Reason<a class="headerlink" href="#reason_20" title="Permanent link">&para;</a></h5>
<p><a href="#Rc-dtor-fail">A destructor must not fail</a>. If a destructor tries to exit with an exception, it's a bad design error and the program had better terminate.</p>
<h5 id="note_35">Note<a class="headerlink" href="#note_35" title="Permanent link">&para;</a></h5>
<p>A destructor (either user-defined or compiler-generated) is implicitly declared <code>noexcept</code> (independently of what code is in its body) if all of the members of its class have <code>noexcept</code> destructors. By explicitly marking destructors <code>noexcept</code>, an author guards against the destructor becoming implicitly <code>noexcept(false)</code> through the addition or modification of a class member.</p>
<h5 id="example_15">Example<a class="headerlink" href="#example_15" title="Permanent link">&para;</a></h5>
<p>Not all destructors are noexcept by default; one throwing member poisons the whole class hierarchy</p>
<div class="language-text highlight"><pre><span></span><code>struct X {
    Details x;  // happens to have a throwing destructor
    // ...
    ~X() { }    // implicitly noexcept(false); aka can throw
};
</code></pre></div>
<p>So, if in doubt, declare a destructor noexcept.</p>
<h5 id="note_36">Note<a class="headerlink" href="#note_36" title="Permanent link">&para;</a></h5>
<p>Why not then declare all destructors noexcept?
Because that would in many cases -- especially simple cases -- be distracting clutter.</p>
<h5 id="enforcement_20">Enforcement<a class="headerlink" href="#enforcement_20" title="Permanent link">&para;</a></h5>
<p>(Simple) A destructor should be declared <code>noexcept</code> if it could throw.</p>
<h2 id="cctor-constructors"><a name="SS-ctor"></a>C.ctor: Constructors<a class="headerlink" href="#cctor-constructors" title="Permanent link">&para;</a></h2>
<p>A constructor defines how an object is initialized (constructed).</p>
<h3 id="c40-define-a-constructor-if-a-class-has-an-invariant"><a name="Rc-ctor"></a>C.40: Define a constructor if a class has an invariant<a class="headerlink" href="#c40-define-a-constructor-if-a-class-has-an-invariant" title="Permanent link">&para;</a></h3>
<h5 id="reason_21">Reason<a class="headerlink" href="#reason_21" title="Permanent link">&para;</a></h5>
<p>That's what constructors are for.</p>
<h5 id="example_16">Example<a class="headerlink" href="#example_16" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Date {  // a Date represents a valid date
              // in the January 1, 1900 to December 31, 2100 range
    Date(int dd, int mm, int yy)
        :d{dd}, m{mm}, y{yy}
    {
        if (!is_valid(d, m, y)) throw Bad_date{};  // enforce invariant
    }
    // ...
private:
    int d, m, y;
};
</code></pre></div>
<p>It is often a good idea to express the invariant as an <code>Ensures</code> on the constructor.</p>
<h5 id="note_37">Note<a class="headerlink" href="#note_37" title="Permanent link">&para;</a></h5>
<p>A constructor can be used for convenience even if a class does not have an invariant. For example:</p>
<div class="language-text highlight"><pre><span></span><code>struct Rec {
    string s;
    int i {0};
    Rec(const string&amp; ss) : s{ss} {}
    Rec(int ii) :i{ii} {}
};

Rec r1 {7};
Rec r2 {&quot;Foo bar&quot;};
</code></pre></div>
<h5 id="note_38">Note<a class="headerlink" href="#note_38" title="Permanent link">&para;</a></h5>
<p>The C++11 initializer list rule eliminates the need for many constructors. For example:</p>
<div class="language-text highlight"><pre><span></span><code>struct Rec2{
    string s;
    int i;
    Rec2(const string&amp; ss, int ii = 0) :s{ss}, i{ii} {}   // redundant
};

Rec2 r1 {&quot;Foo&quot;, 7};
Rec2 r2 {&quot;Bar&quot;};
</code></pre></div>
<p>The <code>Rec2</code> constructor is redundant.
Also, the default for <code>int</code> would be better done as a <a href="#Rc-in-class-initializer">default member initializer</a>.</p>
<p><strong>See also</strong>: <a href="#Rc-complete">construct valid object</a> and <a href="#Rc-throw">constructor throws</a>.</p>
<h5 id="enforcement_21">Enforcement<a class="headerlink" href="#enforcement_21" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag classes with user-defined copy operations but no constructor (a user-defined copy is a good indicator that the class has an invariant)</li>
</ul>
<h3 id="c41-a-constructor-should-create-a-fully-initialized-object"><a name="Rc-complete"></a>C.41: A constructor should create a fully initialized object<a class="headerlink" href="#c41-a-constructor-should-create-a-fully-initialized-object" title="Permanent link">&para;</a></h3>
<h5 id="reason_22">Reason<a class="headerlink" href="#reason_22" title="Permanent link">&para;</a></h5>
<p>A constructor establishes the invariant for a class. A user of a class should be able to assume that a constructed object is usable.</p>
<h5 id="example-bad_8">Example, bad<a class="headerlink" href="#example-bad_8" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X1 {
    FILE* f;   // call init() before any other function
    // ...
public:
    X1() {}
    void init();   // initialize f
    void read();   // read from f
    // ...
};

void f()
{
    X1 file;
    file.read();   // crash or bad read!
    // ...
    file.init();   // too late
    // ...
}
</code></pre></div>
<p>Compilers do not read comments.</p>
<h5 id="exception_5">Exception<a class="headerlink" href="#exception_5" title="Permanent link">&para;</a></h5>
<p>If a valid object cannot conveniently be constructed by a constructor, <a href="#Rc-factory">use a factory function</a>.</p>
<h5 id="enforcement_22">Enforcement<a class="headerlink" href="#enforcement_22" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Every constructor should initialize every data member (either explicitly, via a delegating ctor call or via default construction).</li>
<li>(Unknown) If a constructor has an <code>Ensures</code> contract, try to see if it holds as a postcondition.</li>
</ul>
<h5 id="note_39">Note<a class="headerlink" href="#note_39" title="Permanent link">&para;</a></h5>
<p>If a constructor acquires a resource (to create a valid object), that resource should be <a href="#Rc-dtor-release">released by the destructor</a>.
The idiom of having constructors acquire resources and destructors release them is called <a href="#Rr-raii">RAII</a> ("Resource Acquisition Is Initialization").</p>
<h3 id="c42-if-a-constructor-cannot-construct-a-valid-object-throw-an-exception"><a name="Rc-throw"></a>C.42: If a constructor cannot construct a valid object, throw an exception<a class="headerlink" href="#c42-if-a-constructor-cannot-construct-a-valid-object-throw-an-exception" title="Permanent link">&para;</a></h3>
<h5 id="reason_23">Reason<a class="headerlink" href="#reason_23" title="Permanent link">&para;</a></h5>
<p>Leaving behind an invalid object is asking for trouble.</p>
<h5 id="example_17">Example<a class="headerlink" href="#example_17" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X2 {
    FILE* f;
    // ...
public:
    X2(const string&amp; name)
        :f{fopen(name.c_str(), &quot;r&quot;)}
    {
        if (!f) throw runtime_error{&quot;could not open&quot; + name};
        // ...
    }

    void read();      // read from f
    // ...
};

void f()
{
    X2 file {&quot;Zeno&quot;}; // throws if file isn&#39;t open
    file.read();      // fine
    // ...
}
</code></pre></div>
<h5 id="example-bad_9">Example, bad<a class="headerlink" href="#example-bad_9" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X3 {     // bad: the constructor leaves a non-valid object behind
    FILE* f;   // call is_valid() before any other function
    bool valid;
    // ...
public:
    X3(const string&amp; name)
        :f{fopen(name.c_str(), &quot;r&quot;)}, valid{false}
    {
        if (f) valid = true;
        // ...
    }

    bool is_valid() { return valid; }
    void read();   // read from f
    // ...
};

void f()
{
    X3 file {&quot;Heraclides&quot;};
    file.read();   // crash or bad read!
    // ...
    if (file.is_valid()) {
        file.read();
        // ...
    }
    else {
        // ... handle error ...
    }
    // ...
}
</code></pre></div>
<h5 id="note_40">Note<a class="headerlink" href="#note_40" title="Permanent link">&para;</a></h5>
<p>For a variable definition (e.g., on the stack or as a member of another object) there is no explicit function call from which an error code could be returned.
Leaving behind an invalid object and relying on users to consistently check an <code>is_valid()</code> function before use is tedious, error-prone, and inefficient.</p>
<h5 id="exception_6">Exception<a class="headerlink" href="#exception_6" title="Permanent link">&para;</a></h5>
<p>There are domains, such as some hard-real-time systems (think airplane controls) where (without additional tool support) exception handling is not sufficiently predictable from a timing perspective.
There the <code>is_valid()</code> technique must be used. In such cases, check <code>is_valid()</code> consistently and immediately to simulate <a href="#Rr-raii">RAII</a>.</p>
<h5 id="alternative">Alternative<a class="headerlink" href="#alternative" title="Permanent link">&para;</a></h5>
<p>If you feel tempted to use some "post-constructor initialization" or "two-stage initialization" idiom, try not to do that.
If you really have to, look at <a href="#Rc-factory">factory functions</a>.</p>
<h5 id="note_41">Note<a class="headerlink" href="#note_41" title="Permanent link">&para;</a></h5>
<p>One reason people have used <code>init()</code> functions rather than doing the initialization work in a constructor has been to avoid code replication.
<a href="#Rc-delegating">Delegating constructors</a> and <a href="#Rc-in-class-initializer">default member initialization</a> do that better.
Another reason has been to delay initialization until an object is needed; the solution to that is often <a href="#Res-init">not to declare a variable until it can be properly initialized</a></p>
<h5 id="enforcement_23">Enforcement<a class="headerlink" href="#enforcement_23" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c43-ensure-that-a-copyable-class-has-a-default-constructor"><a name="Rc-default0"></a>C.43: Ensure that a copyable class has a default constructor<a class="headerlink" href="#c43-ensure-that-a-copyable-class-has-a-default-constructor" title="Permanent link">&para;</a></h3>
<h5 id="reason_24">Reason<a class="headerlink" href="#reason_24" title="Permanent link">&para;</a></h5>
<p>That is, ensure that if a concrete class is copyable it also satisfies the rest of "semiregular."</p>
<p>Many language and library facilities rely on default constructors to initialize their elements, e.g. <code>T a[10]</code> and <code>std::vector&lt;T&gt; v(10)</code>.
A default constructor often simplifies the task of defining a suitable <a href="#???">moved-from state</a> for a type that is also copyable.</p>
<h5 id="example_18">Example<a class="headerlink" href="#example_18" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Date { // BAD: no default constructor
public:
    Date(int dd, int mm, int yyyy);
    // ...
};

vector&lt;Date&gt; vd1(1000);   // default Date needed here
vector&lt;Date&gt; vd2(1000, Date{7, Month::October, 1885});   // alternative
</code></pre></div>
<p>The default constructor is only auto-generated if there is no user-declared constructor, hence it's impossible to initialize the vector <code>vd1</code> in the example above.
The absence of a default value can cause surprises for users and complicate its use, so if one can be reasonably defined, it should be.</p>
<p><code>Date</code> is chosen to encourage thought:
There is no "natural" default date (the big bang is too far back in time to be useful for most people), so this example is non-trivial.
<code>{0, 0, 0}</code> is not a valid date in most calendar systems, so choosing that would be introducing something like floating-point's <code>NaN</code>.
However, most realistic <code>Date</code> classes have a "first date" (e.g. January 1, 1970 is popular), so making that the default is usually trivial.</p>
<div class="language-text highlight"><pre><span></span><code>class Date {
public:
    Date(int dd, int mm, int yyyy);
    Date() = default; // [See also](#Rc-default)
    // ...
private:
    int dd {1};
    int mm {1};
    int yyyy {1970};
    // ...
};

vector&lt;Date&gt; vd1(1000);
</code></pre></div>
<h5 id="note_42">Note<a class="headerlink" href="#note_42" title="Permanent link">&para;</a></h5>
<p>A class with members that all have default constructors implicitly gets a default constructor:</p>
<div class="language-text highlight"><pre><span></span><code>struct X {
    string s;
    vector&lt;int&gt; v;
};

X x; // means X{ { }, { } }; that is the empty string and the empty vector
</code></pre></div>
<p>Beware that built-in types are not properly default constructed:</p>
<div class="language-text highlight"><pre><span></span><code>struct X {
    string s;
    int i;
};

void f()
{
    X x;    // x.s is initialized to the empty string; x.i is uninitialized

    cout &lt;&lt; x.s &lt;&lt; &#39; &#39; &lt;&lt; x.i &lt;&lt; &#39;\n&#39;;
    ++x.i;
}
</code></pre></div>
<p>Statically allocated objects of built-in types are by default initialized to <code>0</code>, but local built-in variables are not.
Beware that your compiler might default initialize local built-in variables, whereas an optimized build will not.
Thus, code like the example above might appear to work, but it relies on undefined behavior.
Assuming that you want initialization, an explicit default initialization can help:</p>
<div class="language-text highlight"><pre><span></span><code>struct X {
    string s;
    int i {};   // default initialize (to 0)
};
</code></pre></div>
<h5 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h5>
<p>Classes that don't have a reasonable default construction are usually not copyable either, so they don't fall under this guideline.</p>
<p>For example, a base class should not be copyable, and so does not necessarily need a default constructor:</p>
<div class="language-text highlight"><pre><span></span><code>// Shape is an abstract base class, not a copyable type.
// It might or might not need a default constructor.
struct Shape {
    virtual void draw() = 0;
    virtual void rotate(int) = 0;
    // =delete copy/move functions
    // ...
};
</code></pre></div>
<p>A class that must acquire a caller-provided resource during construction often cannot have a default constructor, but it does not fall under this guideline because such a class is usually not copyable anyway:</p>
<div class="language-text highlight"><pre><span></span><code>// std::lock_guard is not a copyable type.
// It does not have a default constructor.
lock_guard g {mx};  // guard the mutex mx
lock_guard g2;      // error: guarding nothing
</code></pre></div>
<p>A class that has a "special state" that must be handled separately from other states by member functions or users causes extra work
(and most likely more errors). Such a type can naturally use the special state as a default constructed value, whether or not it is copyable:</p>
<div class="language-text highlight"><pre><span></span><code>// std::ofstream is not a copyable type.
// It does happen to have a default constructor
// that goes along with a special &quot;not open&quot; state.
ofstream out {&quot;Foobar&quot;};
// ...
out &lt;&lt; log(time, transaction);
</code></pre></div>
<p>Similar special-state types that are copyable, such as copyable smart pointers that have the special state "==nullptr", should use the special state as their default constructed value.</p>
<p>However, it is preferable to have a default constructor default to a meaningful state such as <code>std::string</code>s <code>""</code> and <code>std::vector</code>s <code>{}</code>.</p>
<h5 id="enforcement_24">Enforcement<a class="headerlink" href="#enforcement_24" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag classes that are copyable by <code>=</code> without a default constructor</li>
<li>Flag classes that are comparable with <code>==</code> but not copyable</li>
</ul>
<h3 id="c44-prefer-default-constructors-to-be-simple-and-non-throwing"><a name="Rc-default00"></a>C.44: Prefer default constructors to be simple and non-throwing<a class="headerlink" href="#c44-prefer-default-constructors-to-be-simple-and-non-throwing" title="Permanent link">&para;</a></h3>
<h5 id="reason_25">Reason<a class="headerlink" href="#reason_25" title="Permanent link">&para;</a></h5>
<p>Being able to set a value to "the default" without operations that might fail simplifies error handling and reasoning about move operations.</p>
<h5 id="example-problematic">Example, problematic<a class="headerlink" href="#example-problematic" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
// elem points to space-elem element allocated using new
class Vector0 {
public:
    Vector0() :Vector0{0} {}
    Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
    // ...
private:
    own&lt;T*&gt; elem;
    T* space;
    T* last;
};
</code></pre></div>
<p>This is nice and general, but setting a <code>Vector0</code> to empty after an error involves an allocation, which might fail.
Also, having a default <code>Vector</code> represented as <code>{new T[0], 0, 0}</code> seems wasteful.
For example, <code>Vector0&lt;int&gt; v[100]</code> costs 100 allocations.</p>
<h5 id="example_19">Example<a class="headerlink" href="#example_19" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
// elem is nullptr or elem points to space-elem element allocated using new
class Vector1 {
public:
    // sets the representation to {nullptr, nullptr, nullptr}; doesn&#39;t throw
    Vector1() noexcept {}
    Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
    // ...
private:
    own&lt;T*&gt; elem {};
    T* space {};
    T* last {};
};
</code></pre></div>
<p>Using <code>{nullptr, nullptr, nullptr}</code> makes <code>Vector1{}</code> cheap, but a special case and implies run-time checks.
Setting a <code>Vector1</code> to empty after detecting an error is trivial.</p>
<h5 id="enforcement_25">Enforcement<a class="headerlink" href="#enforcement_25" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag throwing default constructors</li>
</ul>
<h3 id="c45-dont-define-a-default-constructor-that-only-initializes-data-members-use-default-member-initializers-instead"><a name="Rc-default"></a>C.45: Don't define a default constructor that only initializes data members; use default member initializers instead<a class="headerlink" href="#c45-dont-define-a-default-constructor-that-only-initializes-data-members-use-default-member-initializers-instead" title="Permanent link">&para;</a></h3>
<h5 id="reason_26">Reason<a class="headerlink" href="#reason_26" title="Permanent link">&para;</a></h5>
<p>Using default member initializers lets the compiler generate the function for you. The compiler-generated function can be more efficient.</p>
<h5 id="example-bad_10">Example, bad<a class="headerlink" href="#example-bad_10" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X1 { // BAD: doesn&#39;t use member initializers
    string s;
    int i;
public:
    X1() :s{&quot;default&quot;}, i{1} { }
    // ...
};
</code></pre></div>
<h5 id="example_20">Example<a class="headerlink" href="#example_20" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X2 {
    string s {&quot;default&quot;};
    int i {1};
public:
    // use compiler-generated default constructor
    // ...
};
</code></pre></div>
<h5 id="enforcement_26">Enforcement<a class="headerlink" href="#enforcement_26" title="Permanent link">&para;</a></h5>
<p>(Simple) A default constructor should do more than just initialize data members with constants.</p>
<h3 id="c46-by-default-declare-single-argument-constructors-explicit"><a name="Rc-explicit"></a>C.46: By default, declare single-argument constructors explicit<a class="headerlink" href="#c46-by-default-declare-single-argument-constructors-explicit" title="Permanent link">&para;</a></h3>
<h5 id="reason_27">Reason<a class="headerlink" href="#reason_27" title="Permanent link">&para;</a></h5>
<p>To avoid unintended conversions.</p>
<h5 id="example-bad_11">Example, bad<a class="headerlink" href="#example-bad_11" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class String {
public:
    String(int);   // BAD
    // ...
};

String s = 10;   // surprise: string of size 10
</code></pre></div>
<h5 id="exception_7">Exception<a class="headerlink" href="#exception_7" title="Permanent link">&para;</a></h5>
<p>If you really want an implicit conversion from the constructor argument type to the class type, don't use <code>explicit</code>:</p>
<div class="language-text highlight"><pre><span></span><code>class Complex {
public:
    Complex(double d);   // OK: we want a conversion from d to {d, 0}
    // ...
};

Complex z = 10.7;   // unsurprising conversion
</code></pre></div>
<p><strong>See also</strong>: <a href="#Ro-conversion">Discussion of implicit conversions</a></p>
<h5 id="note_43">Note<a class="headerlink" href="#note_43" title="Permanent link">&para;</a></h5>
<p>Copy and move constructors should not be made <code>explicit</code> because they do not perform conversions. Explicit copy/move constructors make passing and returning by value difficult.</p>
<h5 id="enforcement_27">Enforcement<a class="headerlink" href="#enforcement_27" title="Permanent link">&para;</a></h5>
<p>(Simple) Single-argument constructors should be declared <code>explicit</code>. Good single argument non-<code>explicit</code> constructors are rare in most code bases. Warn for all that are not on a "positive list".</p>
<h3 id="c47-define-and-initialize-data-members-in-the-order-of-member-declaration"><a name="Rc-order"></a>C.47: Define and initialize data members in the order of member declaration<a class="headerlink" href="#c47-define-and-initialize-data-members-in-the-order-of-member-declaration" title="Permanent link">&para;</a></h3>
<h5 id="reason_28">Reason<a class="headerlink" href="#reason_28" title="Permanent link">&para;</a></h5>
<p>To minimize confusion and errors. That is the order in which the initialization happens (independent of the order of member initializers).</p>
<h5 id="example-bad_12">Example, bad<a class="headerlink" href="#example-bad_12" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Foo {
    int m1;
    int m2;
public:
    Foo(int x) :m2{x}, m1{++x} { }   // BAD: misleading initializer order
    // ...
};

Foo x(1); // surprise: x.m1 == x.m2 == 2
</code></pre></div>
<h5 id="enforcement_28">Enforcement<a class="headerlink" href="#enforcement_28" title="Permanent link">&para;</a></h5>
<p>(Simple) A member initializer list should mention the members in the same order they are declared.</p>
<p><strong>See also</strong>: <a href="#Sd-order">Discussion</a></p>
<h3 id="c48-prefer-default-member-initializers-to-member-initializers-in-constructors-for-constant-initializers"><a name="Rc-in-class-initializer"></a>C.48: Prefer default member initializers to member initializers in constructors for constant initializers<a class="headerlink" href="#c48-prefer-default-member-initializers-to-member-initializers-in-constructors-for-constant-initializers" title="Permanent link">&para;</a></h3>
<h5 id="reason_29">Reason<a class="headerlink" href="#reason_29" title="Permanent link">&para;</a></h5>
<p>Makes it explicit that the same value is expected to be used in all constructors. Avoids repetition. Avoids maintenance problems. It leads to the shortest and most efficient code.</p>
<h5 id="example-bad_13">Example, bad<a class="headerlink" href="#example-bad_13" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X {   // BAD
    int i;
    string s;
    int j;
public:
    X() :i{666}, s{&quot;qqq&quot;} { }   // j is uninitialized
    X(int ii) :i{ii} {}         // s is &quot;&quot; and j is uninitialized
    // ...
};
</code></pre></div>
<p>How would a maintainer know whether <code>j</code> was deliberately uninitialized (probably a bad idea anyway) and whether it was intentional to give <code>s</code> the default value <code>""</code> in one case and <code>qqq</code> in another (almost certainly a bug)? The problem with <code>j</code> (forgetting to initialize a member) often happens when a new member is added to an existing class.</p>
<h5 id="example_21">Example<a class="headerlink" href="#example_21" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X2 {
    int i {666};
    string s {&quot;qqq&quot;};
    int j {0};
public:
    X2() = default;        // all members are initialized to their defaults
    X2(int ii) :i{ii} {}   // s and j initialized to their defaults
    // ...
};
</code></pre></div>
<p><strong>Alternative</strong>: We can get part of the benefits from default arguments to constructors, and that is not uncommon in older code. However, that is less explicit, causes more arguments to be passed, and is repetitive when there is more than one constructor:</p>
<div class="language-text highlight"><pre><span></span><code>class X3 {   // BAD: inexplicit, argument passing overhead
    int i;
    string s;
    int j;
public:
    X3(int ii = 666, const string&amp; ss = &quot;qqq&quot;, int jj = 0)
        :i{ii}, s{ss}, j{jj} { }   // all members are initialized to their defaults
    // ...
};
</code></pre></div>
<h5 id="enforcement_29">Enforcement<a class="headerlink" href="#enforcement_29" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Every constructor should initialize every data member (either explicitly, via a delegating ctor call or via default construction).</li>
<li>(Simple) Default arguments to constructors suggest a default member initializer might be more appropriate.</li>
</ul>
<h3 id="c49-prefer-initialization-to-assignment-in-constructors"><a name="Rc-initialize"></a>C.49: Prefer initialization to assignment in constructors<a class="headerlink" href="#c49-prefer-initialization-to-assignment-in-constructors" title="Permanent link">&para;</a></h3>
<h5 id="reason_30">Reason<a class="headerlink" href="#reason_30" title="Permanent link">&para;</a></h5>
<p>An initialization explicitly states that initialization, rather than assignment, is done and can be more elegant and efficient. Prevents "use before set" errors.</p>
<h5 id="example-good_2">Example, good<a class="headerlink" href="#example-good_2" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class A {   // Good
    string s1;
public:
    A(czstring p) : s1{p} { }    // GOOD: directly construct (and the C-string is explicitly named)
    // ...
};
</code></pre></div>
<h5 id="example-bad_14">Example, bad<a class="headerlink" href="#example-bad_14" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class B {   // BAD
    string s1;
public:
    B(const char* p) { s1 = p; }   // BAD: default constructor followed by assignment
    // ...
};

class C {   // UGLY, aka very bad
    int* p;
public:
    C() { cout &lt;&lt; *p; p = new int{10}; }   // accidental use before initialized
    // ...
};
</code></pre></div>
<h5 id="example-better-still">Example, better still<a class="headerlink" href="#example-better-still" title="Permanent link">&para;</a></h5>
<p>Instead of those <code>const char*</code>s we could use C++17 <code>std::string_view</code> or <code>gsl::span&lt;char&gt;</code>
as <a href="#Rstr-view">a more general way to present arguments to a function</a>:</p>
<div class="language-text highlight"><pre><span></span><code>class D {   // Good
    string s1;
public:
    D(string_view v) : s1{v} { }    // GOOD: directly construct
    // ...
};
</code></pre></div>
<h3 id="c50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization"><a name="Rc-factory"></a>C.50: Use a factory function if you need "virtual behavior" during initialization<a class="headerlink" href="#c50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization" title="Permanent link">&para;</a></h3>
<h5 id="reason_31">Reason<a class="headerlink" href="#reason_31" title="Permanent link">&para;</a></h5>
<p>If the state of a base class object must depend on the state of a derived part of the object, we need to use a virtual function (or equivalent) while minimizing the window of opportunity to misuse an imperfectly constructed object.</p>
<h5 id="note_44">Note<a class="headerlink" href="#note_44" title="Permanent link">&para;</a></h5>
<p>The return type of the factory should normally be <code>unique_ptr</code> by default; if some uses are shared, the caller can <code>move</code> the <code>unique_ptr</code> into a <code>shared_ptr</code>. However, if the factory author knows that all uses of the returned object will be shared uses, return <code>shared_ptr</code> and use <code>make_shared</code> in the body to save an allocation.</p>
<h5 id="example-bad_15">Example, bad<a class="headerlink" href="#example-bad_15" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class B {
public:
    B()
    {
        /* ... */
        f(); // BAD: C.82: Don&#39;t call virtual functions in constructors and destructors
        /* ... */
    }

    virtual void f() = 0;
};
</code></pre></div>
<h5 id="example_22">Example<a class="headerlink" href="#example_22" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class B {
protected:
    class Token {};

public:
    explicit B(Token) { /* ... */ }  // create an imperfectly initialized object
    virtual void f() = 0;

    template&lt;class T&gt;
    static shared_ptr&lt;T&gt; create()    // interface for creating shared objects
    {
        auto p = make_shared&lt;T&gt;(typename T::Token{});
        p-&gt;post_initialize();
        return p;
    }

protected:
    virtual void post_initialize()   // called right after construction
        { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe
};

class D : public B {                 // some derived class
protected:
    class Token {};

public:
    explicit D(Token) : B{ B::Token{} } {}
    void f() override { /* ...  */ };

protected:
    template&lt;class T&gt;
    friend shared_ptr&lt;T&gt; B::create();
};

shared_ptr&lt;D&gt; p = D::create&lt;D&gt;();  // creating a D object
</code></pre></div>
<p><code>make_shared</code> requires that the constructor is public. By requiring a protected <code>Token</code> the constructor cannot be publicly called anymore, so we avoid an incompletely constructed object escaping into the wild.
By providing the factory function <code>create()</code>, we make construction (on the free store) convenient.</p>
<h5 id="note_45">Note<a class="headerlink" href="#note_45" title="Permanent link">&para;</a></h5>
<p>Conventional factory functions allocate on the free store, rather than on the stack or in an enclosing object.</p>
<p><strong>See also</strong>: <a href="#Sd-factory">Discussion</a></p>
<h3 id="c51-use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class"><a name="Rc-delegating"></a>C.51: Use delegating constructors to represent common actions for all constructors of a class<a class="headerlink" href="#c51-use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class" title="Permanent link">&para;</a></h3>
<h5 id="reason_32">Reason<a class="headerlink" href="#reason_32" title="Permanent link">&para;</a></h5>
<p>To avoid repetition and accidental differences.</p>
<h5 id="example-bad_16">Example, bad<a class="headerlink" href="#example-bad_16" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Date {   // BAD: repetitive
    int d;
    Month m;
    int y;
public:
    Date(int dd, Month mm, year yy)
        :d{dd}, m{mm}, y{yy}
        { if (!valid(d, m, y)) throw Bad_date{}; }

    Date(int dd, Month mm)
        :d{dd}, m{mm} y{current_year()}
        { if (!valid(d, m, y)) throw Bad_date{}; }
    // ...
};
</code></pre></div>
<p>The common action gets tedious to write and might accidentally not be common.</p>
<h5 id="example_23">Example<a class="headerlink" href="#example_23" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Date2 {
    int d;
    Month m;
    int y;
public:
    Date2(int dd, Month mm, year yy)
        :d{dd}, m{mm}, y{yy}
        { if (!valid(d, m, y)) throw Bad_date{}; }

    Date2(int dd, Month mm)
        :Date2{dd, mm, current_year()} {}
    // ...
};
</code></pre></div>
<p><strong>See also</strong>: If the "repeated action" is a simple initialization, consider <a href="#Rc-in-class-initializer">a default member initializer</a>.</p>
<h5 id="enforcement_30">Enforcement<a class="headerlink" href="#enforcement_30" title="Permanent link">&para;</a></h5>
<p>(Moderate) Look for similar constructor bodies.</p>
<h3 id="c52-use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization"><a name="Rc-inheriting"></a>C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization<a class="headerlink" href="#c52-use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization" title="Permanent link">&para;</a></h3>
<h5 id="reason_33">Reason<a class="headerlink" href="#reason_33" title="Permanent link">&para;</a></h5>
<p>If you need those constructors for a derived class, re-implementing them is tedious and error-prone.</p>
<h5 id="example_24">Example<a class="headerlink" href="#example_24" title="Permanent link">&para;</a></h5>
<p><code>std::vector</code> has a lot of tricky constructors, so if I want my own <code>vector</code>, I don't want to reimplement them:</p>
<div class="language-text highlight"><pre><span></span><code>class Rec {
    // ... data and lots of nice constructors ...
};

class Oper : public Rec {
    using Rec::Rec;
    // ... no data members ...
    // ... lots of nice utility functions ...
};
</code></pre></div>
<h5 id="example-bad_17">Example, bad<a class="headerlink" href="#example-bad_17" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Rec2 : public Rec {
    int x;
    using Rec::Rec;
};

Rec2 r {&quot;foo&quot;, 7};
int val = r.x;   // uninitialized
</code></pre></div>
<h5 id="enforcement_31">Enforcement<a class="headerlink" href="#enforcement_31" title="Permanent link">&para;</a></h5>
<p>Make sure that every member of the derived class is initialized.</p>
<h2 id="ccopy-copy-and-move"><a name="SS-copy"></a>C.copy: Copy and move<a class="headerlink" href="#ccopy-copy-and-move" title="Permanent link">&para;</a></h2>
<p>Concrete types should generally be copyable, but interfaces in a class hierarchy should not.
Resource handles might or might not be copyable.
Types can be defined to move for logical as well as performance reasons.</p>
<h3 id="c60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const"><a name="Rc-copy-assignment"></a>C.60: Make copy assignment non-<code>virtual</code>, take the parameter by <code>const&amp;</code>, and return by non-<code>const&amp;</code><a class="headerlink" href="#c60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const" title="Permanent link">&para;</a></h3>
<h5 id="reason_34">Reason<a class="headerlink" href="#reason_34" title="Permanent link">&para;</a></h5>
<p>It is simple and efficient. If you want to optimize for rvalues, provide an overload that takes a <code>&amp;&amp;</code> (see <a href="#Rf-consume">F.18</a>).</p>
<h5 id="example_25">Example<a class="headerlink" href="#example_25" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Foo {
public:
    Foo&amp; operator=(const Foo&amp; x)
    {
        // GOOD: no need to check for self-assignment (other than performance)
        auto tmp = x;
        swap(tmp); // see C.83
        return *this;
    }
    // ...
};

Foo a;
Foo b;
Foo f();

a = b;    // assign lvalue: copy
a = f();  // assign rvalue: potentially move
</code></pre></div>
<h5 id="note_46">Note<a class="headerlink" href="#note_46" title="Permanent link">&para;</a></h5>
<p>The <code>swap</code> implementation technique offers the <a href="#Abrahams01">strong guarantee</a>.</p>
<h5 id="example_26">Example<a class="headerlink" href="#example_26" title="Permanent link">&para;</a></h5>
<p>But what if you can get significantly better performance by not making a temporary copy? Consider a simple <code>Vector</code> intended for a domain where assignment of large, equal-sized <code>Vector</code>s is common. In this case, the copy of elements implied by the <code>swap</code> implementation technique could cause an order of magnitude increase in cost:</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
class Vector {
public:
    Vector&amp; operator=(const Vector&amp;);
    // ...
private:
    T* elem;
    int sz;
};

Vector&amp; Vector::operator=(const Vector&amp; a)
{
    if (a.sz &gt; sz) {
        // ... use the swap technique, it can&#39;t be bettered ...
        return *this;
    }
    // ... copy sz elements from *a.elem to elem ...
    if (a.sz &lt; sz) {
        // ... destroy the surplus elements in *this and adjust size ...
    }
    return *this;
}
</code></pre></div>
<p>By writing directly to the target elements, we will get only <a href="#Abrahams01">the basic guarantee</a> rather than the strong guarantee offered by the <code>swap</code> technique. Beware of <a href="#Rc-copy-self">self-assignment</a>.</p>
<p><strong>Alternatives</strong>: If you think you need a <code>virtual</code> assignment operator, and understand why that's deeply problematic, don't call it <code>operator=</code>. Make it a named function like <code>virtual void assign(const Foo&amp;)</code>.
See <a href="#Rc-copy-virtual">copy constructor vs. <code>clone()</code></a>.</p>
<h5 id="enforcement_32">Enforcement<a class="headerlink" href="#enforcement_32" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) An assignment operator should not be virtual. Here be dragons!</li>
<li>(Simple) An assignment operator should return <code>T&amp;</code> to enable chaining, not alternatives like <code>const T&amp;</code> which interfere with composability and putting objects in containers.</li>
<li>(Moderate) An assignment operator should (implicitly or explicitly) invoke all base and member assignment operators.
  Look at the destructor to determine if the type has pointer semantics or value semantics.</li>
</ul>
<h3 id="c61-a-copy-operation-should-copy"><a name="Rc-copy-semantic"></a>C.61: A copy operation should copy<a class="headerlink" href="#c61-a-copy-operation-should-copy" title="Permanent link">&para;</a></h3>
<h5 id="reason_35">Reason<a class="headerlink" href="#reason_35" title="Permanent link">&para;</a></h5>
<p>That is the generally assumed semantics. After <code>x = y</code>, we should have <code>x == y</code>.
After a copy <code>x</code> and <code>y</code> can be independent objects (value semantics, the way non-pointer built-in types and the standard-library types work) or refer to a shared object (pointer semantics, the way pointers work).</p>
<h5 id="example_27">Example<a class="headerlink" href="#example_27" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X {   // OK: value semantics
public:
    X();
    X(const X&amp;);     // copy X
    void modify();   // change the value of X
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};

bool operator==(const X&amp; a, const X&amp; b)
{
    return a.sz == b.sz &amp;&amp; equal(a.p, a.p + a.sz, b.p, b.p + b.sz);
}

X::X(const X&amp; a)
    :p{new T[a.sz]}, sz{a.sz}
{
    copy(a.p, a.p + sz, p);
}

X x;
X y = x;
if (x != y) throw Bad{};
x.modify();
if (x == y) throw Bad{};   // assume value semantics
</code></pre></div>
<h5 id="example_28">Example<a class="headerlink" href="#example_28" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X2 {  // OK: pointer semantics
public:
    X2();
    X2(const X2&amp;) = default; // shallow copy
    ~X2() = default;
    void modify();          // change the pointed-to value
    // ...
private:
    T* p;
    int sz;
};

bool operator==(const X2&amp; a, const X2&amp; b)
{
    return a.sz == b.sz &amp;&amp; a.p == b.p;
}

X2 x;
X2 y = x;
if (x != y) throw Bad{};
x.modify();
if (x != y) throw Bad{};  // assume pointer semantics
</code></pre></div>
<h5 id="note_47">Note<a class="headerlink" href="#note_47" title="Permanent link">&para;</a></h5>
<p>Prefer value semantics unless you are building a "smart pointer". Value semantics is the simplest to reason about and what the standard-library facilities expect.</p>
<h5 id="enforcement_33">Enforcement<a class="headerlink" href="#enforcement_33" title="Permanent link">&para;</a></h5>
<p>(Not enforceable)</p>
<h3 id="c62-make-copy-assignment-safe-for-self-assignment"><a name="Rc-copy-self"></a>C.62: Make copy assignment safe for self-assignment<a class="headerlink" href="#c62-make-copy-assignment-safe-for-self-assignment" title="Permanent link">&para;</a></h3>
<h5 id="reason_36">Reason<a class="headerlink" href="#reason_36" title="Permanent link">&para;</a></h5>
<p>If <code>x = x</code> changes the value of <code>x</code>, people will be surprised and bad errors will occur (often including leaks).</p>
<h5 id="example_29">Example<a class="headerlink" href="#example_29" title="Permanent link">&para;</a></h5>
<p>The standard-library containers handle self-assignment elegantly and efficiently:</p>
<div class="language-text highlight"><pre><span></span><code>std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9};
v = v;
// the value of v is still {3, 1, 4, 1, 5, 9}
</code></pre></div>
<h5 id="note_48">Note<a class="headerlink" href="#note_48" title="Permanent link">&para;</a></h5>
<p>The default assignment generated from members that handle self-assignment correctly handles self-assignment.</p>
<div class="language-text highlight"><pre><span></span><code>struct Bar {
    vector&lt;pair&lt;int, int&gt;&gt; v;
    map&lt;string, int&gt; m;
    string s;
};

Bar b;
// ...
b = b;   // correct and efficient
</code></pre></div>
<h5 id="note_49">Note<a class="headerlink" href="#note_49" title="Permanent link">&para;</a></h5>
<p>You can handle self-assignment by explicitly testing for self-assignment, but often it is faster and more elegant to cope without such a test (e.g., <a href="#Rc-swap">using <code>swap</code></a>).</p>
<div class="language-text highlight"><pre><span></span><code>class Foo {
    string s;
    int i;
public:
    Foo&amp; operator=(const Foo&amp; a);
    // ...
};

Foo&amp; Foo::operator=(const Foo&amp; a)   // OK, but there is a cost
{
    if (this == &amp;a) return *this;
    s = a.s;
    i = a.i;
    return *this;
}
</code></pre></div>
<p>This is obviously safe and apparently efficient.
However, what if we do one self-assignment per million assignments?
That's about a million redundant tests (but since the answer is essentially always the same, the computer's branch predictor will guess right essentially every time).
Consider:</p>
<div class="language-text highlight"><pre><span></span><code>Foo&amp; Foo::operator=(const Foo&amp; a)   // simpler, and probably much better
{
    s = a.s;
    i = a.i;
    return *this;
}
</code></pre></div>
<p><code>std::string</code> is safe for self-assignment and so are <code>int</code>. All the cost is carried by the (rare) case of self-assignment.</p>
<h5 id="enforcement_34">Enforcement<a class="headerlink" href="#enforcement_34" title="Permanent link">&para;</a></h5>
<p>(Simple) Assignment operators should not contain the pattern <code>if (this == &amp;a) return *this;</code> ???</p>
<h3 id="c63-make-move-assignment-non-virtual-take-the-parameter-by-and-return-by-non-const"><a name="Rc-move-assignment"></a>C.63: Make move assignment non-<code>virtual</code>, take the parameter by <code>&amp;&amp;</code>, and return by non-<code>const&amp;</code><a class="headerlink" href="#c63-make-move-assignment-non-virtual-take-the-parameter-by-and-return-by-non-const" title="Permanent link">&para;</a></h3>
<h5 id="reason_37">Reason<a class="headerlink" href="#reason_37" title="Permanent link">&para;</a></h5>
<p>It is simple and efficient.</p>
<p><strong>See</strong>: <a href="#Rc-copy-assignment">The rule for copy-assignment</a>.</p>
<h5 id="enforcement_35">Enforcement<a class="headerlink" href="#enforcement_35" title="Permanent link">&para;</a></h5>
<p>Equivalent to what is done for <a href="#Rc-copy-assignment">copy-assignment</a>.</p>
<ul>
<li>(Simple) An assignment operator should not be virtual. Here be dragons!</li>
<li>(Simple) An assignment operator should return <code>T&amp;</code> to enable chaining, not alternatives like <code>const T&amp;</code> which interfere with composability and putting objects in containers.</li>
<li>(Moderate) A move assignment operator should (implicitly or explicitly) invoke all base and member move assignment operators.</li>
</ul>
<h3 id="c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state"><a name="Rc-move-semantic"></a>C.64: A move operation should move and leave its source in a valid state<a class="headerlink" href="#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state" title="Permanent link">&para;</a></h3>
<h5 id="reason_38">Reason<a class="headerlink" href="#reason_38" title="Permanent link">&para;</a></h5>
<p>That is the generally assumed semantics.
After <code>y = std::move(x)</code> the value of <code>y</code> should be the value <code>x</code> had and <code>x</code> should be in a valid state.</p>
<h5 id="example_30">Example<a class="headerlink" href="#example_30" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X {   // OK: value semantics
public:
    X();
    X(X&amp;&amp; a) noexcept;  // move X
    X&amp; operator=(X&amp;&amp; a) noexcept; // move-assign X
    void modify();     // change the value of X
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};

X::X(X&amp;&amp; a) noexcept
    :p{a.p}, sz{a.sz}  // steal representation
{
    a.p = nullptr;     // set to &quot;empty&quot;
    a.sz = 0;
}

void use()
{
    X x{};
    // ...
    X y = std::move(x);
    x = X{};   // OK
} // OK: x can be destroyed
</code></pre></div>
<h5 id="note_50">Note<a class="headerlink" href="#note_50" title="Permanent link">&para;</a></h5>
<p>Ideally, that moved-from should be the default value of the type.
Ensure that unless there is an exceptionally good reason not to.
However, not all types have a default value and for some types establishing the default value can be expensive.
The standard requires only that the moved-from object can be destroyed.
Often, we can easily and cheaply do better: The standard library assumes that it is possible to assign to a moved-from object.
Always leave the moved-from object in some (necessarily specified) valid state.</p>
<h5 id="note_51">Note<a class="headerlink" href="#note_51" title="Permanent link">&para;</a></h5>
<p>Unless there is an exceptionally strong reason not to, make <code>x = std::move(y); y = z;</code> work with the conventional semantics.</p>
<h5 id="enforcement_36">Enforcement<a class="headerlink" href="#enforcement_36" title="Permanent link">&para;</a></h5>
<p>(Not enforceable) Look for assignments to members in the move operation. If there is a default constructor, compare those assignments to the initializations in the default constructor.</p>
<h3 id="c65-make-move-assignment-safe-for-self-assignment"><a name="Rc-move-self"></a>C.65: Make move assignment safe for self-assignment<a class="headerlink" href="#c65-make-move-assignment-safe-for-self-assignment" title="Permanent link">&para;</a></h3>
<h5 id="reason_39">Reason<a class="headerlink" href="#reason_39" title="Permanent link">&para;</a></h5>
<p>If <code>x = x</code> changes the value of <code>x</code>, people will be surprised and bad errors can occur. However, people don't usually directly write a self-assignment that turn into a move, but it can occur. However, <code>std::swap</code> is implemented using move operations so if you accidentally do <code>swap(a, b)</code> where <code>a</code> and <code>b</code> refer to the same object, failing to handle self-move could be a serious and subtle error.</p>
<h5 id="example_31">Example<a class="headerlink" href="#example_31" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Foo {
    string s;
    int i;
public:
    Foo&amp; operator=(Foo&amp;&amp; a) noexcept;
    // ...
};

Foo&amp; Foo::operator=(Foo&amp;&amp; a) noexcept  // OK, but there is a cost
{
    if (this == &amp;a) return *this;  // this line is redundant
    s = std::move(a.s);
    i = a.i;
    return *this;
}
</code></pre></div>
<p>The one-in-a-million argument against <code>if (this == &amp;a) return *this;</code> tests from the discussion of <a href="#Rc-copy-self">self-assignment</a> is even more relevant for self-move.</p>
<h5 id="note_52">Note<a class="headerlink" href="#note_52" title="Permanent link">&para;</a></h5>
<p>There is no known general way of avoiding an <code>if (this == &amp;a) return *this;</code> test for a move assignment and still get a correct answer (i.e., after <code>x = x</code> the value of <code>x</code> is unchanged).</p>
<h5 id="note_53">Note<a class="headerlink" href="#note_53" title="Permanent link">&para;</a></h5>
<p>The ISO standard guarantees only a "valid but unspecified" state for the standard-library containers. Apparently this has not been a problem in about 10 years of experimental and production use. Please contact the editors if you find a counter example. The rule here is more caution and insists on complete safety.</p>
<h5 id="example_32">Example<a class="headerlink" href="#example_32" title="Permanent link">&para;</a></h5>
<p>Here is a way to move a pointer without a test (imagine it as code in the implementation a move assignment):</p>
<div class="language-text highlight"><pre><span></span><code>// move from other.ptr to this-&gt;ptr
T* temp = other.ptr;
other.ptr = nullptr;
delete ptr; // in self-move, this-&gt;ptr is also null; delete is a no-op
ptr = temp; // in self-move, the original ptr is restored
</code></pre></div>
<h5 id="enforcement_37">Enforcement<a class="headerlink" href="#enforcement_37" title="Permanent link">&para;</a></h5>
<ul>
<li>(Moderate) In the case of self-assignment, a move assignment operator should not leave the object holding pointer members that have been <code>delete</code>d or set to <code>nullptr</code>.</li>
<li>(Not enforceable) Look at the use of standard-library container types (incl. <code>string</code>) and consider them safe for ordinary (not life-critical) uses.</li>
</ul>
<h3 id="c66-make-move-operations-noexcept"><a name="Rc-move-noexcept"></a>C.66: Make move operations <code>noexcept</code><a class="headerlink" href="#c66-make-move-operations-noexcept" title="Permanent link">&para;</a></h3>
<h5 id="reason_40">Reason<a class="headerlink" href="#reason_40" title="Permanent link">&para;</a></h5>
<p>A throwing move violates most people's reasonable assumptions.
A non-throwing move will be used more efficiently by standard-library and language facilities.</p>
<h5 id="example_33">Example<a class="headerlink" href="#example_33" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
class Vector {
public:
    Vector(Vector&amp;&amp; a) noexcept :elem{a.elem}, sz{a.sz} { a.elem = nullptr; a.sz = 0; }
    Vector&amp; operator=(Vector&amp;&amp; a) noexcept {
        if (&amp;a != this) {
            delete elem;
            elem = a.elem; a.elem = nullptr;
            sz   = a.sz;   a.sz   = 0;
        }
        return *this;
    }
    // ...
private:
    T* elem;
    int sz;
};
</code></pre></div>
<p>These operations do not throw.</p>
<h5 id="example-bad_18">Example, bad<a class="headerlink" href="#example-bad_18" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
class Vector2 {
public:
    Vector2(Vector2&amp;&amp; a) noexcept { *this = a; }             // just use the copy
    Vector2&amp; operator=(Vector2&amp;&amp; a) noexcept { *this = a; }  // just use the copy
    // ...
private:
    T* elem;
    int sz;
};
</code></pre></div>
<p>This <code>Vector2</code> is not just inefficient, but since a vector copy requires allocation, it can throw.</p>
<h5 id="enforcement_38">Enforcement<a class="headerlink" href="#enforcement_38" title="Permanent link">&para;</a></h5>
<p>(Simple) A move operation should be marked <code>noexcept</code>.</p>
<h3 id="c67-a-polymorphic-class-should-suppress-public-copymove"><a name="Rc-copy-virtual"></a>C.67: A polymorphic class should suppress public copy/move<a class="headerlink" href="#c67-a-polymorphic-class-should-suppress-public-copymove" title="Permanent link">&para;</a></h3>
<h5 id="reason_41">Reason<a class="headerlink" href="#reason_41" title="Permanent link">&para;</a></h5>
<p>A <em>polymorphic class</em> is a class that defines or inherits at least one virtual function. It is likely that it will be used as a base class for other derived classes with polymorphic behavior. If it is accidentally passed by value, with the implicitly generated copy constructor and assignment, we risk slicing: only the base portion of a derived object will be copied, and the polymorphic behavior will be corrupted.</p>
<p>If the class has no data, <code>=delete</code> the copy/move functions. Otherwise, make them protected.</p>
<h5 id="example-bad_19">Example, bad<a class="headerlink" href="#example-bad_19" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class B { // BAD: polymorphic base class doesn&#39;t suppress copying
public:
    virtual char m() { return &#39;B&#39;; }
    // ... nothing about copy operations, so uses default ...
};

class D : public B {
public:
    char m() override { return &#39;D&#39;; }
    // ...
};

void f(B&amp; b)
{
    auto b2 = b; // oops, slices the object; b2.m() will return &#39;B&#39;
}

D d;
f(d);
</code></pre></div>
<h5 id="example_34">Example<a class="headerlink" href="#example_34" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class B { // GOOD: polymorphic class suppresses copying
public:
    B() = default;
    B(const B&amp;) = delete;
    B&amp; operator=(const B&amp;) = delete;
    virtual char m() { return &#39;B&#39;; }
    // ...
};

class D : public B {
public:
    char m() override { return &#39;D&#39;; }
    // ...
};

void f(B&amp; b)
{
    auto b2 = b; // ok, compiler will detect inadvertent copying, and protest
}

D d;
f(d);
</code></pre></div>
<h5 id="note_54">Note<a class="headerlink" href="#note_54" title="Permanent link">&para;</a></h5>
<p>If you need to create deep copies of polymorphic objects, use <code>clone()</code> functions: see <a href="#Rh-copy">C.130</a>.</p>
<h5 id="exception_8">Exception<a class="headerlink" href="#exception_8" title="Permanent link">&para;</a></h5>
<p>Classes that represent exception objects need both to be polymorphic and copy-constructible.</p>
<h5 id="enforcement_39">Enforcement<a class="headerlink" href="#enforcement_39" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag a polymorphic class with a public copy operation.</li>
<li>Flag an assignment of polymorphic class objects.</li>
</ul>
<h2 id="cother-other-default-operation-rules">C.other: Other default operation rules<a class="headerlink" href="#cother-other-default-operation-rules" title="Permanent link">&para;</a></h2>
<p>In addition to the operations for which the language offers default implementations,
there are a few operations that are so foundational that specific rules for their definition are needed:
comparisons, <code>swap</code>, and <code>hash</code>.</p>
<h3 id="c80-use-default-if-you-have-to-be-explicit-about-using-the-default-semantics"><a name="Rc-eqdefault"></a>C.80: Use <code>=default</code> if you have to be explicit about using the default semantics<a class="headerlink" href="#c80-use-default-if-you-have-to-be-explicit-about-using-the-default-semantics" title="Permanent link">&para;</a></h3>
<h5 id="reason_42">Reason<a class="headerlink" href="#reason_42" title="Permanent link">&para;</a></h5>
<p>The compiler is more likely to get the default semantics right and you cannot implement these functions better than the compiler.</p>
<h5 id="example_35">Example<a class="headerlink" href="#example_35" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Tracer {
    string message;
public:
    Tracer(const string&amp; m) : message{m} { cerr &lt;&lt; &quot;entering &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }
    ~Tracer() { cerr &lt;&lt; &quot;exiting &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }

    Tracer(const Tracer&amp;) = default;
    Tracer&amp; operator=(const Tracer&amp;) = default;
    Tracer(Tracer&amp;&amp;) noexcept = default;
    Tracer&amp; operator=(Tracer&amp;&amp;) noexcept = default;
};
</code></pre></div>
<p>Because we defined the destructor, we must define the copy and move operations. The <code>= default</code> is the best and simplest way of doing that.</p>
<h5 id="example-bad_20">Example, bad<a class="headerlink" href="#example-bad_20" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Tracer2 {
    string message;
public:
    Tracer2(const string&amp; m) : message{m} { cerr &lt;&lt; &quot;entering &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }
    ~Tracer2() { cerr &lt;&lt; &quot;exiting &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }

    Tracer2(const Tracer2&amp; a) : message{a.message} {}
    Tracer2&amp; operator=(const Tracer2&amp; a) { message = a.message; return *this; }
    Tracer2(Tracer2&amp;&amp; a) noexcept :message{a.message} {}
    Tracer2&amp; operator=(Tracer2&amp;&amp; a) noexcept { message = a.message; return *this; }
};
</code></pre></div>
<p>Writing out the bodies of the copy and move operations is verbose, tedious, and error-prone. A compiler does it better.</p>
<h5 id="enforcement_40">Enforcement<a class="headerlink" href="#enforcement_40" title="Permanent link">&para;</a></h5>
<p>(Moderate) The body of a user-defined operation should not have the same semantics as the compiler-generated version, because that would be redundant.</p>
<h3 id="c81-use-delete-when-you-want-to-disable-default-behavior-without-wanting-an-alternative"><a name="Rc-delete"></a>C.81: Use <code>=delete</code> when you want to disable default behavior (without wanting an alternative)<a class="headerlink" href="#c81-use-delete-when-you-want-to-disable-default-behavior-without-wanting-an-alternative" title="Permanent link">&para;</a></h3>
<h5 id="reason_43">Reason<a class="headerlink" href="#reason_43" title="Permanent link">&para;</a></h5>
<p>In a few cases, a default operation is not desirable.</p>
<h5 id="example_36">Example<a class="headerlink" href="#example_36" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Immortal {
public:
    ~Immortal() = delete;   // do not allow destruction
    // ...
};

void use()
{
    Immortal ugh;   // error: ugh cannot be destroyed
    Immortal* p = new Immortal{};
    delete p;       // error: cannot destroy *p
}
</code></pre></div>
<h5 id="example_37">Example<a class="headerlink" href="#example_37" title="Permanent link">&para;</a></h5>
<p>A <code>unique_ptr</code> can be moved, but not copied. To achieve that its copy operations are deleted. To avoid copying it is necessary to <code>=delete</code> its copy operations from lvalues:</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
public:
    // ...
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    // ...
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;   // move constructor
    // ...
    unique_ptr(const unique_ptr&amp;) = delete; // disable copy from lvalue
    // ...
};

unique_ptr&lt;int&gt; make();   // make &quot;something&quot; and return it by moving

void f()
{
    unique_ptr&lt;int&gt; pi {};
    auto pi2 {pi};      // error: no move constructor from lvalue
    auto pi3 {make()};  // OK, move: the result of make() is an rvalue
}
</code></pre></div>
<p>Note that deleted functions should be public.</p>
<h5 id="enforcement_41">Enforcement<a class="headerlink" href="#enforcement_41" title="Permanent link">&para;</a></h5>
<p>The elimination of a default operation is (should be) based on the desired semantics of the class. Consider such classes suspect, but maintain a "positive list" of classes where a human has asserted that the semantics is correct.</p>
<h3 id="c82-dont-call-virtual-functions-in-constructors-and-destructors"><a name="Rc-ctor-virtual"></a>C.82: Don't call virtual functions in constructors and destructors<a class="headerlink" href="#c82-dont-call-virtual-functions-in-constructors-and-destructors" title="Permanent link">&para;</a></h3>
<h5 id="reason_44">Reason<a class="headerlink" href="#reason_44" title="Permanent link">&para;</a></h5>
<p>The function called will be that of the object constructed so far, rather than a possibly overriding function in a derived class.
This can be most confusing.
Worse, a direct or indirect call to an unimplemented pure virtual function from a constructor or destructor results in undefined behavior.</p>
<h5 id="example-bad_21">Example, bad<a class="headerlink" href="#example-bad_21" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Base {
public:
    virtual void f() = 0;   // not implemented
    virtual void g();       // implemented with Base version
    virtual void h();       // implemented with Base version
    virtual ~Base();        // implemented with Base version
};

class Derived : public Base {
public:
    void g() override;   // provide Derived implementation
    void h() final;      // provide Derived implementation

    Derived()
    {
        // BAD: attempt to call an unimplemented virtual function
        f();

        // BAD: will call Derived::g, not dispatch further virtually
        g();

        // GOOD: explicitly state intent to call only the visible version
        Derived::g();

        // ok, no qualification needed, h is final
        h();
    }
};
</code></pre></div>
<p>Note that calling a specific explicitly qualified function is not a virtual call even if the function is <code>virtual</code>.</p>
<p><strong>See also</strong> <a href="#Rc-factory">factory functions</a> for how to achieve the effect of a call to a derived class function without risking undefined behavior.</p>
<h5 id="note_55">Note<a class="headerlink" href="#note_55" title="Permanent link">&para;</a></h5>
<p>There is nothing inherently wrong with calling virtual functions from constructors and destructors.
The semantics of such calls is type safe.
However, experience shows that such calls are rarely needed, easily confuse maintainers, and become a source of errors when used by novices.</p>
<h5 id="enforcement_42">Enforcement<a class="headerlink" href="#enforcement_42" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag calls of virtual functions from constructors and destructors.</li>
</ul>
<h3 id="c83-for-value-like-types-consider-providing-a-noexcept-swap-function"><a name="Rc-swap"></a>C.83: For value-like types, consider providing a <code>noexcept</code> swap function<a class="headerlink" href="#c83-for-value-like-types-consider-providing-a-noexcept-swap-function" title="Permanent link">&para;</a></h3>
<h5 id="reason_45">Reason<a class="headerlink" href="#reason_45" title="Permanent link">&para;</a></h5>
<p>A <code>swap</code> can be handy for implementing a number of idioms, from smoothly moving objects around to implementing assignment easily to providing a guaranteed commit function that enables strongly error-safe calling code. Consider using swap to implement copy assignment in terms of copy construction. See also <a href="#Re-never-fail">destructors, deallocation, and swap must never fail</a>.</p>
<h5 id="example-good_3">Example, good<a class="headerlink" href="#example-good_3" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Foo {
public:
    void swap(Foo&amp; rhs) noexcept
    {
        m1.swap(rhs.m1);
        std::swap(m2, rhs.m2);
    }
private:
    Bar m1;
    int m2;
};
</code></pre></div>
<p>Providing a non-member <code>swap</code> function in the same namespace as your type for callers' convenience.</p>
<div class="language-text highlight"><pre><span></span><code>void swap(Foo&amp; a, Foo&amp; b)
{
    a.swap(b);
}
</code></pre></div>
<h5 id="enforcement_43">Enforcement<a class="headerlink" href="#enforcement_43" title="Permanent link">&para;</a></h5>
<ul>
<li>Non-trivially copyable types should provide a member swap or a free swap overload.</li>
<li>(Simple) When a class has a <code>swap</code> member function, it should be declared <code>noexcept</code>.</li>
</ul>
<h3 id="c84-a-swap-function-must-not-fail"><a name="Rc-swap-fail"></a>C.84: A <code>swap</code> function must not fail<a class="headerlink" href="#c84-a-swap-function-must-not-fail" title="Permanent link">&para;</a></h3>
<h5 id="reason_46">Reason<a class="headerlink" href="#reason_46" title="Permanent link">&para;</a></h5>
<p><code>swap</code> is widely used in ways that are assumed never to fail and programs cannot easily be written to work correctly in the presence of a failing <code>swap</code>. The standard-library containers and algorithms will not work correctly if a swap of an element type fails.</p>
<h5 id="example-bad_22">Example, bad<a class="headerlink" href="#example-bad_22" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void swap(My_vector&amp; x, My_vector&amp; y)
{
    auto tmp = x;   // copy elements
    x = y;
    y = tmp;
}
</code></pre></div>
<p>This is not just slow, but if a memory allocation occurs for the elements in <code>tmp</code>, this <code>swap</code> could throw and would make STL algorithms fail if used with them.</p>
<h5 id="enforcement_44">Enforcement<a class="headerlink" href="#enforcement_44" title="Permanent link">&para;</a></h5>
<p>(Simple) When a class has a <code>swap</code> member function, it should be declared <code>noexcept</code>.</p>
<h3 id="c85-make-swap-noexcept"><a name="Rc-swap-noexcept"></a>C.85: Make <code>swap</code> <code>noexcept</code><a class="headerlink" href="#c85-make-swap-noexcept" title="Permanent link">&para;</a></h3>
<h5 id="reason_47">Reason<a class="headerlink" href="#reason_47" title="Permanent link">&para;</a></h5>
<p><a href="#Rc-swap-fail">A <code>swap</code> must not fail</a>.
If a <code>swap</code> tries to exit with an exception, it's a bad design error and the program had better terminate.</p>
<h5 id="enforcement_45">Enforcement<a class="headerlink" href="#enforcement_45" title="Permanent link">&para;</a></h5>
<p>(Simple) When a class has a <code>swap</code> member function, it should be declared <code>noexcept</code>.</p>
<h3 id="c86-make-symmetric-with-respect-to-operand-types-and-noexcept"><a name="Rc-eq"></a>C.86: Make <code>==</code> symmetric with respect to operand types and <code>noexcept</code><a class="headerlink" href="#c86-make-symmetric-with-respect-to-operand-types-and-noexcept" title="Permanent link">&para;</a></h3>
<h5 id="reason_48">Reason<a class="headerlink" href="#reason_48" title="Permanent link">&para;</a></h5>
<p>Asymmetric treatment of operands is surprising and a source of errors where conversions are possible.
<code>==</code> is a fundamental operation and programmers should be able to use it without fear of failure.</p>
<h5 id="example_38">Example<a class="headerlink" href="#example_38" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct X {
    string name;
    int number;
};

bool operator==(const X&amp; a, const X&amp; b) noexcept {
    return a.name == b.name &amp;&amp; a.number == b.number;
}
</code></pre></div>
<h5 id="example-bad_23">Example, bad<a class="headerlink" href="#example-bad_23" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class B {
    string name;
    int number;
    bool operator==(const B&amp; a) const {
        return name == a.name &amp;&amp; number == a.number;
    }
    // ...
};
</code></pre></div>
<p><code>B</code>'s comparison accepts conversions for its second operand, but not its first.</p>
<h5 id="note_56">Note<a class="headerlink" href="#note_56" title="Permanent link">&para;</a></h5>
<p>If a class has a failure state, like <code>double</code>'s <code>NaN</code>, there is a temptation to make a comparison against the failure state throw.
The alternative is to make two failure states compare equal and any valid state compare false against the failure state.</p>
<h5 id="note_57">Note<a class="headerlink" href="#note_57" title="Permanent link">&para;</a></h5>
<p>This rule applies to all the usual comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<h5 id="enforcement_46">Enforcement<a class="headerlink" href="#enforcement_46" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag an <code>operator==()</code> for which the argument types differ; same for other comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</li>
<li>Flag member <code>operator==()</code>s; same for other comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</li>
</ul>
<h3 id="c87-beware-of-on-base-classes"><a name="Rc-eq-base"></a>C.87: Beware of <code>==</code> on base classes<a class="headerlink" href="#c87-beware-of-on-base-classes" title="Permanent link">&para;</a></h3>
<h5 id="reason_49">Reason<a class="headerlink" href="#reason_49" title="Permanent link">&para;</a></h5>
<p>It is really hard to write a foolproof and useful <code>==</code> for a hierarchy.</p>
<h5 id="example-bad_24">Example, bad<a class="headerlink" href="#example-bad_24" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class B {
    string name;
    int number;
public:
    virtual bool operator==(const B&amp; a) const
    {
         return name == a.name &amp;&amp; number == a.number;
    }
    // ...
};
</code></pre></div>
<p><code>B</code>'s comparison accepts conversions for its second operand, but not its first.</p>
<div class="language-text highlight"><pre><span></span><code>class D : public B {
    char character;
public:
    virtual bool operator==(const D&amp; a) const
    {
        return B::operator==(a) &amp;&amp; character == a.character;
    }
    // ...
};

B b = ...
D d = ...
b == d;    // compares name and number, ignores d&#39;s character
d == b;    // compares name and number, ignores d&#39;s character
D d2;
d == d2;   // compares name, number, and character
B&amp; b2 = d2;
b2 == d;   // compares name and number, ignores d2&#39;s and d&#39;s character
</code></pre></div>
<p>Of course there are ways of making <code>==</code> work in a hierarchy, but the naive approaches do not scale</p>
<h5 id="note_58">Note<a class="headerlink" href="#note_58" title="Permanent link">&para;</a></h5>
<p>This rule applies to all the usual comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and <code>&lt;=&gt;</code>.</p>
<h5 id="enforcement_47">Enforcement<a class="headerlink" href="#enforcement_47" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag a virtual <code>operator==()</code>; same for other comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and <code>&lt;=&gt;</code>.</li>
</ul>
<h3 id="c89-make-a-hash-noexcept"><a name="Rc-hash"></a>C.89: Make a <code>hash</code> <code>noexcept</code><a class="headerlink" href="#c89-make-a-hash-noexcept" title="Permanent link">&para;</a></h3>
<h5 id="reason_50">Reason<a class="headerlink" href="#reason_50" title="Permanent link">&para;</a></h5>
<p>Users of hashed containers use hash indirectly and don't expect simple access to throw.
It's a standard-library requirement.</p>
<h5 id="example-bad_25">Example, bad<a class="headerlink" href="#example-bad_25" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;&gt;
struct hash&lt;My_type&gt; {  // thoroughly bad hash specialization
    using result_type = size_t;
    using argument_type = My_type;

    size_t operator()(const My_type &amp; x) const
    {
        size_t xs = x.s.size();
        if (xs &lt; 4) throw Bad_My_type{};    // &quot;Nobody expects the Spanish inquisition!&quot;
        return hash&lt;size_t&gt;()(x.s.size()) ^ trim(x.s);
    }
};

int main()
{
    unordered_map&lt;My_type, int&gt; m;
    My_type mt{ &quot;asdfg&quot; };
    m[mt] = 7;
    cout &lt;&lt; m[My_type{ &quot;asdfg&quot; }] &lt;&lt; &#39;\n&#39;;
}
</code></pre></div>
<p>If you have to define a <code>hash</code> specialization, try simply to let it combine standard-library <code>hash</code> specializations with <code>^</code> (xor).
That tends to work better than "cleverness" for non-specialists.</p>
<h5 id="enforcement_48">Enforcement<a class="headerlink" href="#enforcement_48" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag throwing <code>hash</code>es.</li>
</ul>
<h3 id="c90-rely-on-constructors-and-assignment-operators-not-memset-and-memcpy"><a name="Rc-memset"></a>C.90: Rely on constructors and assignment operators, not <code>memset</code> and <code>memcpy</code><a class="headerlink" href="#c90-rely-on-constructors-and-assignment-operators-not-memset-and-memcpy" title="Permanent link">&para;</a></h3>
<h5 id="reason_51">Reason<a class="headerlink" href="#reason_51" title="Permanent link">&para;</a></h5>
<p>The standard C++ mechanism to construct an instance of a type is to call its constructor. As specified in guideline <a href="#Rc-complete">C.41</a>: a constructor should create a fully initialized object. No additional initialization, such as by <code>memcpy</code>, should be required.
A type will provide a copy constructor and/or copy assignment operator to appropriately make a copy of the class, preserving the type's invariants.  Using memcpy to copy a non-trivially copyable type has undefined behavior.  Frequently this results in slicing, or data corruption.</p>
<h5 id="example-good_4">Example, good<a class="headerlink" href="#example-good_4" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct base {
    virtual void update() = 0;
    std::shared_ptr&lt;int&gt; sp;
};

struct derived : public base {
    void update() override {}
};
</code></pre></div>
<h5 id="example-bad_26">Example, bad<a class="headerlink" href="#example-bad_26" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void init(derived&amp; a)
{
    memset(&amp;a, 0, sizeof(derived));
}
</code></pre></div>
<p>This is type-unsafe and overwrites the vtable.</p>
<h5 id="example-bad_27">Example, bad<a class="headerlink" href="#example-bad_27" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void copy(derived&amp; a, derived&amp; b)
{
    memcpy(&amp;a, &amp;b, sizeof(derived));
}
</code></pre></div>
<p>This is also type-unsafe and overwrites the vtable.</p>
<h5 id="enforcement_49">Enforcement<a class="headerlink" href="#enforcement_49" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag passing a non-trivially-copyable type to <code>memset</code> or <code>memcpy</code>.</li>
</ul>
<h2 id="ccon-containers-and-other-resource-handles"><a name="SS-containers"></a>C.con: Containers and other resource handles<a class="headerlink" href="#ccon-containers-and-other-resource-handles" title="Permanent link">&para;</a></h2>
<p>A container is an object holding a sequence of objects of some type; <code>std::vector</code> is the archetypical container.
A resource handle is a class that owns a resource; <code>std::vector</code> is the typical resource handle; its resource is its sequence of elements.</p>
<p>Summary of container rules:</p>
<ul>
<li><a href="#Rcon-stl">C.100: Follow the STL when defining a container</a></li>
<li><a href="#Rcon-val">C.101: Give a container value semantics</a></li>
<li><a href="#Rcon-move">C.102: Give a container move operations</a></li>
<li><a href="#Rcon-init">C.103: Give a container an initializer list constructor</a></li>
<li><a href="#Rcon-empty">C.104: Give a container a default constructor that sets it to empty</a></li>
<li>???</li>
<li><a href="#Rcon-ptr">C.109: If a resource handle has pointer semantics, provide <code>*</code> and <code>-&gt;</code></a></li>
</ul>
<p><strong>See also</strong>: <a href="#S-resource">Resources</a></p>
<h3 id="c100-follow-the-stl-when-defining-a-container"><a name="Rcon-stl"></a>C.100: Follow the STL when defining a container<a class="headerlink" href="#c100-follow-the-stl-when-defining-a-container" title="Permanent link">&para;</a></h3>
<h5 id="reason_52">Reason<a class="headerlink" href="#reason_52" title="Permanent link">&para;</a></h5>
<p>The STL containers are familiar to most C++ programmers and a fundamentally sound design.</p>
<h5 id="note_59">Note<a class="headerlink" href="#note_59" title="Permanent link">&para;</a></h5>
<p>There are of course other fundamentally sound design styles and sometimes reasons to depart from
the style of the standard library, but in the absence of a solid reason to differ, it is simpler
and easier for both implementers and users to follow the standard.</p>
<p>In particular, <code>std::vector</code> and <code>std::map</code> provide useful relatively simple models.</p>
<h5 id="example_39">Example<a class="headerlink" href="#example_39" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>// simplified (e.g., no allocators):

template&lt;typename T&gt;
class Sorted_vector {
    using value_type = T;
    // ... iterator types ...

    Sorted_vector() = default;
    Sorted_vector(initializer_list&lt;T&gt;);    // initializer-list constructor: sort and store
    Sorted_vector(const Sorted_vector&amp;) = default;
    Sorted_vector(Sorted_vector&amp;&amp;) noexcept = default;
    Sorted_vector&amp; operator=(const Sorted_vector&amp;) = default;     // copy assignment
    Sorted_vector&amp; operator=(Sorted_vector&amp;&amp;) noexcept = default; // move assignment
    ~Sorted_vector() = default;

    Sorted_vector(const std::vector&lt;T&gt;&amp; v);   // store and sort
    Sorted_vector(std::vector&lt;T&gt;&amp;&amp; v);        // sort and &quot;steal representation&quot;

    const T&amp; operator[](int i) const { return rep[i]; }
    // no non-const direct access to preserve order

    void push_back(const T&amp;);   // insert in the right place (not necessarily at back)
    void push_back(T&amp;&amp;);        // insert in the right place (not necessarily at back)

    // ... cbegin(), cend() ...
private:
    std::vector&lt;T&gt; rep;  // use a std::vector to hold elements
};

template&lt;typename T&gt; bool operator==(const Sorted_vector&lt;T&gt;&amp;, const Sorted_vector&lt;T&gt;&amp;);
template&lt;typename T&gt; bool operator!=(const Sorted_vector&lt;T&gt;&amp;, const Sorted_vector&lt;T&gt;&amp;);
// ...
</code></pre></div>
<p>Here, the STL style is followed, but incompletely.
That's not uncommon.
Provide only as much functionality as makes sense for a specific container.
The key is to define the conventional constructors, assignments, destructors, and iterators
(as meaningful for the specific container) with their conventional semantics.
From that base, the container can be expanded as needed.
Here, special constructors from <code>std::vector</code> were added.</p>
<h5 id="enforcement_50">Enforcement<a class="headerlink" href="#enforcement_50" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c101-give-a-container-value-semantics"><a name="Rcon-val"></a>C.101: Give a container value semantics<a class="headerlink" href="#c101-give-a-container-value-semantics" title="Permanent link">&para;</a></h3>
<h5 id="reason_53">Reason<a class="headerlink" href="#reason_53" title="Permanent link">&para;</a></h5>
<p>Regular objects are simpler to think and reason about than irregular ones.
Familiarity.</p>
<h5 id="note_60">Note<a class="headerlink" href="#note_60" title="Permanent link">&para;</a></h5>
<p>If meaningful, make a container <code>Regular</code> (the concept).
In particular, ensure that an object compares equal to its copy.</p>
<h5 id="example_40">Example<a class="headerlink" href="#example_40" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(const Sorted_vector&lt;string&gt;&amp; v)
{
    Sorted_vector&lt;string&gt; v2 {v};
    if (v != v2)
        cout &lt;&lt; &quot;Behavior against reason and logic.\n&quot;;
    // ...
}
</code></pre></div>
<h5 id="enforcement_51">Enforcement<a class="headerlink" href="#enforcement_51" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c102-give-a-container-move-operations"><a name="Rcon-move"></a>C.102: Give a container move operations<a class="headerlink" href="#c102-give-a-container-move-operations" title="Permanent link">&para;</a></h3>
<h5 id="reason_54">Reason<a class="headerlink" href="#reason_54" title="Permanent link">&para;</a></h5>
<p>Containers tend to get large; without a move constructor and a copy constructor an object can be
expensive to move around, thus tempting people to pass pointers to it around and getting into
resource management problems.</p>
<h5 id="example_41">Example<a class="headerlink" href="#example_41" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>Sorted_vector&lt;int&gt; read_sorted(istream&amp; is)
{
    vector&lt;int&gt; v;
    cin &gt;&gt; v;   // assume we have a read operation for vectors
    Sorted_vector&lt;int&gt; sv = v;  // sorts
    return sv;
}
</code></pre></div>
<p>A user can reasonably assume that returning a standard-like container is cheap.</p>
<h5 id="enforcement_52">Enforcement<a class="headerlink" href="#enforcement_52" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c103-give-a-container-an-initializer-list-constructor"><a name="Rcon-init"></a>C.103: Give a container an initializer list constructor<a class="headerlink" href="#c103-give-a-container-an-initializer-list-constructor" title="Permanent link">&para;</a></h3>
<h5 id="reason_55">Reason<a class="headerlink" href="#reason_55" title="Permanent link">&para;</a></h5>
<p>People expect to be able to initialize a container with a set of values.
Familiarity.</p>
<h5 id="example_42">Example<a class="headerlink" href="#example_42" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>Sorted_vector&lt;int&gt; sv {1, 3, -1, 7, 0, 0}; // Sorted_vector sorts elements as needed
</code></pre></div>
<h5 id="enforcement_53">Enforcement<a class="headerlink" href="#enforcement_53" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c104-give-a-container-a-default-constructor-that-sets-it-to-empty"><a name="Rcon-empty"></a>C.104: Give a container a default constructor that sets it to empty<a class="headerlink" href="#c104-give-a-container-a-default-constructor-that-sets-it-to-empty" title="Permanent link">&para;</a></h3>
<h5 id="reason_56">Reason<a class="headerlink" href="#reason_56" title="Permanent link">&para;</a></h5>
<p>To make it <code>Regular</code>.</p>
<h5 id="example_43">Example<a class="headerlink" href="#example_43" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>vector&lt;Sorted_sequence&lt;string&gt;&gt; vs(100);    // 100 Sorted_sequences each with the value &quot;&quot;
</code></pre></div>
<h5 id="enforcement_54">Enforcement<a class="headerlink" href="#enforcement_54" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c109-if-a-resource-handle-has-pointer-semantics-provide-and-"><a name="Rcon-ptr"></a>C.109: If a resource handle has pointer semantics, provide <code>*</code> and <code>-&gt;</code><a class="headerlink" href="#c109-if-a-resource-handle-has-pointer-semantics-provide-and-" title="Permanent link">&para;</a></h3>
<h5 id="reason_57">Reason<a class="headerlink" href="#reason_57" title="Permanent link">&para;</a></h5>
<p>That's what is expected from pointers.
Familiarity.</p>
<h5 id="example_44">Example<a class="headerlink" href="#example_44" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>???
</code></pre></div>
<h5 id="enforcement_55">Enforcement<a class="headerlink" href="#enforcement_55" title="Permanent link">&para;</a></h5>
<p>???</p>
<h2 id="clambdas-function-objects-and-lambdas"><a name="SS-lambdas"></a>C.lambdas: Function objects and lambdas<a class="headerlink" href="#clambdas-function-objects-and-lambdas" title="Permanent link">&para;</a></h2>
<p>A function object is an object supplying an overloaded <code>()</code> so that you can call it.
A lambda expression (colloquially often shortened to "a lambda") is a notation for generating a function object.
Function objects should be cheap to copy (and therefore <a href="#Rf-in">passed by value</a>).</p>
<p>Summary:</p>
<ul>
<li><a href="#Rf-name">F.10: If an operation can be reused, give it a name</a></li>
<li><a href="#Rf-lambda">F.11: Use an unnamed lambda if you need a simple function object in one place only</a></li>
<li><a href="#Rf-capture-vs-overload">F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)</a></li>
<li><a href="#Rf-reference-capture">F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms</a></li>
<li><a href="#Rf-value-capture">F.53: Avoid capturing by reference in lambdas that will be used non-locally, including returned, stored on the heap, or passed to another thread</a></li>
<li><a href="#Res-lambda-init">ES.28: Use lambdas for complex initialization, especially of <code>const</code> variables</a></li>
</ul>
<h2 id="chier-class-hierarchies-oop"><a name="SS-hier"></a>C.hier: Class hierarchies (OOP)<a class="headerlink" href="#chier-class-hierarchies-oop" title="Permanent link">&para;</a></h2>
<p>A class hierarchy is constructed to represent a set of hierarchically organized concepts (only).
Typically base classes act as interfaces.
There are two major uses for hierarchies, often named implementation inheritance and interface inheritance.</p>
<p>Class hierarchy rule summary:</p>
<ul>
<li><a href="#Rh-domain">C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)</a></li>
<li><a href="#Rh-abstract">C.121: If a base class is used as an interface, make it a pure abstract class</a></li>
<li><a href="#Rh-separation">C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed</a></li>
</ul>
<p>Designing rules for classes in a hierarchy summary:</p>
<ul>
<li><a href="#Rh-abstract-ctor">C.126: An abstract class typically doesn't need a user-written constructor</a></li>
<li><a href="#Rh-dtor">C.127: A class with a virtual function should have a virtual or protected destructor</a></li>
<li><a href="#Rh-override">C.128: Virtual functions should specify exactly one of <code>virtual</code>, <code>override</code>, or <code>final</code></a></li>
<li><a href="#Rh-kind">C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance</a></li>
<li><a href="#Rh-copy">C.130: For making deep copies of polymorphic classes prefer a virtual <code>clone</code> function instead of public copy construction/assignment</a></li>
<li><a href="#Rh-get">C.131: Avoid trivial getters and setters</a></li>
<li><a href="#Rh-virtual">C.132: Don't make a function <code>virtual</code> without reason</a></li>
<li><a href="#Rh-protected">C.133: Avoid <code>protected</code> data</a></li>
<li><a href="#Rh-public">C.134: Ensure all non-<code>const</code> data members have the same access level</a></li>
<li><a href="#Rh-mi-interface">C.135: Use multiple inheritance to represent multiple distinct interfaces</a></li>
<li><a href="#Rh-mi-implementation">C.136: Use multiple inheritance to represent the union of implementation attributes</a></li>
<li><a href="#Rh-vbase">C.137: Use <code>virtual</code> bases to avoid overly general base classes</a></li>
<li><a href="#Rh-using">C.138: Create an overload set for a derived class and its bases with <code>using</code></a></li>
<li><a href="#Rh-final">C.139: Use <code>final</code> on classes sparingly</a></li>
<li><a href="#Rh-virtual-default-arg">C.140: Do not provide different default arguments for a virtual function and an overrider</a></li>
</ul>
<p>Accessing objects in a hierarchy rule summary:</p>
<ul>
<li><a href="#Rh-poly">C.145: Access polymorphic objects through pointers and references</a></li>
<li><a href="#Rh-dynamic_cast">C.146: Use <code>dynamic_cast</code> where class hierarchy navigation is unavoidable</a></li>
<li><a href="#Rh-ref-cast">C.147: Use <code>dynamic_cast</code> to a reference type when failure to find the required class is considered an error</a></li>
<li><a href="#Rh-ptr-cast">C.148: Use <code>dynamic_cast</code> to a pointer type when failure to find the required class is considered a valid alternative</a></li>
<li><a href="#Rh-smart">C.149: Use <code>unique_ptr</code> or <code>shared_ptr</code> to avoid forgetting to <code>delete</code> objects created using <code>new</code></a></li>
<li><a href="#Rh-make_unique">C.150: Use <code>make_unique()</code> to construct objects owned by <code>unique_ptr</code>s</a></li>
<li><a href="#Rh-make_shared">C.151: Use <code>make_shared()</code> to construct objects owned by <code>shared_ptr</code>s</a></li>
<li><a href="#Rh-array">C.152: Never assign a pointer to an array of derived class objects to a pointer to its base</a></li>
<li><a href="#Rh-use-virtual">C.153: Prefer virtual function to casting</a></li>
</ul>
<h3 id="c120-use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only"><a name="Rh-domain"></a>C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)<a class="headerlink" href="#c120-use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only" title="Permanent link">&para;</a></h3>
<h5 id="reason_58">Reason<a class="headerlink" href="#reason_58" title="Permanent link">&para;</a></h5>
<p>Direct representation of ideas in code eases comprehension and maintenance. Make sure the idea represented in the base class exactly matches all derived types and there is not a better way to express it than using the tight coupling of inheritance.</p>
<p>Do <em>not</em> use inheritance when simply having a data member will do. Usually this means that the derived type needs to override a base virtual function or needs access to a protected member.</p>
<h5 id="example_45">Example<a class="headerlink" href="#example_45" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class DrawableUIElement {
public:
    virtual void render() const = 0;
    // ...
};

class AbstractButton : public DrawableUIElement {
public:
    virtual void onClick() = 0;
    // ...
};

class PushButton : public AbstractButton {
    void render() const override;
    void onClick() override;
    // ...
};

class Checkbox : public AbstractButton {
// ...
};
</code></pre></div>
<h5 id="example-bad_28">Example, bad<a class="headerlink" href="#example-bad_28" title="Permanent link">&para;</a></h5>
<p>Do <em>not</em> represent non-hierarchical domain concepts as class hierarchies.</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
class Container {
public:
    // list operations:
    virtual T&amp; get() = 0;
    virtual void put(T&amp;) = 0;
    virtual void insert(Position) = 0;
    // ...
    // vector operations:
    virtual T&amp; operator[](int) = 0;
    virtual void sort() = 0;
    // ...
    // tree operations:
    virtual void balance() = 0;
    // ...
};
</code></pre></div>
<p>Here most overriding classes cannot implement most of the functions required in the interface well.
Thus the base class becomes an implementation burden.
Furthermore, the user of <code>Container</code> cannot rely on the member functions actually performing meaningful operations reasonably efficiently;
it might throw an exception instead.
Thus users have to resort to run-time checking and/or
not using this (over)general interface in favor of a particular interface found by a run-time type inquiry (e.g., a <code>dynamic_cast</code>).</p>
<h5 id="enforcement_56">Enforcement<a class="headerlink" href="#enforcement_56" title="Permanent link">&para;</a></h5>
<ul>
<li>Look for classes with lots of members that do nothing but throw.</li>
<li>Flag every use of a non-public base class <code>B</code> where the derived class <code>D</code> does not override a virtual function or access a protected member in <code>B</code>, and <code>B</code> is not one of the following: empty, a template parameter or parameter pack of <code>D</code>, a class template specialized with <code>D</code>.</li>
</ul>
<h3 id="c121-if-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class"><a name="Rh-abstract"></a>C.121: If a base class is used as an interface, make it a pure abstract class<a class="headerlink" href="#c121-if-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class" title="Permanent link">&para;</a></h3>
<h5 id="reason_59">Reason<a class="headerlink" href="#reason_59" title="Permanent link">&para;</a></h5>
<p>A class is more stable (less brittle) if it does not contain data.
Interfaces should normally be composed entirely of public pure virtual functions and a default/empty virtual destructor.</p>
<h5 id="example_46">Example<a class="headerlink" href="#example_46" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class My_interface {
public:
    // ...only pure virtual functions here ...
    virtual ~My_interface() {}   // or =default
};
</code></pre></div>
<h5 id="example-bad_29">Example, bad<a class="headerlink" href="#example-bad_29" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Goof {
public:
    // ...only pure virtual functions here ...
    // no virtual destructor
};

class Derived : public Goof {
    string s;
    // ...
};

void use()
{
    unique_ptr&lt;Goof&gt; p {new Derived{&quot;here we go&quot;}};
    f(p.get()); // use Derived through the Goof interface
    g(p.get()); // use Derived through the Goof interface
} // leak
</code></pre></div>
<p>The <code>Derived</code> is <code>delete</code>d through its <code>Goof</code> interface, so its <code>string</code> is leaked.
Give <code>Goof</code> a virtual destructor and all is well.</p>
<h5 id="enforcement_57">Enforcement<a class="headerlink" href="#enforcement_57" title="Permanent link">&para;</a></h5>
<ul>
<li>Warn on any class that contains data members and also has an overridable (non-<code>final</code>) virtual function that wasn't inherited from a base class.</li>
</ul>
<h3 id="c122-use-abstract-classes-as-interfaces-when-complete-separation-of-interface-and-implementation-is-needed"><a name="Rh-separation"></a>C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed<a class="headerlink" href="#c122-use-abstract-classes-as-interfaces-when-complete-separation-of-interface-and-implementation-is-needed" title="Permanent link">&para;</a></h3>
<h5 id="reason_60">Reason<a class="headerlink" href="#reason_60" title="Permanent link">&para;</a></h5>
<p>Such as on an ABI (link) boundary.</p>
<h5 id="example_47">Example<a class="headerlink" href="#example_47" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Device {
    virtual ~Device() = default;
    virtual void write(span&lt;const char&gt; outbuf) = 0;
    virtual void read(span&lt;char&gt; inbuf) = 0;
};

class D1 : public Device {
    // ... data ...

    void write(span&lt;const char&gt; outbuf) override;
    void read(span&lt;char&gt; inbuf) override;
};

class D2 : public Device {
    // ... different data ...

    void write(span&lt;const char&gt; outbuf) override;
    void read(span&lt;char&gt; inbuf) override;
};
</code></pre></div>
<p>A user can now use <code>D1</code>s and <code>D2</code>s interchangeably through the interface provided by <code>Device</code>.
Furthermore, we can update <code>D1</code> and <code>D2</code> in ways that are not binary compatible with older versions as long as all access goes through <code>Device</code>.</p>
<h5 id="enforcement_58">Enforcement<a class="headerlink" href="#enforcement_58" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>???
</code></pre></div>
<h2 id="chierclass-designing-classes-in-a-hierarchy">C.hierclass: Designing classes in a hierarchy:<a class="headerlink" href="#chierclass-designing-classes-in-a-hierarchy" title="Permanent link">&para;</a></h2>
<h3 id="c126-an-abstract-class-typically-doesnt-need-a-user-written-constructor"><a name="Rh-abstract-ctor"></a>C.126: An abstract class typically doesn't need a user-written constructor<a class="headerlink" href="#c126-an-abstract-class-typically-doesnt-need-a-user-written-constructor" title="Permanent link">&para;</a></h3>
<h5 id="reason_61">Reason<a class="headerlink" href="#reason_61" title="Permanent link">&para;</a></h5>
<p>An abstract class typically does not have any data for a constructor to initialize.</p>
<h5 id="example_48">Example<a class="headerlink" href="#example_48" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Shape {
public:
    // no user-written constructor needed in abstract base class
    virtual Point center() const = 0;    // pure virtual
    virtual void move(Point to) = 0;
    // ... more pure virtual functions...
    virtual ~Shape() {}                 // destructor
};

class Circle : public Shape {
public:
    Circle(Point p, int rad);           // constructor in derived class
    Point center() const override { return x; }
};
</code></pre></div>
<h5 id="exception_9">Exception<a class="headerlink" href="#exception_9" title="Permanent link">&para;</a></h5>
<ul>
<li>A base class constructor that does work, such as registering an object somewhere, might need a constructor.</li>
<li>In extremely rare cases, you might find it reasonable for an abstract class to have a bit of data shared by all derived classes
  (e.g., use statistics data, debug information, etc.); such classes tend to have constructors. But be warned: Such classes also tend to be prone to requiring virtual inheritance.</li>
</ul>
<h5 id="enforcement_59">Enforcement<a class="headerlink" href="#enforcement_59" title="Permanent link">&para;</a></h5>
<p>Flag abstract classes with constructors.</p>
<h3 id="c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor"><a name="Rh-dtor"></a>C.127: A class with a virtual function should have a virtual or protected destructor<a class="headerlink" href="#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor" title="Permanent link">&para;</a></h3>
<h5 id="reason_62">Reason<a class="headerlink" href="#reason_62" title="Permanent link">&para;</a></h5>
<p>A class with a virtual function is usually (and in general) used via a pointer to base. Usually, the last user has to call delete on a pointer to base, often via a smart pointer to base, so the destructor should be public and virtual. Less commonly, if deletion through a pointer to base is not intended to be supported, the destructor should be protected and non-virtual; see <a href="#Rc-dtor-virtual">C.35</a>.</p>
<h5 id="example-bad_30">Example, bad<a class="headerlink" href="#example-bad_30" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct B {
    virtual int f() = 0;
    // ... no user-written destructor, defaults to public non-virtual ...
};

// bad: derived from a class without a virtual destructor
struct D : B {
    string s {&quot;default&quot;};
    // ...
};

void use()
{
    unique_ptr&lt;B&gt; p = make_unique&lt;D&gt;();
    // ...
} // undefined behavior, might call B::~B only and leak the string
</code></pre></div>
<h5 id="note_61">Note<a class="headerlink" href="#note_61" title="Permanent link">&para;</a></h5>
<p>There are people who don't follow this rule because they plan to use a class only through a <code>shared_ptr</code>: <code>std::shared_ptr&lt;B&gt; p = std::make_shared&lt;D&gt;(args);</code> Here, the shared pointer will take care of deletion, so no leak will occur from an inappropriate <code>delete</code> of the base. People who do this consistently can get a false positive, but the rule is important -- what if one was allocated using <code>make_unique</code>? It's not safe unless the author of <code>B</code> ensures that it can never be misused, such as by making all constructors private and providing a factory function to enforce the allocation with <code>make_shared</code>.</p>
<h5 id="enforcement_60">Enforcement<a class="headerlink" href="#enforcement_60" title="Permanent link">&para;</a></h5>
<ul>
<li>A class with any virtual functions should have a destructor that is either public and virtual or else protected and non-virtual.</li>
<li>Flag <code>delete</code> of a class with a virtual function but no virtual destructor.</li>
</ul>
<h3 id="c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final"><a name="Rh-override"></a>C.128: Virtual functions should specify exactly one of <code>virtual</code>, <code>override</code>, or <code>final</code><a class="headerlink" href="#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final" title="Permanent link">&para;</a></h3>
<h5 id="reason_63">Reason<a class="headerlink" href="#reason_63" title="Permanent link">&para;</a></h5>
<p>Readability.
Detection of mistakes.
Writing explicit <code>virtual</code>, <code>override</code>, or <code>final</code> is self-documenting and enables the compiler to catch mismatch of types and/or names between base and derived classes. However, writing more than one of these three is both redundant and a potential source of errors.</p>
<p>It's simple and clear:</p>
<ul>
<li><code>virtual</code> means exactly and only "this is a new virtual function."</li>
<li><code>override</code> means exactly and only "this is a non-final overrider."</li>
<li><code>final</code> means exactly and only "this is a final overrider."</li>
</ul>
<h5 id="example-bad_31">Example, bad<a class="headerlink" href="#example-bad_31" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct B {
    void f1(int);
    virtual void f2(int) const;
    virtual void f3(int);
    // ...
};

struct D : B {
    void f1(int);        // bad (hope for a warning): D::f1() hides B::f1()
    void f2(int) const;  // bad (but conventional and valid): no explicit override
    void f3(double);     // bad (hope for a warning): D::f3() hides B::f3()
    // ...
};
</code></pre></div>
<h5 id="example-good_5">Example, good<a class="headerlink" href="#example-good_5" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Better : B {
    void f1(int) override;        // error (caught): Better::f1() hides B::f1()
    void f2(int) const override;
    void f3(double) override;     // error (caught): Better::f3() hides B::f3()
    // ...
};
</code></pre></div>
<h4 id="discussion_1">Discussion<a class="headerlink" href="#discussion_1" title="Permanent link">&para;</a></h4>
<p>We want to eliminate two particular classes of errors:</p>
<ul>
<li><strong>implicit virtual</strong>: the programmer intended the function to be implicitly virtual and it is (but readers of the code can't tell); or the programmer intended the function to be implicitly virtual but it isn't (e.g., because of a subtle parameter list mismatch); or the programmer did not intend the function to be virtual but it is (because it happens to have the same signature as a virtual in the base class)</li>
<li><strong>implicit override</strong>: the programmer intended the function to be implicitly an overrider and it is (but readers of the code can't tell); or the programmer intended the function to be implicitly an overrider but it isn't (e.g., because of a subtle parameter list mismatch); or the programmer did not intend the function to be an overrider but it is (because it happens to have the same signature as a virtual in the base class -- note this problem arises whether or not the function is explicitly declared virtual, because the programmer might have intended to create either a new virtual function or a new non-virtual function)</li>
</ul>
<p>Note: On a class defined as <code>final</code>, it doesn't matter whether you put <code>override</code> or <code>final</code> on an individual virtual function.</p>
<p>Note: Use <code>final</code> on functions sparingly. It does not necessarily lead to optimization, and it precludes further overriding.</p>
<h5 id="enforcement_61">Enforcement<a class="headerlink" href="#enforcement_61" title="Permanent link">&para;</a></h5>
<ul>
<li>Compare virtual function names in base and derived classes and flag uses of the same name that does not override.</li>
<li>Flag overrides with neither <code>override</code> nor <code>final</code>.</li>
<li>Flag function declarations that use more than one of <code>virtual</code>, <code>override</code>, and <code>final</code>.</li>
</ul>
<h3 id="c129-when-designing-a-class-hierarchy-distinguish-between-implementation-inheritance-and-interface-inheritance"><a name="Rh-kind"></a>C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance<a class="headerlink" href="#c129-when-designing-a-class-hierarchy-distinguish-between-implementation-inheritance-and-interface-inheritance" title="Permanent link">&para;</a></h3>
<h5 id="reason_64">Reason<a class="headerlink" href="#reason_64" title="Permanent link">&para;</a></h5>
<p>Implementation details in an interface make the interface brittle;
that is, make its users vulnerable to having to recompile after changes in the implementation.
Data in a base class increases the complexity of implementing the base and can lead to replication of code.</p>
<h5 id="note_62">Note<a class="headerlink" href="#note_62" title="Permanent link">&para;</a></h5>
<p>Definition:</p>
<ul>
<li>interface inheritance is the use of inheritance to separate users from implementations,
in particular to allow derived classes to be added and changed without affecting the users of base classes.</li>
<li>implementation inheritance is the use of inheritance to simplify implementation of new facilities
by making useful operations available for implementers of related new operations (sometimes called "programming by difference").</li>
</ul>
<p>A pure interface class is simply a set of pure virtual functions; see <a href="#Ri-abstract">I.25</a>.</p>
<p>In early OOP (e.g., in the 1980s and 1990s), implementation inheritance and interface inheritance were often mixed
and bad habits die hard.
Even now, mixtures are not uncommon in old code bases and in old-style teaching material.</p>
<p>The importance of keeping the two kinds of inheritance increases</p>
<ul>
<li>with the size of a hierarchy (e.g., dozens of derived classes),</li>
<li>with the length of time the hierarchy is used (e.g., decades), and</li>
<li>with the number of distinct organizations in which a hierarchy is used
(e.g., it can be difficult to distribute an update to a base class)</li>
</ul>
<h5 id="example-bad_32">Example, bad<a class="headerlink" href="#example-bad_32" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Shape {   // BAD, mixed interface and implementation
public:
    Shape();
    Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}

    Point center() const { return cent; }
    Color color() const { return col; }

    virtual void rotate(int) = 0;
    virtual void move(Point p) { cent = p; redraw(); }

    virtual void redraw();

    // ...
private:
    Point cent;
    Color col;
};

class Circle : public Shape {
public:
    Circle(Point c, int r) : Shape{c}, rad{r} { /* ... */ }

    // ...
private:
    int rad;
};

class Triangle : public Shape {
public:
    Triangle(Point p1, Point p2, Point p3); // calculate center
    // ...
};
</code></pre></div>
<p>Problems:</p>
<ul>
<li>As the hierarchy grows and more data is added to <code>Shape</code>, the constructors get harder to write and maintain.</li>
<li>Why calculate the center for the <code>Triangle</code>? we might never use it.</li>
<li>Add a data member to <code>Shape</code> (e.g., drawing style or canvas)
and all classes derived from <code>Shape</code> and all code using <code>Shape</code> will need to be reviewed, possibly changed, and probably recompiled.</li>
</ul>
<p>The implementation of <code>Shape::move()</code> is an example of implementation inheritance:
we have defined <code>move()</code> once and for all, for all derived classes.
The more code there is in such base class member function implementations and the more data is shared by placing it in the base,
the more benefits we gain - and the less stable the hierarchy is.</p>
<h5 id="example_49">Example<a class="headerlink" href="#example_49" title="Permanent link">&para;</a></h5>
<p>This Shape hierarchy can be rewritten using interface inheritance:</p>
<div class="language-text highlight"><pre><span></span><code>class Shape {  // pure interface
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
};
</code></pre></div>
<p>Note that a pure interface rarely has constructors: there is nothing to construct.</p>
<div class="language-text highlight"><pre><span></span><code>class Circle : public Shape {
public:
    Circle(Point c, int r, Color c) : cent{c}, rad{r}, col{c} { /* ... */ }

    Point center() const override { return cent; }
    Color color() const override { return col; }

    // ...
private:
    Point cent;
    int rad;
    Color col;
};
</code></pre></div>
<p>The interface is now less brittle, but there is more work in implementing the member functions.
For example, <code>center</code> has to be implemented by every class derived from <code>Shape</code>.</p>
<h5 id="example-dual-hierarchy">Example, dual hierarchy<a class="headerlink" href="#example-dual-hierarchy" title="Permanent link">&para;</a></h5>
<p>How can we gain the benefit of stable hierarchies from interface hierarchies and the benefit of implementation reuse from implementation inheritance?
One popular technique is dual hierarchies.
There are many ways of implementing the idea of dual hierarchies; here, we use a multiple-inheritance variant.</p>
<p>First we devise a hierarchy of interface classes:</p>
<div class="language-text highlight"><pre><span></span><code>class Shape {   // pure interface
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
};

class Circle : public virtual Shape {   // pure interface
public:
    virtual int radius() = 0;
    // ...
};
</code></pre></div>
<p>To make this interface useful, we must provide its implementation classes (here, named equivalently, but in the <code>Impl</code> namespace):</p>
<div class="language-text highlight"><pre><span></span><code>class Impl::Shape : public virtual ::Shape { // implementation
public:
    // constructors, destructor
    // ...
    Point center() const override { /* ... */ }
    Color color() const override { /* ... */ }

    void rotate(int) override { /* ... */ }
    void move(Point p) override { /* ... */ }

    void redraw() override { /* ... */ }

    // ...
};
</code></pre></div>
<p>Now <code>Shape</code> is a poor example of a class with an implementation,
but bear with us because this is just a simple example of a technique aimed at more complex hierarchies.</p>
<div class="language-text highlight"><pre><span></span><code>class Impl::Circle : public virtual ::Circle, public Impl::Shape {   // implementation
public:
    // constructors, destructor

    int radius() override { /* ... */ }
    // ...
};
</code></pre></div>
<p>And we could extend the hierarchies by adding a Smiley class (:-)):</p>
<div class="language-text highlight"><pre><span></span><code>class Smiley : public virtual Circle { // pure interface
public:
    // ...
};

class Impl::Smiley : public virtual ::Smiley, public Impl::Circle {   // implementation
public:
    // constructors, destructor
    // ...
}
</code></pre></div>
<p>There are now two hierarchies:</p>
<ul>
<li>interface: Smiley -&gt; Circle -&gt; Shape</li>
<li>implementation: Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape</li>
</ul>
<p>Since each implementation is derived from its interface as well as its implementation base class we get a lattice (DAG):</p>
<div class="language-text highlight"><pre><span></span><code>Smiley     -&gt;         Circle     -&gt;  Shape
  ^                     ^               ^
  |                     |               |
Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape
</code></pre></div>
<p>As mentioned, this is just one way to construct a dual hierarchy.</p>
<p>The implementation hierarchy can be used directly, rather than through the abstract interface.</p>
<div class="language-text highlight"><pre><span></span><code>void work_with_shape(Shape&amp;);

int user()
{
    Impl::Smiley my_smiley{ /* args */ };   // create concrete shape
    // ...
    my_smiley.some_member();        // use implementation class directly
    // ...
    work_with_shape(my_smiley);     // use implementation through abstract interface
    // ...
}
</code></pre></div>
<p>This can be useful when the implementation class has members that are not offered in the abstract interface
or if direct use of a member offers optimization opportunities (e.g., if an implementation member function is <code>final</code>)</p>
<h5 id="note_63">Note<a class="headerlink" href="#note_63" title="Permanent link">&para;</a></h5>
<p>Another (related) technique for separating interface and implementation is <a href="#Ri-pimpl">Pimpl</a>.</p>
<h5 id="note_64">Note<a class="headerlink" href="#note_64" title="Permanent link">&para;</a></h5>
<p>There is often a choice between offering common functionality as (implemented) base class functions and freestanding functions
(in an implementation namespace).
Base classes give a shorter notation and easier access to shared data (in the base)
at the cost of the functionality being available only to users of the hierarchy.</p>
<h5 id="enforcement_62">Enforcement<a class="headerlink" href="#enforcement_62" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag a derived to base conversion to a base with both data and virtual functions
(except for calls from a derived class member to a base class member)</li>
<li>???</li>
</ul>
<h3 id="c130-for-making-deep-copies-of-polymorphic-classes-prefer-a-virtual-clone-function-instead-of-public-copy-constructionassignment"><a name="Rh-copy"></a>C.130: For making deep copies of polymorphic classes prefer a virtual <code>clone</code> function instead of public copy construction/assignment<a class="headerlink" href="#c130-for-making-deep-copies-of-polymorphic-classes-prefer-a-virtual-clone-function-instead-of-public-copy-constructionassignment" title="Permanent link">&para;</a></h3>
<h5 id="reason_65">Reason<a class="headerlink" href="#reason_65" title="Permanent link">&para;</a></h5>
<p>Copying a polymorphic class is discouraged due to the slicing problem, see <a href="#Rc-copy-virtual">C.67</a>. If you really need copy semantics, copy deeply: Provide a virtual <code>clone</code> function that will copy the actual most-derived type and return an owning pointer to the new object, and then in derived classes return the derived type (use a covariant return type).</p>
<h5 id="example_50">Example<a class="headerlink" href="#example_50" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class B {
public:
    B() = default;
    virtual ~B() = default;
    virtual gsl::owner&lt;B*&gt; clone() const = 0;
protected:
     B(const B&amp;) = default;
     B&amp; operator=(const B&amp;) = default;
     B(B&amp;&amp;) noexcept = default;
     B&amp; operator=(B&amp;&amp;) noexcept = default;
    // ...
};

class D : public B {
public:
    gsl::owner&lt;D*&gt; clone() const override
    {
        return new D{*this};
    };
};
</code></pre></div>
<p>Generally, it is recommended to use smart pointers to represent ownership (see <a href="#Rr-owner">R.20</a>). However, because of language rules, the covariant return type cannot be a smart pointer: <code>D::clone</code> can't return a <code>unique_ptr&lt;D&gt;</code> while <code>B::clone</code> returns <code>unique_ptr&lt;B&gt;</code>. Therefore, you either need to consistently return <code>unique_ptr&lt;B&gt;</code> in all overrides, or use <code>owner&lt;&gt;</code> utility from the <a href="#SS-views">Guidelines Support Library</a>.</p>
<h3 id="c131-avoid-trivial-getters-and-setters"><a name="Rh-get"></a>C.131: Avoid trivial getters and setters<a class="headerlink" href="#c131-avoid-trivial-getters-and-setters" title="Permanent link">&para;</a></h3>
<h5 id="reason_66">Reason<a class="headerlink" href="#reason_66" title="Permanent link">&para;</a></h5>
<p>A trivial getter or setter adds no semantic value; the data item could just as well be <code>public</code>.</p>
<h5 id="example_51">Example<a class="headerlink" href="#example_51" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Point {   // Bad: verbose
    int x;
    int y;
public:
    Point(int xx, int yy) : x{xx}, y{yy} { }
    int get_x() const { return x; }
    void set_x(int xx) { x = xx; }
    int get_y() const { return y; }
    void set_y(int yy) { y = yy; }
    // no behavioral member functions
};
</code></pre></div>
<p>Consider making such a class a <code>struct</code> -- that is, a behaviorless bunch of variables, all public data and no member functions.</p>
<div class="language-text highlight"><pre><span></span><code>struct Point {
    int x {0};
    int y {0};
};
</code></pre></div>
<p>Note that we can put default initializers on data members: <a href="#Rc-initialize">C.49: Prefer initialization to assignment in constructors</a>.</p>
<h5 id="note_65">Note<a class="headerlink" href="#note_65" title="Permanent link">&para;</a></h5>
<p>The key to this rule is whether the semantics of the getter/setter are trivial. While it is not a complete definition of "trivial", consider whether there would be any difference beyond syntax if the getter/setter was a public data member instead. Examples of non-trivial semantics would be: maintaining a class invariant or converting between an internal type and an interface type.</p>
<h5 id="enforcement_63">Enforcement<a class="headerlink" href="#enforcement_63" title="Permanent link">&para;</a></h5>
<p>Flag multiple <code>get</code> and <code>set</code> member functions that simply access a member without additional semantics.</p>
<h3 id="c132-dont-make-a-function-virtual-without-reason"><a name="Rh-virtual"></a>C.132: Don't make a function <code>virtual</code> without reason<a class="headerlink" href="#c132-dont-make-a-function-virtual-without-reason" title="Permanent link">&para;</a></h3>
<h5 id="reason_67">Reason<a class="headerlink" href="#reason_67" title="Permanent link">&para;</a></h5>
<p>Redundant <code>virtual</code> increases run-time and object-code size.
A virtual function can be overridden and is thus open to mistakes in a derived class.
A virtual function ensures code replication in a templated hierarchy.</p>
<h5 id="example-bad_33">Example, bad<a class="headerlink" href="#example-bad_33" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;class T&gt;
class Vector {
public:
    // ...
    virtual int size() const { return sz; }   // bad: what good could a derived class do?
private:
    T* elem;   // the elements
    int sz;    // number of elements
};
</code></pre></div>
<p>This kind of "vector" isn't meant to be used as a base class at all.</p>
<h5 id="enforcement_64">Enforcement<a class="headerlink" href="#enforcement_64" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag a class with virtual functions but no derived classes.</li>
<li>Flag a class where all member functions are virtual and have implementations.</li>
</ul>
<h3 id="c133-avoid-protected-data"><a name="Rh-protected"></a>C.133: Avoid <code>protected</code> data<a class="headerlink" href="#c133-avoid-protected-data" title="Permanent link">&para;</a></h3>
<h5 id="reason_68">Reason<a class="headerlink" href="#reason_68" title="Permanent link">&para;</a></h5>
<p><code>protected</code> data is a source of complexity and errors.
<code>protected</code> data complicates the statement of invariants.
<code>protected</code> data inherently violates the guidance against putting data in base classes, which usually leads to having to deal with virtual inheritance as well.</p>
<h5 id="example-bad_34">Example, bad<a class="headerlink" href="#example-bad_34" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Shape {
public:
    // ... interface functions ...
protected:
    // data for use in derived classes:
    Color fill_color;
    Color edge_color;
    Style st;
};
</code></pre></div>
<p>Now it is up to every derived <code>Shape</code> to manipulate the protected data correctly.
This has been popular, but also a major source of maintenance problems.
In a large class hierarchy, the consistent use of protected data is hard to maintain because there can be a lot of code,
spread over a lot of classes.
The set of classes that can touch that data is open: anyone can derive a new class and start manipulating the protected data.
Often, it is not possible to examine the complete set of classes, so any change to the representation of the class becomes infeasible.
There is no enforced invariant for the protected data; it is much like a set of global variables.
The protected data has de facto become global to a large body of code.</p>
<h5 id="note_66">Note<a class="headerlink" href="#note_66" title="Permanent link">&para;</a></h5>
<p>Protected data often looks tempting to enable arbitrary improvements through derivation.
Often, what you get is unprincipled changes and errors.
<a href="#Rc-private">Prefer <code>private</code> data</a> with a well-specified and enforced invariant.
Alternative, and often better, <a href="#Rh-abstract">keep data out of any class used as an interface</a>.</p>
<h5 id="note_67">Note<a class="headerlink" href="#note_67" title="Permanent link">&para;</a></h5>
<p>Protected member function can be just fine.</p>
<h5 id="enforcement_65">Enforcement<a class="headerlink" href="#enforcement_65" title="Permanent link">&para;</a></h5>
<p>Flag classes with <code>protected</code> data.</p>
<h3 id="c134-ensure-all-non-const-data-members-have-the-same-access-level"><a name="Rh-public"></a>C.134: Ensure all non-<code>const</code> data members have the same access level<a class="headerlink" href="#c134-ensure-all-non-const-data-members-have-the-same-access-level" title="Permanent link">&para;</a></h3>
<h5 id="reason_69">Reason<a class="headerlink" href="#reason_69" title="Permanent link">&para;</a></h5>
<p>Prevention of logical confusion leading to errors.
If the non-<code>const</code> data members don't have the same access level, the type is confused about what it's trying to do.
Is it a type that maintains an invariant or simply a collection of values?</p>
<h5 id="discussion_2">Discussion<a class="headerlink" href="#discussion_2" title="Permanent link">&para;</a></h5>
<p>The core question is: What code is responsible for maintaining a meaningful/correct value for that variable?</p>
<p>There are exactly two kinds of data members:</p>
<ul>
<li>A: Ones that don't participate in the object's invariant. Any combination of values for these members is valid.</li>
<li>B: Ones that do participate in the object's invariant. Not every combination of values is meaningful (else there'd be no invariant). Therefore all code that has write access to these variables must know about the invariant, know the semantics, and know (and actively implement and enforce) the rules for keeping the values correct.</li>
</ul>
<p>Data members in category A should just be <code>public</code> (or, more rarely, <code>protected</code> if you only want derived classes to see them). They don't need encapsulation. All code in the system might as well see and manipulate them.</p>
<p>Data members in category B should be <code>private</code> or <code>const</code>. This is because encapsulation is important. To make them non-<code>private</code> and non-<code>const</code> would mean that the object can't control its own state: An unbounded amount of code beyond the class would need to know about the invariant and participate in maintaining it accurately -- if these data members were <code>public</code>, that would be all calling code that uses the object; if they were <code>protected</code>, it would be all the code in current and future derived classes. This leads to brittle and tightly coupled code that quickly becomes a nightmare to maintain. Any code that inadvertently sets the data members to an invalid or unexpected combination of values would corrupt the object and all subsequent uses of the object.</p>
<p>Most classes are either all A or all B:</p>
<ul>
<li><em>All public</em>: If you're writing an aggregate bundle-of-variables without an invariant across those variables, then all the variables should be <code>public</code>.
  <a href="#Rc-struct">By convention, declare such classes <code>struct</code> rather than <code>class</code></a></li>
<li><em>All private</em>: If you're writing a type that maintains an invariant, then all the non-<code>const</code> variables should be private -- it should be encapsulated.</li>
</ul>
<h5 id="exception_10">Exception<a class="headerlink" href="#exception_10" title="Permanent link">&para;</a></h5>
<p>Occasionally classes will mix A and B, usually for debug reasons. An encapsulated object might contain something like non-<code>const</code> debug instrumentation that isn't part of the invariant and so falls into category A -- it isn't really part of the object's value or meaningful observable state either. In that case, the A parts should be treated as A's (made <code>public</code>, or in rarer cases <code>protected</code> if they should be visible only to derived classes) and the B parts should still be treated like B's (<code>private</code> or <code>const</code>).</p>
<h5 id="enforcement_66">Enforcement<a class="headerlink" href="#enforcement_66" title="Permanent link">&para;</a></h5>
<p>Flag any class that has non-<code>const</code> data members with different access levels.</p>
<h3 id="c135-use-multiple-inheritance-to-represent-multiple-distinct-interfaces"><a name="Rh-mi-interface"></a>C.135: Use multiple inheritance to represent multiple distinct interfaces<a class="headerlink" href="#c135-use-multiple-inheritance-to-represent-multiple-distinct-interfaces" title="Permanent link">&para;</a></h3>
<h5 id="reason_70">Reason<a class="headerlink" href="#reason_70" title="Permanent link">&para;</a></h5>
<p>Not all classes will necessarily support all interfaces, and not all callers will necessarily want to deal with all operations.
Especially to break apart monolithic interfaces into "aspects" of behavior supported by a given derived class.</p>
<h5 id="example_52">Example<a class="headerlink" href="#example_52" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class iostream : public istream, public ostream {   // very simplified
    // ...
};
</code></pre></div>
<p><code>istream</code> provides the interface to input operations; <code>ostream</code> provides the interface to output operations.
<code>iostream</code> provides the union of the <code>istream</code> and <code>ostream</code> interfaces and the synchronization needed to allow both on a single stream.</p>
<h5 id="note_68">Note<a class="headerlink" href="#note_68" title="Permanent link">&para;</a></h5>
<p>This is a very common use of inheritance because the need for multiple different interfaces to an implementation is common
and such interfaces are often not easily or naturally organized into a single-rooted hierarchy.</p>
<h5 id="note_69">Note<a class="headerlink" href="#note_69" title="Permanent link">&para;</a></h5>
<p>Such interfaces are typically abstract classes.</p>
<h5 id="enforcement_67">Enforcement<a class="headerlink" href="#enforcement_67" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c136-use-multiple-inheritance-to-represent-the-union-of-implementation-attributes"><a name="Rh-mi-implementation"></a>C.136: Use multiple inheritance to represent the union of implementation attributes<a class="headerlink" href="#c136-use-multiple-inheritance-to-represent-the-union-of-implementation-attributes" title="Permanent link">&para;</a></h3>
<h5 id="reason_71">Reason<a class="headerlink" href="#reason_71" title="Permanent link">&para;</a></h5>
<p>Some forms of mixins have state and often operations on that state.
If the operations are virtual the use of inheritance is necessary, if not using inheritance can avoid boilerplate and forwarding.</p>
<h5 id="example_53">Example<a class="headerlink" href="#example_53" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class iostream : public istream, public ostream {   // very simplified
    // ...
};
</code></pre></div>
<p><code>istream</code> provides the interface to input operations (and some data); <code>ostream</code> provides the interface to output operations (and some data).
<code>iostream</code> provides the union of the <code>istream</code> and <code>ostream</code> interfaces and the synchronization needed to allow both on a single stream.</p>
<h5 id="note_70">Note<a class="headerlink" href="#note_70" title="Permanent link">&para;</a></h5>
<p>This a relatively rare use because implementation can often be organized into a single-rooted hierarchy.</p>
<h5 id="example_54">Example<a class="headerlink" href="#example_54" title="Permanent link">&para;</a></h5>
<p>Sometimes, an "implementation attribute" is more like a "mixin" that determine the behavior of an implementation and inject
members to enable the implementation of the policies it requires.
For example, see <code>std::enable_shared_from_this</code>
or various bases from boost.intrusive (e.g. <code>list_base_hook</code> or <code>intrusive_ref_counter</code>).</p>
<h5 id="enforcement_68">Enforcement<a class="headerlink" href="#enforcement_68" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c137-use-virtual-bases-to-avoid-overly-general-base-classes"><a name="Rh-vbase"></a>C.137: Use <code>virtual</code> bases to avoid overly general base classes<a class="headerlink" href="#c137-use-virtual-bases-to-avoid-overly-general-base-classes" title="Permanent link">&para;</a></h3>
<h5 id="reason_72">Reason<a class="headerlink" href="#reason_72" title="Permanent link">&para;</a></h5>
<p>Allow separation of shared data and interface.
 To avoid all shared data to being put into an ultimate base class.</p>
<h5 id="example_55">Example<a class="headerlink" href="#example_55" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct Interface {
    virtual void f();
    virtual int g();
    // ... no data here ...
};

class Utility {  // with data
    void utility1();
    virtual void utility2();    // customization point
public:
    int x;
    int y;
};

class Derive1 : public Interface, virtual protected Utility {
    // override Interface functions
    // Maybe override Utility virtual functions
    // ...
};

class Derive2 : public Interface, virtual protected Utility {
    // override Interface functions
    // Maybe override Utility virtual functions
    // ...
};
</code></pre></div>
<p>Factoring out <code>Utility</code> makes sense if many derived classes share significant "implementation details."</p>
<h5 id="note_71">Note<a class="headerlink" href="#note_71" title="Permanent link">&para;</a></h5>
<p>Obviously, the example is too "theoretical", but it is hard to find a <em>small</em> realistic example.
<code>Interface</code> is the root of an <a href="#Rh-abstract">interface hierarchy</a>
and <code>Utility</code> is the root of an <a href="#Rh-kind">implementation hierarchy</a>.
Here is <a href="https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck">a slightly more realistic example</a> with an explanation.</p>
<h5 id="note_72">Note<a class="headerlink" href="#note_72" title="Permanent link">&para;</a></h5>
<p>Often, linearization of a hierarchy is a better solution.</p>
<h5 id="enforcement_69">Enforcement<a class="headerlink" href="#enforcement_69" title="Permanent link">&para;</a></h5>
<p>Flag mixed interface and implementation hierarchies.</p>
<h3 id="c138-create-an-overload-set-for-a-derived-class-and-its-bases-with-using"><a name="Rh-using"></a>C.138: Create an overload set for a derived class and its bases with <code>using</code><a class="headerlink" href="#c138-create-an-overload-set-for-a-derived-class-and-its-bases-with-using" title="Permanent link">&para;</a></h3>
<h5 id="reason_73">Reason<a class="headerlink" href="#reason_73" title="Permanent link">&para;</a></h5>
<p>Without a using declaration, member functions in the derived class hide the entire inherited overload sets.</p>
<h5 id="example-bad_35">Example, bad<a class="headerlink" href="#example-bad_35" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>#include &lt;iostream&gt;
class B {
public:
    virtual int f(int i) { std::cout &lt;&lt; &quot;f(int): &quot;; return i; }
    virtual double f(double d) { std::cout &lt;&lt; &quot;f(double): &quot;; return d; }
    virtual ~B() = default;
};
class D: public B {
public:
    int f(int i) override { std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; }
};
int main()
{
    D d;
    std::cout &lt;&lt; d.f(2) &lt;&lt; &#39;\n&#39;;   // prints &quot;f(int): 3&quot;
    std::cout &lt;&lt; d.f(2.3) &lt;&lt; &#39;\n&#39;; // prints &quot;f(int): 3&quot;
}
</code></pre></div>
<h5 id="example-good_6">Example, good<a class="headerlink" href="#example-good_6" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class D: public B {
public:
    int f(int i) override { std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; }
    using B::f; // exposes f(double)
};
</code></pre></div>
<h5 id="note_73">Note<a class="headerlink" href="#note_73" title="Permanent link">&para;</a></h5>
<p>This issue affects both virtual and non-virtual member functions</p>
<p>For variadic bases, C++17 introduced a variadic form of the using-declaration,</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;class... Ts&gt;
struct Overloader : Ts... {
    using Ts::operator()...; // exposes operator() from every base
};
</code></pre></div>
<h5 id="enforcement_70">Enforcement<a class="headerlink" href="#enforcement_70" title="Permanent link">&para;</a></h5>
<p>Diagnose name hiding</p>
<h3 id="c139-use-final-on-classes-sparingly"><a name="Rh-final"></a>C.139: Use <code>final</code> on classes sparingly<a class="headerlink" href="#c139-use-final-on-classes-sparingly" title="Permanent link">&para;</a></h3>
<h5 id="reason_74">Reason<a class="headerlink" href="#reason_74" title="Permanent link">&para;</a></h5>
<p>Capping a hierarchy with <code>final</code> classes is rarely needed for logical reasons and can be damaging to the extensibility of a hierarchy.</p>
<h5 id="example-bad_36">Example, bad<a class="headerlink" href="#example-bad_36" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Widget { /* ... */ };

// nobody will ever want to improve My_widget (or so you thought)
class My_widget final : public Widget { /* ... */ };

class My_improved_widget : public My_widget { /* ... */ };  // error: can&#39;t do that
</code></pre></div>
<h5 id="note_74">Note<a class="headerlink" href="#note_74" title="Permanent link">&para;</a></h5>
<p>Not every class is meant to be a base class.
Most standard-library classes are examples of that (e.g., <code>std::vector</code> and <code>std::string</code> are not designed to be derived from).
This rule is about using <code>final</code> on classes with virtual functions meant to be interfaces for a class hierarchy.</p>
<h5 id="note_75">Note<a class="headerlink" href="#note_75" title="Permanent link">&para;</a></h5>
<p>Claims of performance improvements from <code>final</code> should be substantiated.
Too often, such claims are based on conjecture or experience with other languages.</p>
<p>There are examples where <code>final</code> can be important for both logical and performance reasons.
One example is a performance-critical AST hierarchy in a compiler or language analysis tool.
New derived classes are not added every year and only by library implementers.
However, misuses are (or at least have been) far more common.</p>
<h5 id="enforcement_71">Enforcement<a class="headerlink" href="#enforcement_71" title="Permanent link">&para;</a></h5>
<p>Flag uses of <code>final</code> on classes.</p>
<h3 id="c140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider"><a name="Rh-virtual-default-arg"></a>C.140: Do not provide different default arguments for a virtual function and an overrider<a class="headerlink" href="#c140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider" title="Permanent link">&para;</a></h3>
<h5 id="reason_75">Reason<a class="headerlink" href="#reason_75" title="Permanent link">&para;</a></h5>
<p>That can cause confusion: An overrider does not inherit default arguments.</p>
<h5 id="example-bad_37">Example, bad<a class="headerlink" href="#example-bad_37" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Base {
public:
    virtual int multiply(int value, int factor = 2) = 0;
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    int multiply(int value, int factor = 10) override;
};

Derived d;
Base&amp; b = d;

b.multiply(10);  // these two calls will call the same function but
d.multiply(10);  // with different arguments and so different results
</code></pre></div>
<h5 id="enforcement_72">Enforcement<a class="headerlink" href="#enforcement_72" title="Permanent link">&para;</a></h5>
<p>Flag default arguments on virtual functions if they differ between base and derived declarations.</p>
<h2 id="chier-access-accessing-objects-in-a-hierarchy">C.hier-access: Accessing objects in a hierarchy<a class="headerlink" href="#chier-access-accessing-objects-in-a-hierarchy" title="Permanent link">&para;</a></h2>
<h3 id="c145-access-polymorphic-objects-through-pointers-and-references"><a name="Rh-poly"></a>C.145: Access polymorphic objects through pointers and references<a class="headerlink" href="#c145-access-polymorphic-objects-through-pointers-and-references" title="Permanent link">&para;</a></h3>
<h5 id="reason_76">Reason<a class="headerlink" href="#reason_76" title="Permanent link">&para;</a></h5>
<p>If you have a class with a virtual function, you don't (in general) know which class provided the function to be used.</p>
<h5 id="example_56">Example<a class="headerlink" href="#example_56" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct B { int a; virtual int f(); virtual ~B() = default };
struct D : B { int b; int f() override; };

void use(B b)
{
    D d;
    B b2 = d;   // slice
    B b3 = b;
}

void use2()
{
    D d;
    use(d);   // slice
}
</code></pre></div>
<p>Both <code>d</code>s are sliced.</p>
<h5 id="exception_11">Exception<a class="headerlink" href="#exception_11" title="Permanent link">&para;</a></h5>
<p>You can safely access a named polymorphic object in the scope of its definition, just don't slice it.</p>
<div class="language-text highlight"><pre><span></span><code>void use3()
{
    D d;
    d.f();   // OK
}
</code></pre></div>
<h5 id="see-also">See also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h5>
<p><a href="#Rc-copy-virtual">A polymorphic class should suppress copying</a></p>
<h5 id="enforcement_73">Enforcement<a class="headerlink" href="#enforcement_73" title="Permanent link">&para;</a></h5>
<p>Flag all slicing.</p>
<h3 id="c146-use-dynamic_cast-where-class-hierarchy-navigation-is-unavoidable"><a name="Rh-dynamic_cast"></a>C.146: Use <code>dynamic_cast</code> where class hierarchy navigation is unavoidable<a class="headerlink" href="#c146-use-dynamic_cast-where-class-hierarchy-navigation-is-unavoidable" title="Permanent link">&para;</a></h3>
<h5 id="reason_77">Reason<a class="headerlink" href="#reason_77" title="Permanent link">&para;</a></h5>
<p><code>dynamic_cast</code> is checked at run time.</p>
<h5 id="example_57">Example<a class="headerlink" href="#example_57" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct B {   // an interface
    virtual void f();
    virtual void g();
    virtual ~B();
};

struct D : B {   // a wider interface
    void f() override;
    virtual void h();
};

void user(B* pb)
{
    if (D* pd = dynamic_cast&lt;D*&gt;(pb)) {
        // ... use D&#39;s interface ...
    }
    else {
        // ... make do with B&#39;s interface ...
    }
}
</code></pre></div>
<p>Use of the other casts can violate type safety and cause the program to access a variable that is actually of type <code>X</code> to be accessed as if it were of an unrelated type <code>Z</code>:</p>
<div class="language-text highlight"><pre><span></span><code>void user2(B* pb)   // bad
{
    D* pd = static_cast&lt;D*&gt;(pb);    // I know that pb really points to a D; trust me
    // ... use D&#39;s interface ...
}

void user3(B* pb)    // unsafe
{
    if (some_condition) {
        D* pd = static_cast&lt;D*&gt;(pb);   // I know that pb really points to a D; trust me
        // ... use D&#39;s interface ...
    }
    else {
        // ... make do with B&#39;s interface ...
    }
}

void f()
{
    B b;
    user(&amp;b);   // OK
    user2(&amp;b);  // bad error
    user3(&amp;b);  // OK *if* the programmer got the some_condition check right
}
</code></pre></div>
<h5 id="note_76">Note<a class="headerlink" href="#note_76" title="Permanent link">&para;</a></h5>
<p>Like other casts, <code>dynamic_cast</code> is overused.
<a href="#Rh-use-virtual">Prefer virtual functions to casting</a>.
Prefer <a href="#???">static polymorphism</a> to hierarchy navigation where it is possible (no run-time resolution necessary)
and reasonably convenient.</p>
<h5 id="note_77">Note<a class="headerlink" href="#note_77" title="Permanent link">&para;</a></h5>
<p>Some people use <code>dynamic_cast</code> where a <code>typeid</code> would have been more appropriate;
<code>dynamic_cast</code> is a general "is kind of" operation for discovering the best interface to an object,
whereas <code>typeid</code> is a "give me the exact type of this object" operation to discover the actual type of an object.
The latter is an inherently simpler operation that ought to be faster.
The latter (<code>typeid</code>) is easily hand-crafted if necessary (e.g., if working on a system where RTTI is -- for some reason -- prohibited),
the former (<code>dynamic_cast</code>) is far harder to implement correctly in general.</p>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>struct B {
    const char* name {&quot;B&quot;};
    // if pb1-&gt;id() == pb2-&gt;id() *pb1 is the same type as *pb2
    virtual const char* id() const { return name; }
    // ...
};

struct D : B {
    const char* name {&quot;D&quot;};
    const char* id() const override { return name; }
    // ...
};

void use()
{
    B* pb1 = new B;
    B* pb2 = new D;

    cout &lt;&lt; pb1-&gt;id(); // &quot;B&quot;
    cout &lt;&lt; pb2-&gt;id(); // &quot;D&quot;


    if (pb2-&gt;id() == &quot;D&quot;) {         // looks innocent
        D* pd = static_cast&lt;D*&gt;(pb2);
        // ...
    }
    // ...
}
</code></pre></div>
<p>The result of <code>pb2-&gt;id() == "D"</code> is actually implementation defined.
We added it to warn of the dangers of home-brew RTTI.
This code might work as expected for years, just to fail on a new machine, new compiler, or a new linker that does not unify character literals.</p>
<p>If you implement your own RTTI, be careful.</p>
<h5 id="exception_12">Exception<a class="headerlink" href="#exception_12" title="Permanent link">&para;</a></h5>
<p>If your implementation provided a really slow <code>dynamic_cast</code>, you might have to use a workaround.
However, all workarounds that cannot be statically resolved involve explicit casting (typically <code>static_cast</code>) and are error-prone.
You will basically be crafting your own special-purpose <code>dynamic_cast</code>.
So, first make sure that your <code>dynamic_cast</code> really is as slow as you think it is (there are a fair number of unsupported rumors about)
and that your use of <code>dynamic_cast</code> is really performance critical.</p>
<p>We are of the opinion that current implementations of <code>dynamic_cast</code> are unnecessarily slow.
For example, under suitable conditions, it is possible to perform a <code>dynamic_cast</code> in <a href="http://www.stroustrup.com/fast_dynamic_casting.pdf">fast constant time</a>.
However, compatibility makes changes difficult even if all agree that an effort to optimize is worthwhile.</p>
<p>In very rare cases, if you have measured that the <code>dynamic_cast</code> overhead is material, you have other means to statically guarantee that a downcast will succeed (e.g., you are using CRTP carefully), and there is no virtual inheritance involved, consider tactically resorting <code>static_cast</code> with a prominent comment and disclaimer summarizing this paragraph and that human attention is needed under maintenance because the type system can't verify correctness. Even so, in our experience such "I know what I'm doing" situations are still a known bug source.</p>
<h5 id="exception_13">Exception<a class="headerlink" href="#exception_13" title="Permanent link">&para;</a></h5>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename B&gt;
class Dx : B {
    // ...
};
</code></pre></div>
<h5 id="enforcement_74">Enforcement<a class="headerlink" href="#enforcement_74" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag all uses of <code>static_cast</code> for downcasts, including C-style casts that perform a <code>static_cast</code>.</li>
<li>This rule is part of the <a href="#Pro-type-downcast">type-safety profile</a>.</li>
</ul>
<h3 id="c147-use-dynamic_cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error"><a name="Rh-ref-cast"></a>C.147: Use <code>dynamic_cast</code> to a reference type when failure to find the required class is considered an error<a class="headerlink" href="#c147-use-dynamic_cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error" title="Permanent link">&para;</a></h3>
<h5 id="reason_78">Reason<a class="headerlink" href="#reason_78" title="Permanent link">&para;</a></h5>
<p>Casting to a reference expresses that you intend to end up with a valid object, so the cast must succeed. <code>dynamic_cast</code> will then throw if it does not succeed.</p>
<h5 id="example_58">Example<a class="headerlink" href="#example_58" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>std::string f(Base&amp; b)
{
    return dynamic_cast&lt;Derived&amp;&gt;(b).to_string();
}
</code></pre></div>
<h5 id="enforcement_75">Enforcement<a class="headerlink" href="#enforcement_75" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c148-use-dynamic_cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative"><a name="Rh-ptr-cast"></a>C.148: Use <code>dynamic_cast</code> to a pointer type when failure to find the required class is considered a valid alternative<a class="headerlink" href="#c148-use-dynamic_cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative" title="Permanent link">&para;</a></h3>
<h5 id="reason_79">Reason<a class="headerlink" href="#reason_79" title="Permanent link">&para;</a></h5>
<p>The <code>dynamic_cast</code> conversion allows to test whether a pointer is pointing at a polymorphic object that has a given class in its hierarchy. Since failure to find the class merely returns a null value, it can be tested during run time. This allows writing code that can choose alternative paths depending on the results.</p>
<p>Contrast with <a href="#Rh-ref-cast">C.147</a>, where failure is an error, and should not be used for conditional execution.</p>
<h5 id="example_59">Example<a class="headerlink" href="#example_59" title="Permanent link">&para;</a></h5>
<p>The example below describes the <code>add</code> function of a <code>Shape_owner</code> that takes ownership of constructed <code>Shape</code> objects. The objects are also sorted into views, according to their geometric attributes.
In this example, <code>Shape</code> does not inherit from <code>Geometric_attributes</code>. Only its subclasses do.</p>
<div class="language-text highlight"><pre><span></span><code>void add(Shape* const item)
{
  // Ownership is always taken
  owned_shapes.emplace_back(item);

  // Check the Geometric_attributes and add the shape to none/one/some/all of the views

  if (auto even = dynamic_cast&lt;Even_sided*&gt;(item))
  {
    view_of_evens.emplace_back(even);
  }

  if (auto trisym = dynamic_cast&lt;Trilaterally_symmetrical*&gt;(item))
  {
    view_of_trisyms.emplace_back(trisym);
  }
}
</code></pre></div>
<h5 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h5>
<p>A failure to find the required class will cause <code>dynamic_cast</code> to return a null value, and de-referencing a null-valued pointer will lead to undefined behavior.
Therefore the result of the <code>dynamic_cast</code> should always be treated as if it might contain a null value, and tested.</p>
<h5 id="enforcement_76">Enforcement<a class="headerlink" href="#enforcement_76" title="Permanent link">&para;</a></h5>
<ul>
<li>(Complex) Unless there is a null test on the result of a <code>dynamic_cast</code> of a pointer type, warn upon dereference of the pointer.</li>
</ul>
<h3 id="c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new"><a name="Rh-smart"></a>C.149: Use <code>unique_ptr</code> or <code>shared_ptr</code> to avoid forgetting to <code>delete</code> objects created using <code>new</code><a class="headerlink" href="#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new" title="Permanent link">&para;</a></h3>
<h5 id="reason_80">Reason<a class="headerlink" href="#reason_80" title="Permanent link">&para;</a></h5>
<p>Avoid resource leaks.</p>
<h5 id="example_60">Example<a class="headerlink" href="#example_60" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void use(int i)
{
    auto p = new int {7};           // bad: initialize local pointers with new
    auto q = make_unique&lt;int&gt;(9);   // ok: guarantee the release of the memory-allocated for 9
    if (0 &lt; i) return;              // maybe return and leak
    delete p;                       // too late
}
</code></pre></div>
<h5 id="enforcement_77">Enforcement<a class="headerlink" href="#enforcement_77" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag initialization of a naked pointer with the result of a <code>new</code></li>
<li>Flag <code>delete</code> of local variable</li>
</ul>
<h3 id="c150-use-make_unique-to-construct-objects-owned-by-unique_ptrs"><a name="Rh-make_unique"></a>C.150: Use <code>make_unique()</code> to construct objects owned by <code>unique_ptr</code>s<a class="headerlink" href="#c150-use-make_unique-to-construct-objects-owned-by-unique_ptrs" title="Permanent link">&para;</a></h3>
<p>See <a href="#Rr-make_unique">R.23</a></p>
<h3 id="c151-use-make_shared-to-construct-objects-owned-by-shared_ptrs"><a name="Rh-make_shared"></a>C.151: Use <code>make_shared()</code> to construct objects owned by <code>shared_ptr</code>s<a class="headerlink" href="#c151-use-make_shared-to-construct-objects-owned-by-shared_ptrs" title="Permanent link">&para;</a></h3>
<p>See <a href="#Rr-make_shared">R.22</a></p>
<h3 id="c152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base"><a name="Rh-array"></a>C.152: Never assign a pointer to an array of derived class objects to a pointer to its base<a class="headerlink" href="#c152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base" title="Permanent link">&para;</a></h3>
<h5 id="reason_81">Reason<a class="headerlink" href="#reason_81" title="Permanent link">&para;</a></h5>
<p>Subscripting the resulting base pointer will lead to invalid object access and probably to memory corruption.</p>
<h5 id="example_61">Example<a class="headerlink" href="#example_61" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct B { int x; };
struct D : B { int y; };

void use(B*);

D a[] = { {1, 2}, {3, 4}, {5, 6} };
B* p = a;     // bad: a decays to &amp;a[0] which is converted to a B*
p[1].x = 7;   // overwrite a[0].y

use(a);       // bad: a decays to &amp;a[0] which is converted to a B*
</code></pre></div>
<h5 id="enforcement_78">Enforcement<a class="headerlink" href="#enforcement_78" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag all combinations of array decay and base to derived conversions.</li>
<li>Pass an array as a <code>span</code> rather than as a pointer, and don't let the array name suffer a derived-to-base conversion before getting into the <code>span</code></li>
</ul>
<h3 id="c153-prefer-virtual-function-to-casting"><a name="Rh-use-virtual"></a>C.153: Prefer virtual function to casting<a class="headerlink" href="#c153-prefer-virtual-function-to-casting" title="Permanent link">&para;</a></h3>
<h5 id="reason_82">Reason<a class="headerlink" href="#reason_82" title="Permanent link">&para;</a></h5>
<p>A virtual function call is safe, whereas casting is error-prone.
A virtual function call reaches the most derived function, whereas a cast might reach an intermediate class and therefore
give a wrong result (especially as a hierarchy is modified during maintenance).</p>
<h5 id="example_62">Example<a class="headerlink" href="#example_62" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>???
</code></pre></div>
<h5 id="enforcement_79">Enforcement<a class="headerlink" href="#enforcement_79" title="Permanent link">&para;</a></h5>
<p>See <a href="#Rh-dynamic_cast">C.146</a> and ???</p>
<h2 id="cover-overloading-and-overloaded-operators"><a name="SS-overload"></a>C.over: Overloading and overloaded operators<a class="headerlink" href="#cover-overloading-and-overloaded-operators" title="Permanent link">&para;</a></h2>
<p>You can overload ordinary functions, function templates, and operators.
You cannot overload function objects.</p>
<p>Overload rule summary:</p>
<ul>
<li><a href="#Ro-conventional">C.160: Define operators primarily to mimic conventional usage</a></li>
<li><a href="#Ro-symmetric">C.161: Use non-member functions for symmetric operators</a></li>
<li><a href="#Ro-equivalent">C.162: Overload operations that are roughly equivalent</a></li>
<li><a href="#Ro-equivalent-2">C.163: Overload only for operations that are roughly equivalent</a></li>
<li><a href="#Ro-conversion">C.164: Avoid implicit conversion operators</a></li>
<li><a href="#Ro-custom">C.165: Use <code>using</code> for customization points</a></li>
<li><a href="#Ro-address-of">C.166: Overload unary <code>&amp;</code> only as part of a system of smart pointers and references</a></li>
<li><a href="#Ro-overload">C.167: Use an operator for an operation with its conventional meaning</a></li>
<li><a href="#Ro-namespace">C.168: Define overloaded operators in the namespace of their operands</a></li>
<li><a href="#Ro-lambda">C.170: If you feel like overloading a lambda, use a generic lambda</a></li>
</ul>
<h3 id="c160-define-operators-primarily-to-mimic-conventional-usage"><a name="Ro-conventional"></a>C.160: Define operators primarily to mimic conventional usage<a class="headerlink" href="#c160-define-operators-primarily-to-mimic-conventional-usage" title="Permanent link">&para;</a></h3>
<h5 id="reason_83">Reason<a class="headerlink" href="#reason_83" title="Permanent link">&para;</a></h5>
<p>Minimize surprises.</p>
<h5 id="example_63">Example<a class="headerlink" href="#example_63" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X {
public:
    // ...
    X&amp; operator=(const X&amp;); // member function defining assignment
    friend bool operator==(const X&amp;, const X&amp;); // == needs access to representation
                                                // after a = b we have a == b
    // ...
};
</code></pre></div>
<p>Here, the conventional semantics is maintained: <a href="#SS-copy">Copies compare equal</a>.</p>
<h5 id="example-bad_38">Example, bad<a class="headerlink" href="#example-bad_38" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>X operator+(X a, X b) { return a.v - b.v; }   // bad: makes + subtract
</code></pre></div>
<h5 id="note_78">Note<a class="headerlink" href="#note_78" title="Permanent link">&para;</a></h5>
<p>Non-member operators should be either friends or defined in <a href="#Ro-namespace">the same namespace as their operands</a>.
<a href="#Ro-symmetric">Binary operators should treat their operands equivalently</a>.</p>
<h5 id="enforcement_80">Enforcement<a class="headerlink" href="#enforcement_80" title="Permanent link">&para;</a></h5>
<p>Possibly impossible.</p>
<h3 id="c161-use-non-member-functions-for-symmetric-operators"><a name="Ro-symmetric"></a>C.161: Use non-member functions for symmetric operators<a class="headerlink" href="#c161-use-non-member-functions-for-symmetric-operators" title="Permanent link">&para;</a></h3>
<h5 id="reason_84">Reason<a class="headerlink" href="#reason_84" title="Permanent link">&para;</a></h5>
<p>If you use member functions, you need two.
Unless you use a non-member function for (say) <code>==</code>, <code>a == b</code> and <code>b == a</code> will be subtly different.</p>
<h5 id="example_64">Example<a class="headerlink" href="#example_64" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>bool operator==(Point a, Point b) { return a.x == b.x &amp;&amp; a.y == b.y; }
</code></pre></div>
<h5 id="enforcement_81">Enforcement<a class="headerlink" href="#enforcement_81" title="Permanent link">&para;</a></h5>
<p>Flag member operator functions.</p>
<h3 id="c162-overload-operations-that-are-roughly-equivalent"><a name="Ro-equivalent"></a>C.162: Overload operations that are roughly equivalent<a class="headerlink" href="#c162-overload-operations-that-are-roughly-equivalent" title="Permanent link">&para;</a></h3>
<h5 id="reason_85">Reason<a class="headerlink" href="#reason_85" title="Permanent link">&para;</a></h5>
<p>Having different names for logically equivalent operations on different argument types is confusing, leads to encoding type information in function names, and inhibits generic programming.</p>
<h5 id="example_65">Example<a class="headerlink" href="#example_65" title="Permanent link">&para;</a></h5>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>void print(int a);
void print(int a, int base);
void print(const string&amp;);
</code></pre></div>
<p>These three functions all print their arguments (appropriately). Conversely:</p>
<div class="language-text highlight"><pre><span></span><code>void print_int(int a);
void print_based(int a, int base);
void print_string(const string&amp;);
</code></pre></div>
<p>These three functions all print their arguments (appropriately). Adding to the name just introduced verbosity and inhibits generic code.</p>
<h5 id="enforcement_82">Enforcement<a class="headerlink" href="#enforcement_82" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c163-overload-only-for-operations-that-are-roughly-equivalent"><a name="Ro-equivalent-2"></a>C.163: Overload only for operations that are roughly equivalent<a class="headerlink" href="#c163-overload-only-for-operations-that-are-roughly-equivalent" title="Permanent link">&para;</a></h3>
<h5 id="reason_86">Reason<a class="headerlink" href="#reason_86" title="Permanent link">&para;</a></h5>
<p>Having the same name for logically different functions is confusing and leads to errors when using generic programming.</p>
<h5 id="example_66">Example<a class="headerlink" href="#example_66" title="Permanent link">&para;</a></h5>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>void open_gate(Gate&amp; g);   // remove obstacle from garage exit lane
void fopen(const char* name, const char* mode);   // open file
</code></pre></div>
<p>The two operations are fundamentally different (and unrelated) so it is good that their names differ. Conversely:</p>
<div class="language-text highlight"><pre><span></span><code>void open(Gate&amp; g);   // remove obstacle from garage exit lane
void open(const char* name, const char* mode =&quot;r&quot;);   // open file
</code></pre></div>
<p>The two operations are still fundamentally different (and unrelated) but the names have been reduced to their (common) minimum, opening opportunities for confusion.
Fortunately, the type system will catch many such mistakes.</p>
<h5 id="note_79">Note<a class="headerlink" href="#note_79" title="Permanent link">&para;</a></h5>
<p>Be particularly careful about common and popular names, such as <code>open</code>, <code>move</code>, <code>+</code>, and <code>==</code>.</p>
<h5 id="enforcement_83">Enforcement<a class="headerlink" href="#enforcement_83" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c164-avoid-implicit-conversion-operators"><a name="Ro-conversion"></a>C.164: Avoid implicit conversion operators<a class="headerlink" href="#c164-avoid-implicit-conversion-operators" title="Permanent link">&para;</a></h3>
<h5 id="reason_87">Reason<a class="headerlink" href="#reason_87" title="Permanent link">&para;</a></h5>
<p>Implicit conversions can be essential (e.g., <code>double</code> to <code>int</code>) but often cause surprises (e.g., <code>String</code> to C-style string).</p>
<h5 id="note_80">Note<a class="headerlink" href="#note_80" title="Permanent link">&para;</a></h5>
<p>Prefer explicitly named conversions until a serious need is demonstrated.
By "serious need" we mean a reason that is fundamental in the application domain (such as an integer to complex number conversion)
and frequently needed. Do not introduce implicit conversions (through conversion operators or non-<code>explicit</code> constructors)
just to gain a minor convenience.</p>
<h5 id="example_67">Example<a class="headerlink" href="#example_67" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct S1 {
    string s;
    // ...
    operator char*() { return s.data(); }  // BAD, likely to cause surprises
};

struct S2 {
    string s;
    // ...
    explicit operator char*() { return s.data(); }
};

void f(S1 s1, S2 s2)
{
    char* x1 = s1;     // OK, but can cause surprises in many contexts
    char* x2 = s2;     // error (and that&#39;s usually a good thing)
    char* x3 = static_cast&lt;char*&gt;(s2); // we can be explicit (on your head be it)
}
</code></pre></div>
<p>The surprising and potentially damaging implicit conversion can occur in arbitrarily hard-to spot contexts, e.g.,</p>
<div class="language-text highlight"><pre><span></span><code>S1 ff();

char* g()
{
    return ff();
}
</code></pre></div>
<p>The string returned by <code>ff()</code> is destroyed before the returned pointer into it can be used.</p>
<h5 id="enforcement_84">Enforcement<a class="headerlink" href="#enforcement_84" title="Permanent link">&para;</a></h5>
<p>Flag all non-explicit conversion operators.</p>
<h3 id="c165-use-using-for-customization-points"><a name="Ro-custom"></a>C.165: Use <code>using</code> for customization points<a class="headerlink" href="#c165-use-using-for-customization-points" title="Permanent link">&para;</a></h3>
<h5 id="reason_88">Reason<a class="headerlink" href="#reason_88" title="Permanent link">&para;</a></h5>
<p>To find function objects and functions defined in a separate namespace to "customize" a common function.</p>
<h5 id="example_68">Example<a class="headerlink" href="#example_68" title="Permanent link">&para;</a></h5>
<p>Consider <code>swap</code>. It is a general (standard-library) function with a definition that will work for just about any type.
However, it is desirable to define specific <code>swap()</code>s for specific types.
For example, the general <code>swap()</code> will copy the elements of two <code>vector</code>s being swapped, whereas a good specific implementation will not copy elements at all.</p>
<div class="language-text highlight"><pre><span></span><code>namespace N {
    My_type X { /* ... */ };
    void swap(X&amp;, X&amp;);   // optimized swap for N::X
    // ...
}

void f1(N::X&amp; a, N::X&amp; b)
{
    std::swap(a, b);   // probably not what we wanted: calls std::swap()
}
</code></pre></div>
<p>The <code>std::swap()</code> in <code>f1()</code> does exactly what we asked it to do: it calls the <code>swap()</code> in namespace <code>std</code>.
Unfortunately, that's probably not what we wanted.
How do we get <code>N::X</code> considered?</p>
<div class="language-text highlight"><pre><span></span><code>void f2(N::X&amp; a, N::X&amp; b)
{
    swap(a, b);   // calls N::swap
}
</code></pre></div>
<p>But that might not be what we wanted for generic code.
There, we typically want the specific function if it exists and the general function if not.
This is done by including the general function in the lookup for the function:</p>
<div class="language-text highlight"><pre><span></span><code>void f3(N::X&amp; a, N::X&amp; b)
{
    using std::swap;  // make std::swap available
    swap(a, b);        // calls N::swap if it exists, otherwise std::swap
}
</code></pre></div>
<h5 id="enforcement_85">Enforcement<a class="headerlink" href="#enforcement_85" title="Permanent link">&para;</a></h5>
<p>Unlikely, except for known customization points, such as <code>swap</code>.
The problem is that the unqualified and qualified lookups both have uses.</p>
<h3 id="c166-overload-unary-only-as-part-of-a-system-of-smart-pointers-and-references"><a name="Ro-address-of"></a>C.166: Overload unary <code>&amp;</code> only as part of a system of smart pointers and references<a class="headerlink" href="#c166-overload-unary-only-as-part-of-a-system-of-smart-pointers-and-references" title="Permanent link">&para;</a></h3>
<h5 id="reason_89">Reason<a class="headerlink" href="#reason_89" title="Permanent link">&para;</a></h5>
<p>The <code>&amp;</code> operator is fundamental in C++.
Many parts of the C++ semantics assume its default meaning.</p>
<h5 id="example_69">Example<a class="headerlink" href="#example_69" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Ptr { // a somewhat smart pointer
    Ptr(X* pp) : p(pp) { /* check */ }
    X* operator-&gt;() { /* check */ return p; }
    X operator[](int i);
    X operator*();
private:
    T* p;
};

class X {
    Ptr operator&amp;() { return Ptr{this}; }
    // ...
};
</code></pre></div>
<h5 id="note_81">Note<a class="headerlink" href="#note_81" title="Permanent link">&para;</a></h5>
<p>If you "mess with" operator <code>&amp;</code> be sure that its definition has matching meanings for <code>-&gt;</code>, <code>[]</code>, <code>*</code>, and <code>.</code> on the result type.
Note that operator <code>.</code> currently cannot be overloaded so a perfect system is impossible.
We hope to remedy that: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf">Operator Dot (R2)</a>.
Note that <code>std::addressof()</code> always yields a built-in pointer.</p>
<h5 id="enforcement_86">Enforcement<a class="headerlink" href="#enforcement_86" title="Permanent link">&para;</a></h5>
<p>Tricky. Warn if <code>&amp;</code> is user-defined without also defining <code>-&gt;</code> for the result type.</p>
<h3 id="c167-use-an-operator-for-an-operation-with-its-conventional-meaning"><a name="Ro-overload"></a>C.167: Use an operator for an operation with its conventional meaning<a class="headerlink" href="#c167-use-an-operator-for-an-operation-with-its-conventional-meaning" title="Permanent link">&para;</a></h3>
<h5 id="reason_90">Reason<a class="headerlink" href="#reason_90" title="Permanent link">&para;</a></h5>
<p>Readability. Convention. Reusability. Support for generic code</p>
<h5 id="example_70">Example<a class="headerlink" href="#example_70" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void cout_my_class(const My_class&amp; c) // confusing, not conventional,not generic
{
    std::cout &lt;&lt; /* class members here */;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_class&amp; c) // OK
{
    return os &lt;&lt; /* class members here */;
}
</code></pre></div>
<p>By itself, <code>cout_my_class</code> would be OK, but it is not usable/composable with code that rely on the <code>&lt;&lt;</code> convention for output:</p>
<div class="language-text highlight"><pre><span></span><code>My_class var { /* ... */ };
// ...
cout &lt;&lt; &quot;var = &quot; &lt;&lt; var &lt;&lt; &#39;\n&#39;;
</code></pre></div>
<h5 id="note_82">Note<a class="headerlink" href="#note_82" title="Permanent link">&para;</a></h5>
<p>There are strong and vigorous conventions for the meaning of most operators, such as</p>
<ul>
<li>comparisons (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and <code>&lt;=&gt;</code>),</li>
<li>arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code>)</li>
<li>access operations (<code>.</code>, <code>-&gt;</code>, unary <code>*</code>, and <code>[]</code>)</li>
<li>assignment (<code>=</code>)</li>
</ul>
<p>Don't define those unconventionally and don't invent your own names for them.</p>
<h5 id="enforcement_87">Enforcement<a class="headerlink" href="#enforcement_87" title="Permanent link">&para;</a></h5>
<p>Tricky. Requires semantic insight.</p>
<h3 id="c168-define-overloaded-operators-in-the-namespace-of-their-operands"><a name="Ro-namespace"></a>C.168: Define overloaded operators in the namespace of their operands<a class="headerlink" href="#c168-define-overloaded-operators-in-the-namespace-of-their-operands" title="Permanent link">&para;</a></h3>
<h5 id="reason_91">Reason<a class="headerlink" href="#reason_91" title="Permanent link">&para;</a></h5>
<p>Readability.
Ability for find operators using ADL.
Avoiding inconsistent definition in different namespaces</p>
<h5 id="example_71">Example<a class="headerlink" href="#example_71" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct S { };
S operator+(S, S);   // OK: in the same namespace as S, and even next to S
S s;

S r = s + s;
</code></pre></div>
<h5 id="example_72">Example<a class="headerlink" href="#example_72" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>namespace N {
    struct S { };
    S operator+(S, S);   // OK: in the same namespace as S, and even next to S
}

N::S s;

S r = s + s;  // finds N::operator+() by ADL
</code></pre></div>
<h5 id="example-bad_39">Example, bad<a class="headerlink" href="#example-bad_39" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>struct S { };
S s;

namespace N {
    bool operator!(S a) { return true; }
    bool not_s = !s;
}

namespace M {
    bool operator!(S a) { return false; }
    bool not_s = !s;
}
</code></pre></div>
<p>Here, the meaning of <code>!s</code> differs in <code>N</code> and <code>M</code>.
This can be most confusing.
Remove the definition of <code>namespace M</code> and the confusion is replaced by an opportunity to make the mistake.</p>
<h5 id="note_83">Note<a class="headerlink" href="#note_83" title="Permanent link">&para;</a></h5>
<p>If a binary operator is defined for two types that are defined in different namespaces, you cannot follow this rule.
For example:</p>
<div class="language-text highlight"><pre><span></span><code>Vec::Vector operator*(const Vec::Vector&amp;, const Mat::Matrix&amp;);
</code></pre></div>
<p>This might be something best avoided.</p>
<h5 id="see-also_1">See also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h5>
<p>This is a special case of the rule that <a href="#Rc-helper">helper functions should be defined in the same namespace as their class</a>.</p>
<h5 id="enforcement_88">Enforcement<a class="headerlink" href="#enforcement_88" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag operator definitions that are not in the namespace of their operands</li>
</ul>
<h3 id="c170-if-you-feel-like-overloading-a-lambda-use-a-generic-lambda"><a name="Ro-lambda"></a>C.170: If you feel like overloading a lambda, use a generic lambda<a class="headerlink" href="#c170-if-you-feel-like-overloading-a-lambda-use-a-generic-lambda" title="Permanent link">&para;</a></h3>
<h5 id="reason_92">Reason<a class="headerlink" href="#reason_92" title="Permanent link">&para;</a></h5>
<p>You cannot overload by defining two different lambdas with the same name.</p>
<h5 id="example_73">Example<a class="headerlink" href="#example_73" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(int);
void f(double);
auto f = [](char);   // error: cannot overload variable and function

auto g = [](int) { /* ... */ };
auto g = [](double) { /* ... */ };   // error: cannot overload variables

auto h = [](auto) { /* ... */ };   // OK
</code></pre></div>
<h5 id="enforcement_89">Enforcement<a class="headerlink" href="#enforcement_89" title="Permanent link">&para;</a></h5>
<p>The compiler catches the attempt to overload a lambda.</p>
<h2 id="cunion-unions"><a name="SS-union"></a>C.union: Unions<a class="headerlink" href="#cunion-unions" title="Permanent link">&para;</a></h2>
<p>A <code>union</code> is a <code>struct</code> where all members start at the same address so that it can hold only one member at a time.
A <code>union</code> does not keep track of which member is stored so the programmer has to get it right;
this is inherently error-prone, but there are ways to compensate.</p>
<p>A type that is a <code>union</code> plus an indicator of which member is currently held is called a <em>tagged union</em>, a <em>discriminated union</em>, or a <em>variant</em>.</p>
<p>Union rule summary:</p>
<ul>
<li><a href="#Ru-union">C.180: Use <code>union</code>s to save Memory</a></li>
<li><a href="#Ru-naked">C.181: Avoid "naked" <code>union</code>s</a></li>
<li><a href="#Ru-anonymous">C.182: Use anonymous <code>union</code>s to implement tagged unions</a></li>
<li><a href="#Ru-pun">C.183: Don't use a <code>union</code> for type punning</a></li>
<li>???</li>
</ul>
<h3 id="c180-use-unions-to-save-memory"><a name="Ru-union"></a>C.180: Use <code>union</code>s to save memory<a class="headerlink" href="#c180-use-unions-to-save-memory" title="Permanent link">&para;</a></h3>
<h5 id="reason_93">Reason<a class="headerlink" href="#reason_93" title="Permanent link">&para;</a></h5>
<p>A <code>union</code> allows a single piece of memory to be used for different types of objects at different times.
Consequently, it can be used to save memory when we have several objects that are never used at the same time.</p>
<h5 id="example_74">Example<a class="headerlink" href="#example_74" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>union Value {
    int x;
    double d;
};

Value v = { 123 };  // now v holds an int
cout &lt;&lt; v.x &lt;&lt; &#39;\n&#39;;    // write 123
v.d = 987.654;  // now v holds a double
cout &lt;&lt; v.d &lt;&lt; &#39;\n&#39;;    // write 987.654
</code></pre></div>
<p>But heed the warning: <a href="#Ru-naked">Avoid "naked" <code>union</code>s</a></p>
<h5 id="example_75">Example<a class="headerlink" href="#example_75" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>// Short-string optimization

constexpr size_t buffer_size = 16; // Slightly larger than the size of a pointer

class Immutable_string {
public:
    Immutable_string(const char* str) :
        size(strlen(str))
    {
        if (size &lt; buffer_size)
            strcpy_s(string_buffer, buffer_size, str);
        else {
            string_ptr = new char[size + 1];
            strcpy_s(string_ptr, size + 1, str);
        }
    }

    ~Immutable_string()
    {
        if (size &gt;= buffer_size)
            delete[] string_ptr;
    }

    const char* get_str() const
    {
        return (size &lt; buffer_size) ? string_buffer : string_ptr;
    }

private:
    // If the string is short enough, we store the string itself
    // instead of a pointer to the string.
    union {
        char* string_ptr;
        char string_buffer[buffer_size];
    };

    const size_t size;
};
</code></pre></div>
<h5 id="enforcement_90">Enforcement<a class="headerlink" href="#enforcement_90" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c181-avoid-naked-unions"><a name="Ru-naked"></a>C.181: Avoid "naked" <code>union</code>s<a class="headerlink" href="#c181-avoid-naked-unions" title="Permanent link">&para;</a></h3>
<h5 id="reason_94">Reason<a class="headerlink" href="#reason_94" title="Permanent link">&para;</a></h5>
<p>A <em>naked union</em> is a union without an associated indicator which member (if any) it holds,
so that the programmer has to keep track.
Naked unions are a source of type errors.</p>
<h5 id="example-bad_40">Example, bad<a class="headerlink" href="#example-bad_40" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>union Value {
    int x;
    double d;
};

Value v;
v.d = 987.654;  // v holds a double
</code></pre></div>
<p>So far, so good, but we can easily misuse the <code>union</code>:</p>
<div class="language-text highlight"><pre><span></span><code>cout &lt;&lt; v.x &lt;&lt; &#39;\n&#39;;    // BAD, undefined behavior: v holds a double, but we read it as an int
</code></pre></div>
<p>Note that the type error happened without any explicit cast.
When we tested that program the last value printed was <code>1683627180</code> which is the integer value for the bit pattern for <code>987.654</code>.
What we have here is an "invisible" type error that happens to give a result that could easily look innocent.</p>
<p>And, talking about "invisible", this code produced no output:</p>
<div class="language-text highlight"><pre><span></span><code>v.x = 123;
cout &lt;&lt; v.d &lt;&lt; &#39;\n&#39;;    // BAD: undefined behavior
</code></pre></div>
<h5 id="alternative_1">Alternative<a class="headerlink" href="#alternative_1" title="Permanent link">&para;</a></h5>
<p>Wrap a <code>union</code> in a class together with a type field.</p>
<p>The C++17 <code>variant</code> type (found in <code>&lt;variant&gt;</code>) does that for you:</p>
<div class="language-text highlight"><pre><span></span><code>variant&lt;int, double&gt; v;
v = 123;        // v holds an int
int x = get&lt;int&gt;(v);
v = 123.456;    // v holds a double
double w = get&lt;double&gt;(v);
</code></pre></div>
<h5 id="enforcement_91">Enforcement<a class="headerlink" href="#enforcement_91" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c182-use-anonymous-unions-to-implement-tagged-unions"><a name="Ru-anonymous"></a>C.182: Use anonymous <code>union</code>s to implement tagged unions<a class="headerlink" href="#c182-use-anonymous-unions-to-implement-tagged-unions" title="Permanent link">&para;</a></h3>
<h5 id="reason_95">Reason<a class="headerlink" href="#reason_95" title="Permanent link">&para;</a></h5>
<p>A well-designed tagged union is type safe.
An <em>anonymous</em> union simplifies the definition of a class with a (tag, union) pair.</p>
<h5 id="example_76">Example<a class="headerlink" href="#example_76" title="Permanent link">&para;</a></h5>
<p>This example is mostly borrowed from TC++PL4 pp216-218.
You can look there for an explanation.</p>
<p>The code is somewhat elaborate.
Handling a type with user-defined assignment and destructor is tricky.
Saving programmers from having to write such code is one reason for including <code>variant</code> in the standard.</p>
<div class="language-text highlight"><pre><span></span><code>class Value { // two alternative representations represented as a union
private:
    enum class Tag { number, text };
    Tag type; // discriminant

    union { // representation (note: anonymous union)
        int i;
        string s; // string has default constructor, copy operations, and destructor
    };
public:
    struct Bad_entry { }; // used for exceptions

    ~Value();
    Value&amp; operator=(const Value&amp;);   // necessary because of the string variant
    Value(const Value&amp;);
    // ...
    int number() const;
    string text() const;

    void set_number(int n);
    void set_text(const string&amp;);
    // ...
};

int Value::number() const
{
    if (type != Tag::number) throw Bad_entry{};
    return i;
}

string Value::text() const
{
    if (type != Tag::text) throw Bad_entry{};
    return s;
}

void Value::set_number(int n)
{
    if (type == Tag::text) {
        s.~string();      // explicitly destroy string
        type = Tag::number;
    }
    i = n;
}

void Value::set_text(const string&amp; ss)
{
    if (type == Tag::text)
        s = ss;
    else {
        new(&amp;s) string{ss};   // placement new: explicitly construct string
        type = Tag::text;
    }
}

Value&amp; Value::operator=(const Value&amp; e)   // necessary because of the string variant
{
    if (type == Tag::text &amp;&amp; e.type == Tag::text) {
        s = e.s;    // usual string assignment
        return *this;
    }

    if (type == Tag::text) s.~string(); // explicit destroy

    switch (e.type) {
    case Tag::number:
        i = e.i;
        break;
    case Tag::text:
        new(&amp;s) string(e.s);   // placement new: explicit construct
    }

    type = e.type;
    return *this;
}

Value::~Value()
{
    if (type == Tag::text) s.~string(); // explicit destroy
}
</code></pre></div>
<h5 id="enforcement_92">Enforcement<a class="headerlink" href="#enforcement_92" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="c183-dont-use-a-union-for-type-punning"><a name="Ru-pun"></a>C.183: Don't use a <code>union</code> for type punning<a class="headerlink" href="#c183-dont-use-a-union-for-type-punning" title="Permanent link">&para;</a></h3>
<h5 id="reason_96">Reason<a class="headerlink" href="#reason_96" title="Permanent link">&para;</a></h5>
<p>It is undefined behavior to read a <code>union</code> member with a different type from the one with which it was written.
Such punning is invisible, or at least harder to spot than using a named cast.
Type punning using a <code>union</code> is a source of errors.</p>
<h5 id="example-bad_41">Example, bad<a class="headerlink" href="#example-bad_41" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>union Pun {
    int x;
    unsigned char c[sizeof(int)];
};
</code></pre></div>
<p>The idea of <code>Pun</code> is to be able to look at the character representation of an <code>int</code>.</p>
<div class="language-text highlight"><pre><span></span><code>void bad(Pun&amp; u)
{
    u.x = &#39;x&#39;;
    cout &lt;&lt; u.c[0] &lt;&lt; &#39;\n&#39;;     // undefined behavior
}
</code></pre></div>
<p>If you wanted to see the bytes of an <code>int</code>, use a (named) cast:</p>
<div class="language-text highlight"><pre><span></span><code>void if_you_must_pun(int&amp; x)
{
    auto p = reinterpret_cast&lt;std::byte*&gt;(&amp;x);
    cout &lt;&lt; p[0] &lt;&lt; &#39;\n&#39;;     // OK; better
    // ...
}
</code></pre></div>
<p>Accessing the result of a <code>reinterpret_cast</code> from the object's declared type to <code>char*</code>, <code>unsigned char*</code>, or <code>std::byte*</code> is defined behavior. (Using <code>reinterpret_cast</code> is discouraged,
but at least we can see that something tricky is going on.)</p>
<h5 id="note_84">Note<a class="headerlink" href="#note_84" title="Permanent link">&para;</a></h5>
<p>Unfortunately, <code>union</code>s are commonly used for type punning.
We don't consider "sometimes, it works as expected" a conclusive argument.</p>
<p>C++17 introduced a distinct type <code>std::byte</code> to facilitate operations on raw object representation.  Use that type instead of <code>unsigned char</code> or <code>char</code> for these operations.</p>
<h5 id="enforcement_93">Enforcement<a class="headerlink" href="#enforcement_93" title="Permanent link">&para;</a></h5>
<p>???</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["content.code.copy"], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="../js/open_in_new_tab.js"></script>
      
    
  </body>
</html>
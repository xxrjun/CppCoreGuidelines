
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../enum-enumerations/">
      
      
        <link rel="next" href="../es-expressions-and-statements/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.4">
    
    
      
        <title>R: Resource management - C++ Core Guidelines</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8608ea7d.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#r-resource-management-s-resource" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="C++ Core Guidelines" class="md-header__button md-logo" aria-label="C++ Core Guidelines" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            C++ Core Guidelines
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              R: Resource management
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/xxrjun/CppCoreGuidelines" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    xxrjun/CppCoreGuidelines
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="C++ Core Guidelines" class="md-nav__button md-logo" aria-label="C++ Core Guidelines" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    C++ Core Guidelines
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/xxrjun/CppCoreGuidelines" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    xxrjun/CppCoreGuidelines
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../NOTICE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NOTICE
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../abstract/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Abstract
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../in-introduction/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    In: Introduction
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../p-philosophy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    P: Philosophy
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../i-interfaces/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    I: Interfaces
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../f-functions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    F: Functions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../c-classes-and-class-hierarchies/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C: Classes and class hierarchies
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../enum-enumerations/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Enum: Enumerations
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    R: Resource management
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    R: Resource management
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#r1-manage-resources-automatically-using-resource-handles-and-raii-resource-acquisition-is-initialization" class="md-nav__link">
    <span class="md-ellipsis">
      R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r2-in-interfaces-use-raw-pointers-to-denote-individual-objects-only" class="md-nav__link">
    <span class="md-ellipsis">
      R.2: In interfaces, use raw pointers to denote individual objects (only)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r3-a-raw-pointer-a-t-is-non-owning" class="md-nav__link">
    <span class="md-ellipsis">
      R.3: A raw pointer (a T*) is non-owning
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r4-a-raw-reference-a-t-is-non-owning" class="md-nav__link">
    <span class="md-ellipsis">
      R.4: A raw reference (a T&amp;) is non-owning
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r5-prefer-scoped-objects-dont-heap-allocate-unnecessarily" class="md-nav__link">
    <span class="md-ellipsis">
      R.5: Prefer scoped objects, don't heap-allocate unnecessarily
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r6-avoid-non-const-global-variables" class="md-nav__link">
    <span class="md-ellipsis">
      R.6: Avoid non-const global variables
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ralloc-allocation-and-deallocation" class="md-nav__link">
    <span class="md-ellipsis">
      R.alloc: Allocation and deallocation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="R.alloc: Allocation and deallocation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#r10-avoid-malloc-and-free" class="md-nav__link">
    <span class="md-ellipsis">
      R.10: Avoid malloc() and free()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r11-avoid-calling-new-and-delete-explicitly" class="md-nav__link">
    <span class="md-ellipsis">
      R.11: Avoid calling new and delete explicitly
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r12-immediately-give-the-result-of-an-explicit-resource-allocation-to-a-manager-object" class="md-nav__link">
    <span class="md-ellipsis">
      R.12: Immediately give the result of an explicit resource allocation to a manager object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement" class="md-nav__link">
    <span class="md-ellipsis">
      R.13: Perform at most one explicit resource allocation in a single expression statement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r14-avoid-parameters-prefer-span" class="md-nav__link">
    <span class="md-ellipsis">
      R.14: Avoid [] parameters, prefer span
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r15-always-overload-matched-allocationdeallocation-pairs" class="md-nav__link">
    <span class="md-ellipsis">
      R.15: Always overload matched allocation/deallocation pairs
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rsmart-smart-pointers" class="md-nav__link">
    <span class="md-ellipsis">
      R.smart: Smart pointers
    </span>
  </a>
  
    <nav class="md-nav" aria-label="R.smart: Smart pointers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#r20-use-unique_ptr-or-shared_ptr-to-represent-ownership" class="md-nav__link">
    <span class="md-ellipsis">
      R.20: Use unique_ptr or shared_ptr to represent ownership
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r21-prefer-unique_ptr-over-shared_ptr-unless-you-need-to-share-ownership" class="md-nav__link">
    <span class="md-ellipsis">
      R.21: Prefer unique_ptr over shared_ptr unless you need to share ownership
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r22-use-make_shared-to-make-shared_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      R.22: Use make_shared() to make shared_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r23-use-make_unique-to-make-unique_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      R.23: Use make_unique() to make unique_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r24-use-stdweak_ptr-to-break-cycles-of-shared_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      R.24: Use std::weak_ptr to break cycles of shared_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics" class="md-nav__link">
    <span class="md-ellipsis">
      R.30: Take smart pointers as parameters only to explicitly express lifetime semantics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r31-if-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std" class="md-nav__link">
    <span class="md-ellipsis">
      R.31: If you have non-std smart pointers, follow the basic pattern from std
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget" class="md-nav__link">
    <span class="md-ellipsis">
      R.32: Take a unique_ptr&lt;widget&gt; parameter to express that a function assumes ownership of a widget
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r33-take-a-unique_ptrwidget-parameter-to-express-that-a-function-reseats-the-widget" class="md-nav__link">
    <span class="md-ellipsis">
      R.33: Take a unique_ptr&lt;widget&gt;&amp; parameter to express that a function reseats the widget
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r34-take-a-shared_ptrwidget-parameter-to-express-shared-ownership" class="md-nav__link">
    <span class="md-ellipsis">
      R.34: Take a shared_ptr&lt;widget&gt; parameter to express shared ownership
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r35-take-a-shared_ptrwidget-parameter-to-express-that-a-function-might-reseat-the-shared-pointer" class="md-nav__link">
    <span class="md-ellipsis">
      R.35: Take a shared_ptr&lt;widget&gt;&amp; parameter to express that a function might reseat the shared pointer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r36-take-a-const-shared_ptrwidget-parameter-to-express-that-it-might-retain-a-reference-count-to-the-object" class="md-nav__link">
    <span class="md-ellipsis">
      R.36: Take a const shared_ptr&lt;widget&gt;&amp; parameter to express that it might retain a reference count to the object ???
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer" class="md-nav__link">
    <span class="md-ellipsis">
      R.37: Do not pass a pointer or reference obtained from an aliased smart pointer
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../es-expressions-and-statements/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ES: Expressions and statements
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../per-performance/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Per: Performance
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cp-concurrency-and-parallelism/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CP: Concurrency and parallelism
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../e-error-handling/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    E: Error handling
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../con-constants-and-immutability/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Con: Constants and immutability
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../t-templates-and-generic-programming/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T: Templates and generic programming
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cpl-c-style-programming/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CPL: C-style programming
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../sf-source-files/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SF: Source files
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../sl-the-standard-library/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SL: The Standard Library
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../a-architectural-ideas/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A: Architectural ideas
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../nr-non-rules-and-myths/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NR: Non-Rules and myths
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../rf-references/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RF: References
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../pro-profiles/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Pro: Profiles
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../gsl-guidelines-support-library/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    GSL: Guidelines support library
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../nl-naming-and-layout-suggestions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NL: Naming and layout suggestions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq-answers-to-frequently-asked-questions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ: Answers to frequently asked questions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-a-libraries/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Appendix A: Libraries
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-b-modernizing-code/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Appendix B: Modernizing code
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-c-discussion/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Appendix C: Discussion
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-d-supporting-tools/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Appendix D: Supporting tools
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Glossary
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../to-do-unclassified-proto-rules/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    To-do: Unclassified proto-rules
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../bibliography/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bibliography
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#r1-manage-resources-automatically-using-resource-handles-and-raii-resource-acquisition-is-initialization" class="md-nav__link">
    <span class="md-ellipsis">
      R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r2-in-interfaces-use-raw-pointers-to-denote-individual-objects-only" class="md-nav__link">
    <span class="md-ellipsis">
      R.2: In interfaces, use raw pointers to denote individual objects (only)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r3-a-raw-pointer-a-t-is-non-owning" class="md-nav__link">
    <span class="md-ellipsis">
      R.3: A raw pointer (a T*) is non-owning
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r4-a-raw-reference-a-t-is-non-owning" class="md-nav__link">
    <span class="md-ellipsis">
      R.4: A raw reference (a T&amp;) is non-owning
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r5-prefer-scoped-objects-dont-heap-allocate-unnecessarily" class="md-nav__link">
    <span class="md-ellipsis">
      R.5: Prefer scoped objects, don't heap-allocate unnecessarily
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#r6-avoid-non-const-global-variables" class="md-nav__link">
    <span class="md-ellipsis">
      R.6: Avoid non-const global variables
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ralloc-allocation-and-deallocation" class="md-nav__link">
    <span class="md-ellipsis">
      R.alloc: Allocation and deallocation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="R.alloc: Allocation and deallocation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#r10-avoid-malloc-and-free" class="md-nav__link">
    <span class="md-ellipsis">
      R.10: Avoid malloc() and free()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r11-avoid-calling-new-and-delete-explicitly" class="md-nav__link">
    <span class="md-ellipsis">
      R.11: Avoid calling new and delete explicitly
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r12-immediately-give-the-result-of-an-explicit-resource-allocation-to-a-manager-object" class="md-nav__link">
    <span class="md-ellipsis">
      R.12: Immediately give the result of an explicit resource allocation to a manager object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement" class="md-nav__link">
    <span class="md-ellipsis">
      R.13: Perform at most one explicit resource allocation in a single expression statement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r14-avoid-parameters-prefer-span" class="md-nav__link">
    <span class="md-ellipsis">
      R.14: Avoid [] parameters, prefer span
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r15-always-overload-matched-allocationdeallocation-pairs" class="md-nav__link">
    <span class="md-ellipsis">
      R.15: Always overload matched allocation/deallocation pairs
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rsmart-smart-pointers" class="md-nav__link">
    <span class="md-ellipsis">
      R.smart: Smart pointers
    </span>
  </a>
  
    <nav class="md-nav" aria-label="R.smart: Smart pointers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#r20-use-unique_ptr-or-shared_ptr-to-represent-ownership" class="md-nav__link">
    <span class="md-ellipsis">
      R.20: Use unique_ptr or shared_ptr to represent ownership
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r21-prefer-unique_ptr-over-shared_ptr-unless-you-need-to-share-ownership" class="md-nav__link">
    <span class="md-ellipsis">
      R.21: Prefer unique_ptr over shared_ptr unless you need to share ownership
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r22-use-make_shared-to-make-shared_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      R.22: Use make_shared() to make shared_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r23-use-make_unique-to-make-unique_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      R.23: Use make_unique() to make unique_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r24-use-stdweak_ptr-to-break-cycles-of-shared_ptrs" class="md-nav__link">
    <span class="md-ellipsis">
      R.24: Use std::weak_ptr to break cycles of shared_ptrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics" class="md-nav__link">
    <span class="md-ellipsis">
      R.30: Take smart pointers as parameters only to explicitly express lifetime semantics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r31-if-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std" class="md-nav__link">
    <span class="md-ellipsis">
      R.31: If you have non-std smart pointers, follow the basic pattern from std
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget" class="md-nav__link">
    <span class="md-ellipsis">
      R.32: Take a unique_ptr&lt;widget&gt; parameter to express that a function assumes ownership of a widget
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r33-take-a-unique_ptrwidget-parameter-to-express-that-a-function-reseats-the-widget" class="md-nav__link">
    <span class="md-ellipsis">
      R.33: Take a unique_ptr&lt;widget&gt;&amp; parameter to express that a function reseats the widget
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r34-take-a-shared_ptrwidget-parameter-to-express-shared-ownership" class="md-nav__link">
    <span class="md-ellipsis">
      R.34: Take a shared_ptr&lt;widget&gt; parameter to express shared ownership
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r35-take-a-shared_ptrwidget-parameter-to-express-that-a-function-might-reseat-the-shared-pointer" class="md-nav__link">
    <span class="md-ellipsis">
      R.35: Take a shared_ptr&lt;widget&gt;&amp; parameter to express that a function might reseat the shared pointer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r36-take-a-const-shared_ptrwidget-parameter-to-express-that-it-might-retain-a-reference-count-to-the-object" class="md-nav__link">
    <span class="md-ellipsis">
      R.36: Take a const shared_ptr&lt;widget&gt;&amp; parameter to express that it might retain a reference count to the object ???
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer" class="md-nav__link">
    <span class="md-ellipsis">
      R.37: Do not pass a pointer or reference obtained from an aliased smart pointer
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="r-resource-management-s-resource">R: Resource management {#S-resource}<a class="headerlink" href="#r-resource-management-s-resource" title="Permanent link">&para;</a></h1>
<p>This section contains rules related to resources.
A resource is anything that must be acquired and (explicitly or implicitly) released, such as memory, file handles, sockets, and locks.
The reason it must be released is typically that it can be in short supply, so even delayed release might do harm.
The fundamental aim is to ensure that we don't leak any resources and that we don't hold a resource longer than we need to.
An entity that is responsible for releasing a resource is called an owner.</p>
<p>There are a few cases where leaks can be acceptable or even optimal:
If you are writing a program that simply produces an output based on an input and the amount of memory needed is proportional to the size of the input, the optimal strategy (for performance and ease of programming) is sometimes simply never to delete anything.
If you have enough memory to handle your largest input, leak away, but be sure to give a good error message if you are wrong.
Here, we ignore such cases.</p>
<ul>
<li>
<p>Resource management rule summary:</p>
</li>
<li>
<p><a href="#Rr-raii">R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)</a></p>
</li>
<li><a href="#Rr-use-ptr">R.2: In interfaces, use raw pointers to denote individual objects (only)</a></li>
<li><a href="#Rr-ptr">R.3: A raw pointer (a <code>T*</code>) is non-owning</a></li>
<li><a href="#Rr-ref">R.4: A raw reference (a <code>T&amp;</code>) is non-owning</a></li>
<li><a href="#Rr-scoped">R.5: Prefer scoped objects, don't heap-allocate unnecessarily</a></li>
<li>
<p><a href="#Rr-global">R.6: Avoid non-<code>const</code> global variables</a></p>
</li>
<li>
<p>Allocation and deallocation rule summary:</p>
</li>
<li>
<p><a href="#Rr-mallocfree">R.10: Avoid <code>malloc()</code> and <code>free()</code></a></p>
</li>
<li><a href="#Rr-newdelete">R.11: Avoid calling <code>new</code> and <code>delete</code> explicitly</a></li>
<li><a href="#Rr-immediate-alloc">R.12: Immediately give the result of an explicit resource allocation to a manager object</a></li>
<li><a href="#Rr-single-alloc">R.13: Perform at most one explicit resource allocation in a single expression statement</a></li>
<li><a href="#Rr-ap">R.14: Avoid <code>[]</code> parameters, prefer <code>span</code></a></li>
<li>
<p><a href="#Rr-pair">R.15: Always overload matched allocation/deallocation pairs</a></p>
</li>
<li>
<p><a name="Rr-summary-smartptrs"></a>Smart pointer rule summary:</p>
</li>
<li>
<p><a href="#Rr-owner">R.20: Use <code>unique_ptr</code> or <code>shared_ptr</code> to represent ownership</a></p>
</li>
<li><a href="#Rr-unique">R.21: Prefer <code>unique_ptr</code> over <code>shared_ptr</code> unless you need to share ownership</a></li>
<li><a href="#Rr-make_shared">R.22: Use <code>make_shared()</code> to make <code>shared_ptr</code>s</a></li>
<li><a href="#Rr-make_unique">R.23: Use <code>make_unique()</code> to make <code>unique_ptr</code>s</a></li>
<li><a href="#Rr-weak_ptr">R.24: Use <code>std::weak_ptr</code> to break cycles of <code>shared_ptr</code>s</a></li>
<li><a href="#Rr-smartptrparam">R.30: Take smart pointers as parameters only to explicitly express lifetime semantics</a></li>
<li><a href="#Rr-smart">R.31: If you have non-<code>std</code> smart pointers, follow the basic pattern from <code>std</code></a></li>
<li><a href="#Rr-uniqueptrparam">R.32: Take a <code>unique_ptr&lt;widget&gt;</code> parameter to express that a function assumes ownership of a <code>widget</code></a></li>
<li><a href="#Rr-reseat">R.33: Take a <code>unique_ptr&lt;widget&gt;&amp;</code> parameter to express that a function reseats the <code>widget</code></a></li>
<li><a href="#Rr-sharedptrparam-owner">R.34: Take a <code>shared_ptr&lt;widget&gt;</code> parameter to express shared ownership</a></li>
<li><a href="#Rr-sharedptrparam">R.35: Take a <code>shared_ptr&lt;widget&gt;&amp;</code> parameter to express that a function might reseat the shared pointer</a></li>
<li><a href="#Rr-sharedptrparam-const">R.36: Take a <code>const shared_ptr&lt;widget&gt;&amp;</code> parameter to express that it might retain a reference count to the object ???</a></li>
<li><a href="#Rr-smartptrget">R.37: Do not pass a pointer or reference obtained from an aliased smart pointer</a></li>
</ul>
<h3 id="r1-manage-resources-automatically-using-resource-handles-and-raii-resource-acquisition-is-initialization"><a name="Rr-raii"></a>R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)<a class="headerlink" href="#r1-manage-resources-automatically-using-resource-handles-and-raii-resource-acquisition-is-initialization" title="Permanent link">&para;</a></h3>
<h5 id="reason">Reason<a class="headerlink" href="#reason" title="Permanent link">&para;</a></h5>
<p>To avoid leaks and the complexity of manual resource management.
C++'s language-enforced constructor/destructor symmetry mirrors the symmetry inherent in resource acquire/release function pairs such as <code>fopen</code>/<code>fclose</code>, <code>lock</code>/<code>unlock</code>, and <code>new</code>/<code>delete</code>.
Whenever you deal with a resource that needs paired acquire/release function calls, encapsulate that resource in an object that enforces pairing for you -- acquire the resource in its constructor, and release it in its destructor.</p>
<h5 id="example-bad">Example, bad<a class="headerlink" href="#example-bad" title="Permanent link">&para;</a></h5>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>void send(X* x, string_view destination)
{
    auto port = open_port(destination);
    my_mutex.lock();
    // ...
    send(port, x);
    // ...
    my_mutex.unlock();
    close_port(port);
    delete x;
}
</code></pre></div>
<p>In this code, you have to remember to <code>unlock</code>, <code>close_port</code>, and <code>delete</code> on all paths, and do each exactly once.
Further, if any of the code marked <code>...</code> throws an exception, then <code>x</code> is leaked and <code>my_mutex</code> remains locked.</p>
<h5 id="example">Example<a class="headerlink" href="#example" title="Permanent link">&para;</a></h5>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>void send(unique_ptr&lt;X&gt; x, string_view destination)  // x owns the X
{
    Port port{destination};            // port owns the PortHandle
    lock_guard&lt;mutex&gt; guard{my_mutex}; // guard owns the lock
    // ...
    send(port, x);
    // ...
} // automatically unlocks my_mutex and deletes the pointer in x
</code></pre></div>
<p>Now all resource cleanup is automatic, performed once on all paths whether or not there is an exception. As a bonus, the function now advertises that it takes over ownership of the pointer.</p>
<p>What is <code>Port</code>? A handy wrapper that encapsulates the resource:</p>
<div class="language-text highlight"><pre><span></span><code>class Port {
    PortHandle port;
public:
    Port(string_view destination) : port{open_port(destination)} { }
    ~Port() { close_port(port); }
    operator PortHandle() { return port; }

    // port handles can&#39;t usually be cloned, so disable copying and assignment if necessary
    Port(const Port&amp;) = delete;
    Port&amp; operator=(const Port&amp;) = delete;
};
</code></pre></div>
<h5 id="note">Note<a class="headerlink" href="#note" title="Permanent link">&para;</a></h5>
<p>Where a resource is "ill-behaved" in that it isn't represented as a class with a destructor, wrap it in a class or use <a href="#Re-finally"><code>finally</code></a></p>
<p><strong>See also</strong>: <a href="#Re-raii">RAII</a></p>
<h3 id="r2-in-interfaces-use-raw-pointers-to-denote-individual-objects-only"><a name="Rr-use-ptr"></a>R.2: In interfaces, use raw pointers to denote individual objects (only)<a class="headerlink" href="#r2-in-interfaces-use-raw-pointers-to-denote-individual-objects-only" title="Permanent link">&para;</a></h3>
<h5 id="reason_1">Reason<a class="headerlink" href="#reason_1" title="Permanent link">&para;</a></h5>
<p>Arrays are best represented by a container type (e.g., <code>vector</code> (owning)) or a <code>span</code> (non-owning).
Such containers and views hold sufficient information to do range checking.</p>
<h5 id="example-bad_1">Example, bad<a class="headerlink" href="#example-bad_1" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(int* p, int n)   // n is the number of elements in p[]
{
    // ...
    p[2] = 7;   // bad: subscript raw pointer
    // ...
}
</code></pre></div>
<p>The compiler does not read comments, and without reading other code you do not know whether <code>p</code> really points to <code>n</code> elements.
Use a <code>span</code> instead.</p>
<h5 id="example_1">Example<a class="headerlink" href="#example_1" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void g(int* p, int fmt)   // print *p using format #fmt
{
    // ... uses *p and p[0] only ...
}
</code></pre></div>
<h5 id="exception">Exception<a class="headerlink" href="#exception" title="Permanent link">&para;</a></h5>
<p>C-style strings are passed as single pointers to a zero-terminated sequence of characters.
Use <code>zstring</code> rather than <code>char*</code> to indicate that you rely on that convention.</p>
<h5 id="note_1">Note<a class="headerlink" href="#note_1" title="Permanent link">&para;</a></h5>
<p>Many current uses of pointers to a single element could be references.
However, where <code>nullptr</code> is a possible value, a reference might not be a reasonable alternative.</p>
<h5 id="enforcement">Enforcement<a class="headerlink" href="#enforcement" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag pointer arithmetic (including <code>++</code>) on a pointer that is not part of a container, view, or iterator.
  This rule would generate a huge number of false positives if applied to an older code base.</li>
<li>Flag array names passed as simple pointers</li>
</ul>
<h3 id="r3-a-raw-pointer-a-t-is-non-owning"><a name="Rr-ptr"></a>R.3: A raw pointer (a <code>T*</code>) is non-owning<a class="headerlink" href="#r3-a-raw-pointer-a-t-is-non-owning" title="Permanent link">&para;</a></h3>
<h5 id="reason_2">Reason<a class="headerlink" href="#reason_2" title="Permanent link">&para;</a></h5>
<p>There is nothing (in the C++ standard or in most code) to say otherwise and most raw pointers are non-owning.
We want owning pointers identified so that we can reliably and efficiently delete the objects pointed to by owning pointers.</p>
<h5 id="example_2">Example<a class="headerlink" href="#example_2" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    int* p1 = new int{7};           // bad: raw owning pointer
    auto p2 = make_unique&lt;int&gt;(7);  // OK: the int is owned by a unique pointer
    // ...
}
</code></pre></div>
<p>The <code>unique_ptr</code> protects against leaks by guaranteeing the deletion of its object (even in the presence of exceptions). The <code>T*</code> does not.</p>
<h5 id="example_3">Example<a class="headerlink" href="#example_3" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
class X {
public:
    T* p;   // bad: it is unclear whether p is owning or not
    T* q;   // bad: it is unclear whether q is owning or not
    // ...
};
</code></pre></div>
<p>We can fix that problem by making ownership explicit:</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
class X2 {
public:
    owner&lt;T*&gt; p;  // OK: p is owning
    T* q;         // OK: q is not owning
    // ...
};
</code></pre></div>
<h5 id="exception_1">Exception<a class="headerlink" href="#exception_1" title="Permanent link">&para;</a></h5>
<p>A major class of exception is legacy code, especially code that must remain compilable as C or interface with C and C-style C++ through ABIs.
The fact that there are billions of lines of code that violate this rule against owning <code>T*</code>s cannot be ignored.
We'd love to see program transformation tools turning 20-year-old "legacy" code into shiny modern code,
we encourage the development, deployment and use of such tools,
we hope the guidelines will help the development of such tools,
and we even contributed (and contribute) to the research and development in this area.
However, it will take time: "legacy code" is generated faster than we can renovate old code, and so it will be for a few years.</p>
<p>This code cannot all be rewritten (even assuming good code transformation software), especially not soon.
This problem cannot be solved (at scale) by transforming all owning pointers to <code>unique_ptr</code>s and <code>shared_ptr</code>s,
partly because we need/use owning "raw pointers" as well as simple pointers in the implementation of our fundamental resource handles.
For example, common <code>vector</code> implementations have one owning pointer and two non-owning pointers.
Many ABIs (and essentially all interfaces to C code) use <code>T*</code>s, some of them owning.
Some interfaces cannot be simply annotated with <code>owner</code> because they need to remain compilable as C
(although this would be a rare good use for a macro, that expands to <code>owner</code> in C++ mode only).</p>
<h5 id="note_2">Note<a class="headerlink" href="#note_2" title="Permanent link">&para;</a></h5>
<p><code>owner&lt;T*&gt;</code> has no default semantics beyond <code>T*</code>. It can be used without changing any code using it and without affecting ABIs.
It is simply an indicator to programmers and analysis tools.
For example, if an <code>owner&lt;T*&gt;</code> is a member of a class, that class better have a destructor that <code>delete</code>s it.</p>
<h5 id="example-bad_2">Example, bad<a class="headerlink" href="#example-bad_2" title="Permanent link">&para;</a></h5>
<p>Returning a (raw) pointer imposes a lifetime management uncertainty on the caller; that is, who deletes the pointed-to object?</p>
<div class="language-text highlight"><pre><span></span><code>Gadget* make_gadget(int n)
{
    auto p = new Gadget{n};
    // ...
    return p;
}

void caller(int n)
{
    auto p = make_gadget(n);   // remember to delete p
    // ...
    delete p;
}
</code></pre></div>
<p>In addition to suffering from the problem of <a href="#Rp-leak">leak</a>, this adds a spurious allocation and deallocation operation, and is needlessly verbose. If Gadget is cheap to move out of a function (i.e., is small or has an efficient move operation), just return it "by value" (see <a href="#Rf-out">"out" return values</a>):</p>
<div class="language-text highlight"><pre><span></span><code>Gadget make_gadget(int n)
{
    Gadget g{n};
    // ...
    return g;
}
</code></pre></div>
<h5 id="note_3">Note<a class="headerlink" href="#note_3" title="Permanent link">&para;</a></h5>
<p>This rule applies to factory functions.</p>
<h5 id="note_4">Note<a class="headerlink" href="#note_4" title="Permanent link">&para;</a></h5>
<p>If pointer semantics are required (e.g., because the return type needs to refer to a base class of a class hierarchy (an interface)), return a "smart pointer."</p>
<h5 id="enforcement_1">Enforcement<a class="headerlink" href="#enforcement_1" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Warn on <code>delete</code> of a raw pointer that is not an <code>owner&lt;T&gt;</code>.</li>
<li>(Moderate) Warn on failure to either <code>reset</code> or explicitly <code>delete</code> an <code>owner&lt;T&gt;</code> pointer on every code path.</li>
<li>(Simple) Warn if the return value of <code>new</code> is assigned to a raw pointer.</li>
<li>(Simple) Warn if a function returns an object that was allocated within the function but has a move constructor.
  Suggest considering returning it by value instead.</li>
</ul>
<h3 id="r4-a-raw-reference-a-t-is-non-owning"><a name="Rr-ref"></a>R.4: A raw reference (a <code>T&amp;</code>) is non-owning<a class="headerlink" href="#r4-a-raw-reference-a-t-is-non-owning" title="Permanent link">&para;</a></h3>
<h5 id="reason_3">Reason<a class="headerlink" href="#reason_3" title="Permanent link">&para;</a></h5>
<p>There is nothing (in the C++ standard or in most code) to say otherwise and most raw references are non-owning.
We want owners identified so that we can reliably and efficiently delete the objects pointed to by owning pointers.</p>
<h5 id="example_4">Example<a class="headerlink" href="#example_4" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    int&amp; r = *new int{7};  // bad: raw owning reference
    // ...
    delete &amp;r;             // bad: violated the rule against deleting raw pointers
}
</code></pre></div>
<p><strong>See also</strong>: <a href="#Rr-ptr">The raw pointer rule</a></p>
<h5 id="enforcement_2">Enforcement<a class="headerlink" href="#enforcement_2" title="Permanent link">&para;</a></h5>
<p>See <a href="#Rr-ptr">the raw pointer rule</a></p>
<h3 id="r5-prefer-scoped-objects-dont-heap-allocate-unnecessarily"><a name="Rr-scoped"></a>R.5: Prefer scoped objects, don't heap-allocate unnecessarily<a class="headerlink" href="#r5-prefer-scoped-objects-dont-heap-allocate-unnecessarily" title="Permanent link">&para;</a></h3>
<h5 id="reason_4">Reason<a class="headerlink" href="#reason_4" title="Permanent link">&para;</a></h5>
<p>A scoped object is a local object, a global object, or a member.
This implies that there is no separate allocation and deallocation cost in excess of that already used for the containing scope or object.
The members of a scoped object are themselves scoped and the scoped object's constructor and destructor manage the members' lifetimes.</p>
<h5 id="example_5">Example<a class="headerlink" href="#example_5" title="Permanent link">&para;</a></h5>
<p>The following example is inefficient (because it has unnecessary allocation and deallocation), vulnerable to exception throws and returns in the <code>...</code> part (leading to leaks), and verbose:</p>
<div class="language-text highlight"><pre><span></span><code>void f(int n)
{
    auto p = new Gadget{n};
    // ...
    delete p;
}
</code></pre></div>
<p>Instead, use a local variable:</p>
<div class="language-text highlight"><pre><span></span><code>void f(int n)
{
    Gadget g{n};
    // ...
}
</code></pre></div>
<h5 id="enforcement_3">Enforcement<a class="headerlink" href="#enforcement_3" title="Permanent link">&para;</a></h5>
<ul>
<li>(Moderate) Warn if an object is allocated and then deallocated on all paths within a function. Suggest it should be a local stack object instead.</li>
<li>(Simple) Warn if a local <code>Unique_pointer</code> or <code>Shared_pointer</code> that is not moved, copied, reassigned or <code>reset</code> before its lifetime ends is not declared <code>const</code>.
Exception: Do not produce such a warning on a local <code>Unique_pointer</code> to an unbounded array. (See below.)</li>
</ul>
<h5 id="exception_2">Exception<a class="headerlink" href="#exception_2" title="Permanent link">&para;</a></h5>
<p>If your stack space is limited, it is OK to create a local <code>const unique_ptr&lt;BigObject&gt;</code> to store the object on the heap instead of the stack.</p>
<h3 id="r6-avoid-non-const-global-variables"><a name="Rr-global"></a>R.6: Avoid non-<code>const</code> global variables<a class="headerlink" href="#r6-avoid-non-const-global-variables" title="Permanent link">&para;</a></h3>
<p>See <a href="#Ri-global">I.2</a></p>
<h2 id="ralloc-allocation-and-deallocation"><a name="SS-alloc"></a>R.alloc: Allocation and deallocation<a class="headerlink" href="#ralloc-allocation-and-deallocation" title="Permanent link">&para;</a></h2>
<h3 id="r10-avoid-malloc-and-free"><a name="Rr-mallocfree"></a>R.10: Avoid <code>malloc()</code> and <code>free()</code><a class="headerlink" href="#r10-avoid-malloc-and-free" title="Permanent link">&para;</a></h3>
<h5 id="reason_5">Reason<a class="headerlink" href="#reason_5" title="Permanent link">&para;</a></h5>
<p><code>malloc()</code> and <code>free()</code> do not support construction and destruction, and do not mix well with <code>new</code> and <code>delete</code>.</p>
<h5 id="example_6">Example<a class="headerlink" href="#example_6" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Record {
    int id;
    string name;
    // ...
};

void use()
{
    // p1 might be nullptr
    // *p1 is not initialized; in particular,
    // that string isn&#39;t a string, but a string-sized bag of bits
    Record* p1 = static_cast&lt;Record*&gt;(malloc(sizeof(Record)));

    auto p2 = new Record;

    // unless an exception is thrown, *p2 is default initialized
    auto p3 = new(nothrow) Record;
    // p3 might be nullptr; if not, *p3 is default initialized

    // ...

    delete p1;    // error: cannot delete object allocated by malloc()
    free(p2);    // error: cannot free() object allocated by new
}
</code></pre></div>
<p>In some implementations that <code>delete</code> and that <code>free()</code> might work, or maybe they will cause run-time errors.</p>
<h5 id="exception_3">Exception<a class="headerlink" href="#exception_3" title="Permanent link">&para;</a></h5>
<p>There are applications and sections of code where exceptions are not acceptable.
Some of the best such examples are in life-critical hard-real-time code.
Beware that many bans on exception use are based on superstition (bad)
or by concerns for older code bases with unsystematic resource management (unfortunately, but sometimes necessary).
In such cases, consider the <code>nothrow</code> versions of <code>new</code>.</p>
<h5 id="enforcement_4">Enforcement<a class="headerlink" href="#enforcement_4" title="Permanent link">&para;</a></h5>
<p>Flag explicit use of <code>malloc</code> and <code>free</code>.</p>
<h3 id="r11-avoid-calling-new-and-delete-explicitly"><a name="Rr-newdelete"></a>R.11: Avoid calling <code>new</code> and <code>delete</code> explicitly<a class="headerlink" href="#r11-avoid-calling-new-and-delete-explicitly" title="Permanent link">&para;</a></h3>
<h5 id="reason_6">Reason<a class="headerlink" href="#reason_6" title="Permanent link">&para;</a></h5>
<p>The pointer returned by <code>new</code> should belong to a resource handle (that can call <code>delete</code>).
If the pointer returned by <code>new</code> is assigned to a plain/naked pointer, the object can be leaked.</p>
<h5 id="note_5">Note<a class="headerlink" href="#note_5" title="Permanent link">&para;</a></h5>
<p>In a large program, a naked <code>delete</code> (that is a <code>delete</code> in application code, rather than part of code devoted to resource management)
is a likely bug: if you have N <code>delete</code>s, how can you be certain that you don't need N+1 or N-1?
The bug might be latent: it might emerge only during maintenance.
If you have a naked <code>new</code>, you probably need a naked <code>delete</code> somewhere, so you probably have a bug.</p>
<h5 id="enforcement_5">Enforcement<a class="headerlink" href="#enforcement_5" title="Permanent link">&para;</a></h5>
<p>(Simple) Warn on any explicit use of <code>new</code> and <code>delete</code>. Suggest using <code>make_unique</code> instead.</p>
<h3 id="r12-immediately-give-the-result-of-an-explicit-resource-allocation-to-a-manager-object"><a name="Rr-immediate-alloc"></a>R.12: Immediately give the result of an explicit resource allocation to a manager object<a class="headerlink" href="#r12-immediately-give-the-result-of-an-explicit-resource-allocation-to-a-manager-object" title="Permanent link">&para;</a></h3>
<h5 id="reason_7">Reason<a class="headerlink" href="#reason_7" title="Permanent link">&para;</a></h5>
<p>If you don't, an exception or a return might lead to a leak.</p>
<h5 id="example-bad_3">Example, bad<a class="headerlink" href="#example-bad_3" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void func(const string&amp; name)
{
    FILE* f = fopen(name, &quot;r&quot;);            // open the file
    vector&lt;char&gt; buf(1024);
    auto _ = finally([f] { fclose(f); });  // remember to close the file
    // ...
}
</code></pre></div>
<p>The allocation of <code>buf</code> might fail and leak the file handle.</p>
<h5 id="example_7">Example<a class="headerlink" href="#example_7" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void func(const string&amp; name)
{
    ifstream f{name};   // open the file
    vector&lt;char&gt; buf(1024);
    // ...
}
</code></pre></div>
<p>The use of the file handle (in <code>ifstream</code>) is simple, efficient, and safe.</p>
<h5 id="enforcement_6">Enforcement<a class="headerlink" href="#enforcement_6" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag explicit allocations used to initialize pointers (problem: how many direct resource allocations can we recognize?)</li>
</ul>
<h3 id="r13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement"><a name="Rr-single-alloc"></a>R.13: Perform at most one explicit resource allocation in a single expression statement<a class="headerlink" href="#r13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement" title="Permanent link">&para;</a></h3>
<h5 id="reason_8">Reason<a class="headerlink" href="#reason_8" title="Permanent link">&para;</a></h5>
<p>If you perform two explicit resource allocations in one statement, you could leak resources because the order of evaluation of many subexpressions, including function arguments, is unspecified.</p>
<h5 id="example_8">Example<a class="headerlink" href="#example_8" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void fun(shared_ptr&lt;Widget&gt; sp1, shared_ptr&lt;Widget&gt; sp2);
</code></pre></div>
<p>This <code>fun</code> can be called like this:</p>
<div class="language-text highlight"><pre><span></span><code>// BAD: potential leak
fun(shared_ptr&lt;Widget&gt;(new Widget(a, b)), shared_ptr&lt;Widget&gt;(new Widget(c, d)));
</code></pre></div>
<p>This is exception-unsafe because the compiler might reorder the two expressions building the function's two arguments.
In particular, the compiler can interleave execution of the two expressions:
Memory allocation (by calling <code>operator new</code>) could be done first for both objects, followed by attempts to call the two <code>Widget</code> constructors.
If one of the constructor calls throws an exception, then the other object's memory will never be released!</p>
<p>This subtle problem has a simple solution: Never perform more than one explicit resource allocation in a single expression statement.
For example:</p>
<div class="language-text highlight"><pre><span></span><code>shared_ptr&lt;Widget&gt; sp1(new Widget(a, b)); // Better, but messy
fun(sp1, new Widget(c, d));
</code></pre></div>
<p>The best solution is to avoid explicit allocation entirely use factory functions that return owning objects:</p>
<div class="language-text highlight"><pre><span></span><code>fun(make_shared&lt;Widget&gt;(a, b), make_shared&lt;Widget&gt;(c, d)); // Best
</code></pre></div>
<p>Write your own factory wrapper if there is not one already.</p>
<h5 id="enforcement_7">Enforcement<a class="headerlink" href="#enforcement_7" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag expressions with multiple explicit resource allocations (problem: how many direct resource allocations can we recognize?)</li>
</ul>
<h3 id="r14-avoid-parameters-prefer-span"><a name="Rr-ap"></a>R.14: Avoid <code>[]</code> parameters, prefer <code>span</code><a class="headerlink" href="#r14-avoid-parameters-prefer-span" title="Permanent link">&para;</a></h3>
<h5 id="reason_9">Reason<a class="headerlink" href="#reason_9" title="Permanent link">&para;</a></h5>
<p>An array decays to a pointer, thereby losing its size, opening the opportunity for range errors.
Use <code>span</code> to preserve size information.</p>
<h5 id="example_9">Example<a class="headerlink" href="#example_9" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(int[]);          // not recommended

void f(int*);           // not recommended for multiple objects
                        // (a pointer should point to a single object, do not subscript)

void f(gsl::span&lt;int&gt;); // good, recommended
</code></pre></div>
<h5 id="enforcement_8">Enforcement<a class="headerlink" href="#enforcement_8" title="Permanent link">&para;</a></h5>
<p>Flag <code>[]</code> parameters. Use <code>span</code> instead.</p>
<h3 id="r15-always-overload-matched-allocationdeallocation-pairs"><a name="Rr-pair"></a>R.15: Always overload matched allocation/deallocation pairs<a class="headerlink" href="#r15-always-overload-matched-allocationdeallocation-pairs" title="Permanent link">&para;</a></h3>
<h5 id="reason_10">Reason<a class="headerlink" href="#reason_10" title="Permanent link">&para;</a></h5>
<p>Otherwise you get mismatched operations and chaos.</p>
<h5 id="example_10">Example<a class="headerlink" href="#example_10" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class X {
    // ...
    void* operator new(size_t s);
    void operator delete(void*);
    // ...
};
</code></pre></div>
<h5 id="note_6">Note<a class="headerlink" href="#note_6" title="Permanent link">&para;</a></h5>
<p>If you want memory that cannot be deallocated, <code>=delete</code> the deallocation operation.
Don't leave it undeclared.</p>
<h5 id="enforcement_9">Enforcement<a class="headerlink" href="#enforcement_9" title="Permanent link">&para;</a></h5>
<p>Flag incomplete pairs.</p>
<h2 id="rsmart-smart-pointers"><a name="SS-smart"></a>R.smart: Smart pointers<a class="headerlink" href="#rsmart-smart-pointers" title="Permanent link">&para;</a></h2>
<h3 id="r20-use-unique_ptr-or-shared_ptr-to-represent-ownership"><a name="Rr-owner"></a>R.20: Use <code>unique_ptr</code> or <code>shared_ptr</code> to represent ownership<a class="headerlink" href="#r20-use-unique_ptr-or-shared_ptr-to-represent-ownership" title="Permanent link">&para;</a></h3>
<h5 id="reason_11">Reason<a class="headerlink" href="#reason_11" title="Permanent link">&para;</a></h5>
<p>They can prevent resource leaks.</p>
<h5 id="example_11">Example<a class="headerlink" href="#example_11" title="Permanent link">&para;</a></h5>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    X* p1 { new X };              // bad, p1 will leak
    auto p2 = make_unique&lt;X&gt;();   // good, unique ownership
    auto p3 = make_shared&lt;X&gt;();   // good, shared ownership
}
</code></pre></div>
<p>This will leak the object used to initialize <code>p1</code> (only).</p>
<h5 id="enforcement_10">Enforcement<a class="headerlink" href="#enforcement_10" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Warn if the return value of <code>new</code> is assigned to a raw pointer.</li>
<li>(Simple) Warn if the result of a function returning a raw owning pointer is assigned to a raw pointer.</li>
</ul>
<h3 id="r21-prefer-unique_ptr-over-shared_ptr-unless-you-need-to-share-ownership"><a name="Rr-unique"></a>R.21: Prefer <code>unique_ptr</code> over <code>shared_ptr</code> unless you need to share ownership<a class="headerlink" href="#r21-prefer-unique_ptr-over-shared_ptr-unless-you-need-to-share-ownership" title="Permanent link">&para;</a></h3>
<h5 id="reason_12">Reason<a class="headerlink" href="#reason_12" title="Permanent link">&para;</a></h5>
<p>A <code>unique_ptr</code> is conceptually simpler and more predictable (you know when destruction happens) and faster (you don't implicitly maintain a use count).</p>
<h5 id="example-bad_4">Example, bad<a class="headerlink" href="#example-bad_4" title="Permanent link">&para;</a></h5>
<p>This needlessly adds and maintains a reference count.</p>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    shared_ptr&lt;Base&gt; base = make_shared&lt;Derived&gt;();
    // use base locally, without copying it -- refcount never exceeds 1
} // destroy base
</code></pre></div>
<h5 id="example_12">Example<a class="headerlink" href="#example_12" title="Permanent link">&para;</a></h5>
<p>This is more efficient:</p>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    unique_ptr&lt;Base&gt; base = make_unique&lt;Derived&gt;();
    // use base locally
} // destroy base
</code></pre></div>
<h5 id="enforcement_11">Enforcement<a class="headerlink" href="#enforcement_11" title="Permanent link">&para;</a></h5>
<p>(Simple) Warn if a function uses a <code>Shared_pointer</code> with an object allocated within the function, but never returns the <code>Shared_pointer</code> or passes it to a function requiring a <code>Shared_pointer</code>. Suggest using <code>unique_ptr</code> instead.</p>
<h3 id="r22-use-make_shared-to-make-shared_ptrs"><a name="Rr-make_shared"></a>R.22: Use <code>make_shared()</code> to make <code>shared_ptr</code>s<a class="headerlink" href="#r22-use-make_shared-to-make-shared_ptrs" title="Permanent link">&para;</a></h3>
<h5 id="reason_13">Reason<a class="headerlink" href="#reason_13" title="Permanent link">&para;</a></h5>
<p><code>make_shared</code> gives a more concise statement of the construction.
It also gives an opportunity to eliminate a separate allocation for the reference counts, by placing the <code>shared_ptr</code>'s use counts next to its object.
It also ensures exception safety in complex expressions (in pre-C++17 code).</p>
<h5 id="example_13">Example<a class="headerlink" href="#example_13" title="Permanent link">&para;</a></h5>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>shared_ptr&lt;X&gt; p1 { new X{2} }; // bad
auto p = make_shared&lt;X&gt;(2);    // good
</code></pre></div>
<p>The <code>make_shared()</code> version mentions <code>X</code> only once, so it is usually shorter (as well as faster) than the version with the explicit <code>new</code>.</p>
<h5 id="enforcement_12">Enforcement<a class="headerlink" href="#enforcement_12" title="Permanent link">&para;</a></h5>
<p>(Simple) Warn if a <code>shared_ptr</code> is constructed from the result of <code>new</code> rather than <code>make_shared</code>.</p>
<h3 id="r23-use-make_unique-to-make-unique_ptrs"><a name="Rr-make_unique"></a>R.23: Use <code>make_unique()</code> to make <code>unique_ptr</code>s<a class="headerlink" href="#r23-use-make_unique-to-make-unique_ptrs" title="Permanent link">&para;</a></h3>
<h5 id="reason_14">Reason<a class="headerlink" href="#reason_14" title="Permanent link">&para;</a></h5>
<p><code>make_unique</code> gives a more concise statement of the construction.
It also ensures exception safety in complex expressions (in pre-C++17 code).</p>
<h5 id="example_14">Example<a class="headerlink" href="#example_14" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>unique_ptr&lt;Foo&gt; p {new Foo{7}};    // OK: but repetitive

auto q = make_unique&lt;Foo&gt;(7);      // Better: no repetition of Foo
</code></pre></div>
<h5 id="enforcement_13">Enforcement<a class="headerlink" href="#enforcement_13" title="Permanent link">&para;</a></h5>
<p>(Simple) Warn if a <code>unique_ptr</code> is constructed from the result of <code>new</code> rather than <code>make_unique</code>.</p>
<h3 id="r24-use-stdweak_ptr-to-break-cycles-of-shared_ptrs"><a name="Rr-weak_ptr"></a>R.24: Use <code>std::weak_ptr</code> to break cycles of <code>shared_ptr</code>s<a class="headerlink" href="#r24-use-stdweak_ptr-to-break-cycles-of-shared_ptrs" title="Permanent link">&para;</a></h3>
<h5 id="reason_15">Reason<a class="headerlink" href="#reason_15" title="Permanent link">&para;</a></h5>
<p><code>shared_ptr</code>'s rely on use counting and the use count for a cyclic structure never goes to zero, so we need a mechanism to
be able to destroy a cyclic structure.</p>
<h5 id="example_15">Example<a class="headerlink" href="#example_15" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>#include &lt;memory&gt;

class bar;

class foo {
public:
  explicit foo(const std::shared_ptr&lt;bar&gt;&amp; forward_reference)
    : forward_reference_(forward_reference)
  { }
private:
  std::shared_ptr&lt;bar&gt; forward_reference_;
};

class bar {
public:
  explicit bar(const std::weak_ptr&lt;foo&gt;&amp; back_reference)
    : back_reference_(back_reference)
  { }
  void do_something()
  {
    if (auto shared_back_reference = back_reference_.lock()) {
      // Use *shared_back_reference
    }
  }
private:
  std::weak_ptr&lt;foo&gt; back_reference_;
};
</code></pre></div>
<h5 id="note_7">Note<a class="headerlink" href="#note_7" title="Permanent link">&para;</a></h5>
<p>??? (HS: A lot of people say "to break cycles", while I think "temporary shared ownership" is more to the point.)
???(BS: breaking cycles is what you must do; temporarily sharing ownership is how you do it.
You could "temporarily share ownership" simply by using another <code>shared_ptr</code>.)</p>
<h5 id="enforcement_14">Enforcement<a class="headerlink" href="#enforcement_14" title="Permanent link">&para;</a></h5>
<p>??? probably impossible. If we could statically detect cycles, we wouldn't need <code>weak_ptr</code></p>
<h3 id="r30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics"><a name="Rr-smartptrparam"></a>R.30: Take smart pointers as parameters only to explicitly express lifetime semantics<a class="headerlink" href="#r30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics" title="Permanent link">&para;</a></h3>
<p>See <a href="#Rf-smart">F.7</a>.</p>
<h3 id="r31-if-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std"><a name="Rr-smart"></a>R.31: If you have non-<code>std</code> smart pointers, follow the basic pattern from <code>std</code><a class="headerlink" href="#r31-if-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std" title="Permanent link">&para;</a></h3>
<h5 id="reason_16">Reason<a class="headerlink" href="#reason_16" title="Permanent link">&para;</a></h5>
<p>The rules in the following section also work for other kinds of third-party and custom smart pointers and are very useful for diagnosing common smart pointer errors that cause performance and correctness problems.
You want the rules to work on all the smart pointers you use.</p>
<p>Any type (including primary template or specialization) that overloads unary <code>*</code> and <code>-&gt;</code> is considered a smart pointer:</p>
<ul>
<li>If it is copyable, it is recognized as a reference-counted <code>shared_ptr</code>.</li>
<li>If it is not copyable, it is recognized as a unique <code>unique_ptr</code>.</li>
</ul>
<h5 id="example-bad_5">Example, bad<a class="headerlink" href="#example-bad_5" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>// use Boost&#39;s intrusive_ptr
#include &lt;boost/intrusive_ptr.hpp&gt;
void f(boost::intrusive_ptr&lt;widget&gt; p)  // error under rule &#39;sharedptrparam&#39;
{
    p-&gt;foo();
}

// use Microsoft&#39;s CComPtr
#include &lt;atlbase.h&gt;
void f(CComPtr&lt;widget&gt; p)               // error under rule &#39;sharedptrparam&#39;
{
    p-&gt;foo();
}
</code></pre></div>
<p>Both cases are an error under the <a href="#Rr-smartptrparam"><code>sharedptrparam</code> guideline</a>:
<code>p</code> is a <code>Shared_pointer</code>, but nothing about its sharedness is used here and passing it by value is a silent pessimization;
these functions should accept a smart pointer only if they need to participate in the widget's lifetime management. Otherwise they should accept a <code>widget*</code>, if it can be <code>nullptr</code>. Otherwise, and ideally, the function should accept a <code>widget&amp;</code>.
These smart pointers match the <code>Shared_pointer</code> concept, so these guideline enforcement rules work on them out of the box and expose this common pessimization.</p>
<h3 id="r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget"><a name="Rr-uniqueptrparam"></a>R.32: Take a <code>unique_ptr&lt;widget&gt;</code> parameter to express that a function assumes ownership of a <code>widget</code><a class="headerlink" href="#r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget" title="Permanent link">&para;</a></h3>
<h5 id="reason_17">Reason<a class="headerlink" href="#reason_17" title="Permanent link">&para;</a></h5>
<p>Using <code>unique_ptr</code> in this way both documents and enforces the function call's ownership transfer.</p>
<h5 id="example_16">Example<a class="headerlink" href="#example_16" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void sink(unique_ptr&lt;widget&gt;); // takes ownership of the widget

void uses(widget*);            // just uses the widget
</code></pre></div>
<h5 id="enforcement_15">Enforcement<a class="headerlink" href="#enforcement_15" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Warn if a function takes a <code>Unique_pointer&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
</ul>
<h3 id="r33-take-a-unique_ptrwidget-parameter-to-express-that-a-function-reseats-the-widget"><a name="Rr-reseat"></a>R.33: Take a <code>unique_ptr&lt;widget&gt;&amp;</code> parameter to express that a function reseats the <code>widget</code><a class="headerlink" href="#r33-take-a-unique_ptrwidget-parameter-to-express-that-a-function-reseats-the-widget" title="Permanent link">&para;</a></h3>
<h5 id="reason_18">Reason<a class="headerlink" href="#reason_18" title="Permanent link">&para;</a></h5>
<p>Using <code>unique_ptr</code> in this way both documents and enforces the function call's reseating semantics.</p>
<h5 id="note_8">Note<a class="headerlink" href="#note_8" title="Permanent link">&para;</a></h5>
<p>"reseat" means "making a pointer or a smart pointer refer to a different object."</p>
<h5 id="example_17">Example<a class="headerlink" href="#example_17" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void reseat(unique_ptr&lt;widget&gt;&amp;); // &quot;will&quot; or &quot;might&quot; reseat pointer
</code></pre></div>
<h5 id="enforcement_16">Enforcement<a class="headerlink" href="#enforcement_16" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Warn if a function takes a <code>Unique_pointer&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
</ul>
<h3 id="r34-take-a-shared_ptrwidget-parameter-to-express-shared-ownership"><a name="Rr-sharedptrparam-owner"></a>R.34: Take a <code>shared_ptr&lt;widget&gt;</code> parameter to express shared ownership<a class="headerlink" href="#r34-take-a-shared_ptrwidget-parameter-to-express-shared-ownership" title="Permanent link">&para;</a></h3>
<h5 id="reason_19">Reason<a class="headerlink" href="#reason_19" title="Permanent link">&para;</a></h5>
<p>This makes the function's ownership sharing explicit.</p>
<h5 id="example-good">Example, good<a class="headerlink" href="#example-good" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class WidgetUser
{
public:
    // WidgetUser will share ownership of the widget
    explicit WidgetUser(std::shared_ptr&lt;widget&gt; w) noexcept:
        m_widget{std::move(w)} {}
    // ...
private:
    std::shared_ptr&lt;widget&gt; m_widget;
};
</code></pre></div>
<h5 id="enforcement_17">Enforcement<a class="headerlink" href="#enforcement_17" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Warn if a function takes a <code>Shared_pointer&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_pointer&lt;T&gt;</code> by value or by reference to <code>const</code> and does not copy or move it to another <code>Shared_pointer</code> on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_pointer&lt;T&gt;</code> by rvalue reference. Suggesting taking it by value instead.</li>
</ul>
<h3 id="r35-take-a-shared_ptrwidget-parameter-to-express-that-a-function-might-reseat-the-shared-pointer"><a name="Rr-sharedptrparam"></a>R.35: Take a <code>shared_ptr&lt;widget&gt;&amp;</code> parameter to express that a function might reseat the shared pointer<a class="headerlink" href="#r35-take-a-shared_ptrwidget-parameter-to-express-that-a-function-might-reseat-the-shared-pointer" title="Permanent link">&para;</a></h3>
<h5 id="reason_20">Reason<a class="headerlink" href="#reason_20" title="Permanent link">&para;</a></h5>
<p>This makes the function's reseating explicit.</p>
<h5 id="note_9">Note<a class="headerlink" href="#note_9" title="Permanent link">&para;</a></h5>
<p>"reseat" means "making a reference or a smart pointer refer to a different object."</p>
<h5 id="example-good_1">Example, good<a class="headerlink" href="#example-good_1" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void ChangeWidget(std::shared_ptr&lt;widget&gt;&amp; w)
{
    // This will change the callers widget
    w = std::make_shared&lt;widget&gt;(widget{});
}
</code></pre></div>
<h5 id="enforcement_18">Enforcement<a class="headerlink" href="#enforcement_18" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Warn if a function takes a <code>Shared_pointer&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_pointer&lt;T&gt;</code> by value or by reference to <code>const</code> and does not copy or move it to another <code>Shared_pointer</code> on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_pointer&lt;T&gt;</code> by rvalue reference. Suggesting taking it by value instead.</li>
</ul>
<h3 id="r36-take-a-const-shared_ptrwidget-parameter-to-express-that-it-might-retain-a-reference-count-to-the-object"><a name="Rr-sharedptrparam-const"></a>R.36: Take a <code>const shared_ptr&lt;widget&gt;&amp;</code> parameter to express that it might retain a reference count to the object ???<a class="headerlink" href="#r36-take-a-const-shared_ptrwidget-parameter-to-express-that-it-might-retain-a-reference-count-to-the-object" title="Permanent link">&para;</a></h3>
<h5 id="reason_21">Reason<a class="headerlink" href="#reason_21" title="Permanent link">&para;</a></h5>
<p>This makes the function's ??? explicit.</p>
<h5 id="example-good_2">Example, good<a class="headerlink" href="#example-good_2" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void share(shared_ptr&lt;widget&gt;);            // share -- &quot;will&quot; retain refcount

void reseat(shared_ptr&lt;widget&gt;&amp;);          // &quot;might&quot; reseat ptr

void may_share(const shared_ptr&lt;widget&gt;&amp;); // &quot;might&quot; retain refcount
</code></pre></div>
<h5 id="enforcement_19">Enforcement<a class="headerlink" href="#enforcement_19" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Warn if a function takes a <code>Shared_pointer&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_pointer&lt;T&gt;</code> by value or by reference to <code>const</code> and does not copy or move it to another <code>Shared_pointer</code> on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_pointer&lt;T&gt;</code> by rvalue reference. Suggesting taking it by value instead.</li>
</ul>
<h3 id="r37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer"><a name="Rr-smartptrget"></a>R.37: Do not pass a pointer or reference obtained from an aliased smart pointer<a class="headerlink" href="#r37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer" title="Permanent link">&para;</a></h3>
<h5 id="reason_22">Reason<a class="headerlink" href="#reason_22" title="Permanent link">&para;</a></h5>
<p>Violating this rule is the number one cause of losing reference counts and finding yourself with a dangling pointer.
Functions should prefer to pass raw pointers and references down call chains.
At the top of the call tree where you obtain the raw pointer or reference from a smart pointer that keeps the object alive.
You need to be sure that the smart pointer cannot inadvertently be reset or reassigned from within the call tree below.</p>
<h5 id="note_10">Note<a class="headerlink" href="#note_10" title="Permanent link">&para;</a></h5>
<p>To do this, sometimes you need to take a local copy of a smart pointer, which firmly keeps the object alive for the duration of the function and the call tree.</p>
<h5 id="example_18">Example<a class="headerlink" href="#example_18" title="Permanent link">&para;</a></h5>
<p>Consider this code:</p>
<div class="language-text highlight"><pre><span></span><code>// global (static or heap), or aliased local ...
shared_ptr&lt;widget&gt; g_p = ...;

void f(widget&amp; w)
{
    g();
    use(w);  // A
}

void g()
{
    g_p = ...; // oops, if this was the last shared_ptr to that widget, destroys the widget
}
</code></pre></div>
<p>The following should not pass code review:</p>
<div class="language-text highlight"><pre><span></span><code>void my_code()
{
    // BAD: passing pointer or reference obtained from a non-local smart pointer
    //      that could be inadvertently reset somewhere inside f or its callees
    f(*g_p);

    // BAD: same reason, just passing it as a &quot;this&quot; pointer
    g_p-&gt;func();
}
</code></pre></div>
<p>The fix is simple -- take a local copy of the pointer to "keep a ref count" for your call tree:</p>
<div class="language-text highlight"><pre><span></span><code>void my_code()
{
    // cheap: 1 increment covers this entire function and all the call trees below us
    auto pin = g_p;

    // GOOD: passing pointer or reference obtained from a local unaliased smart pointer
    f(*pin);

    // GOOD: same reason
    pin-&gt;func();
}
</code></pre></div>
<h5 id="enforcement_20">Enforcement<a class="headerlink" href="#enforcement_20" title="Permanent link">&para;</a></h5>
<ul>
<li>(Simple) Warn if a pointer or reference obtained from a smart pointer variable (<code>Unique_pointer</code> or <code>Shared_pointer</code>) that is non-local, or that is local but potentially aliased, is used in a function call. If the smart pointer is a <code>Shared_pointer</code> then suggest taking a local copy of the smart pointer and obtain a pointer or reference from that instead.</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["content.code.copy"], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.f1b6f286.min.js"></script>
      
        <script src="../js/open_in_new_tab.js"></script>
      
    
  </body>
</html>
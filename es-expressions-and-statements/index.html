
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../r-resource-management/">
      
      
        <link rel="next" href="../per-performance/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.15">
    
    
      
        <title>ES: Expressions and statements - C++ Core Guidelines</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.342714a4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#es-expressions-and-statements-s-expr" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="C++ Core Guidelines" class="md-header__button md-logo" aria-label="C++ Core Guidelines" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            C++ Core Guidelines
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              ES: Expressions and statements
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/xxrjun/CppCoreGuidelines" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    xxrjun/CppCoreGuidelines
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="C++ Core Guidelines" class="md-nav__button md-logo" aria-label="C++ Core Guidelines" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    C++ Core Guidelines
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/xxrjun/CppCoreGuidelines" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    xxrjun/CppCoreGuidelines
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../NOTICE/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    NOTICE
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../abstract/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Abstract
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../in-introduction/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    In: Introduction
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../p-philosophy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    P: Philosophy
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../i-interfaces/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    I: Interfaces
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../f-functions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    F: Functions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../c-classes-and-class-hierarchies/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    C: Classes and class hierarchies
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../enum-enumerations/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Enum: Enumerations
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../r-resource-management/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    R: Resource management
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    ES: Expressions and statements
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    ES: Expressions and statements
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#es1-prefer-the-standard-library-to-other-libraries-and-to-handcrafted-code" class="md-nav__link">
    <span class="md-ellipsis">
      ES.1: Prefer the standard library to other libraries and to "handcrafted code"
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#es2-prefer-suitable-abstractions-to-direct-use-of-language-features" class="md-nav__link">
    <span class="md-ellipsis">
      ES.2: Prefer suitable abstractions to direct use of language features
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#es3-dont-repeat-yourself-avoid-redundant-code" class="md-nav__link">
    <span class="md-ellipsis">
      ES.3: Don't repeat yourself, avoid redundant code
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esdcl-declarations" class="md-nav__link">
    <span class="md-ellipsis">
      ES.dcl: Declarations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ES.dcl: Declarations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es5-keep-scopes-small" class="md-nav__link">
    <span class="md-ellipsis">
      ES.5: Keep scopes small
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es6-declare-names-in-for-statement-initializers-and-conditions-to-limit-scope" class="md-nav__link">
    <span class="md-ellipsis">
      ES.6: Declare names in for-statement initializers and conditions to limit scope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es7-keep-common-and-local-names-short-and-keep-uncommon-and-non-local-names-longer" class="md-nav__link">
    <span class="md-ellipsis">
      ES.7: Keep common and local names short, and keep uncommon and non-local names longer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es8-avoid-similar-looking-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.8: Avoid similar-looking names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es9-avoid-all_caps-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.9: Avoid ALL_CAPS names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es10-declare-one-name-only-per-declaration" class="md-nav__link">
    <span class="md-ellipsis">
      ES.10: Declare one name (only) per declaration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es11-use-auto-to-avoid-redundant-repetition-of-type-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.11: Use auto to avoid redundant repetition of type names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es12-do-not-reuse-names-in-nested-scopes" class="md-nav__link">
    <span class="md-ellipsis">
      ES.12: Do not reuse names in nested scopes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es20-always-initialize-an-object" class="md-nav__link">
    <span class="md-ellipsis">
      ES.20: Always initialize an object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es21-dont-introduce-a-variable-or-constant-before-you-need-to-use-it" class="md-nav__link">
    <span class="md-ellipsis">
      ES.21: Don't introduce a variable (or constant) before you need to use it
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es22-dont-declare-a-variable-until-you-have-a-value-to-initialize-it-with" class="md-nav__link">
    <span class="md-ellipsis">
      ES.22: Don't declare a variable until you have a value to initialize it with
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es23-prefer-the-initializer-syntax" class="md-nav__link">
    <span class="md-ellipsis">
      ES.23: Prefer the {}-initializer syntax
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es24-use-a-unique_ptrt-to-hold-pointers" class="md-nav__link">
    <span class="md-ellipsis">
      ES.24: Use a unique_ptr&lt;T&gt; to hold pointers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es25-declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on" class="md-nav__link">
    <span class="md-ellipsis">
      ES.25: Declare an object const or constexpr unless you want to modify its value later on
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es26-dont-use-a-variable-for-two-unrelated-purposes" class="md-nav__link">
    <span class="md-ellipsis">
      ES.26: Don't use a variable for two unrelated purposes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es27-use-stdarray-or-stack_array-for-arrays-on-the-stack" class="md-nav__link">
    <span class="md-ellipsis">
      ES.27: Use std::array or stack_array for arrays on the stack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es28-use-lambdas-for-complex-initialization-especially-of-const-variables" class="md-nav__link">
    <span class="md-ellipsis">
      ES.28: Use lambdas for complex initialization, especially of const variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es30-dont-use-macros-for-program-text-manipulation" class="md-nav__link">
    <span class="md-ellipsis">
      ES.30: Don't use macros for program text manipulation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es31-dont-use-macros-for-constants-or-functions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.31: Don't use macros for constants or "functions"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es32-use-all_caps-for-all-macro-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.32: Use ALL_CAPS for all macro names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es33-if-you-must-use-macros-give-them-unique-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.33: If you must use macros, give them unique names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es34-dont-define-a-c-style-variadic-function" class="md-nav__link">
    <span class="md-ellipsis">
      ES.34: Don't define a (C-style) variadic function
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esexpr-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.expr: Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ES.expr: Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es40-avoid-complicated-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.40: Avoid complicated expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es41-if-in-doubt-about-operator-precedence-parenthesize" class="md-nav__link">
    <span class="md-ellipsis">
      ES.41: If in doubt about operator precedence, parenthesize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es42-keep-use-of-pointers-simple-and-straightforward" class="md-nav__link">
    <span class="md-ellipsis">
      ES.42: Keep use of pointers simple and straightforward
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es43-avoid-expressions-with-undefined-order-of-evaluation" class="md-nav__link">
    <span class="md-ellipsis">
      ES.43: Avoid expressions with undefined order of evaluation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es44-dont-depend-on-order-of-evaluation-of-function-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      ES.44: Don't depend on order of evaluation of function arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es45-avoid-magic-constants-use-symbolic-constants" class="md-nav__link">
    <span class="md-ellipsis">
      ES.45: Avoid "magic constants"; use symbolic constants
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es46-avoid-lossy-narrowing-truncating-arithmetic-conversions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es47-use-nullptr-rather-than-0-or-null" class="md-nav__link">
    <span class="md-ellipsis">
      ES.47: Use nullptr rather than 0 or NULL
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es48-avoid-casts" class="md-nav__link">
    <span class="md-ellipsis">
      ES.48: Avoid casts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es49-if-you-must-use-a-cast-use-a-named-cast" class="md-nav__link">
    <span class="md-ellipsis">
      ES.49: If you must use a cast, use a named cast
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es50-dont-cast-away-const" class="md-nav__link">
    <span class="md-ellipsis">
      ES.50: Don't cast away const
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es55-avoid-the-need-for-range-checking" class="md-nav__link">
    <span class="md-ellipsis">
      ES.55: Avoid the need for range checking
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope" class="md-nav__link">
    <span class="md-ellipsis">
      ES.56: Write std::move() only when you need to explicitly move an object to another scope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es60-avoid-new-and-delete-outside-resource-management-functions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.60: Avoid new and delete outside resource management functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es61-delete-arrays-using-delete-and-non-arrays-using-delete" class="md-nav__link">
    <span class="md-ellipsis">
      ES.61: Delete arrays using delete[] and non-arrays using delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es62-dont-compare-pointers-into-different-arrays" class="md-nav__link">
    <span class="md-ellipsis">
      ES.62: Don't compare pointers into different arrays
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es63-dont-slice" class="md-nav__link">
    <span class="md-ellipsis">
      ES.63: Don't slice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es64-use-the-tenotation-for-construction" class="md-nav__link">
    <span class="md-ellipsis">
      ES.64: Use the T{e}notation for construction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es65-dont-dereference-an-invalid-pointer" class="md-nav__link">
    <span class="md-ellipsis">
      ES.65: Don't dereference an invalid pointer
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esstmt-statements" class="md-nav__link">
    <span class="md-ellipsis">
      ES.stmt: Statements
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ES.stmt: Statements">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es70-prefer-a-switch-statement-to-an-if-statement-when-there-is-a-choice" class="md-nav__link">
    <span class="md-ellipsis">
      ES.70: Prefer a switch-statement to an if-statement when there is a choice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice" class="md-nav__link">
    <span class="md-ellipsis">
      ES.71: Prefer a range-for-statement to a for-statement when there is a choice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es72-prefer-a-for-statement-to-a-while-statement-when-there-is-an-obvious-loop-variable" class="md-nav__link">
    <span class="md-ellipsis">
      ES.72: Prefer a for-statement to a while-statement when there is an obvious loop variable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es73-prefer-a-while-statement-to-a-for-statement-when-there-is-no-obvious-loop-variable" class="md-nav__link">
    <span class="md-ellipsis">
      ES.73: Prefer a while-statement to a for-statement when there is no obvious loop variable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es74-prefer-to-declare-a-loop-variable-in-the-initializer-part-of-a-for-statement" class="md-nav__link">
    <span class="md-ellipsis">
      ES.74: Prefer to declare a loop variable in the initializer part of a for-statement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es75-avoid-do-statements" class="md-nav__link">
    <span class="md-ellipsis">
      ES.75: Avoid do-statements
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es76-avoid-goto" class="md-nav__link">
    <span class="md-ellipsis">
      ES.76: Avoid goto
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es77-minimize-the-use-of-break-and-continue-in-loops" class="md-nav__link">
    <span class="md-ellipsis">
      ES.77: Minimize the use of break and continue in loops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es78-dont-rely-on-implicit-fallthrough-in-switch-statements" class="md-nav__link">
    <span class="md-ellipsis">
      ES.78: Don't rely on implicit fallthrough in switch statements
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es79-use-default-to-handle-common-cases-only" class="md-nav__link">
    <span class="md-ellipsis">
      ES.79: Use default to handle common cases (only)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es84-dont-try-to-declare-a-local-variable-with-no-name" class="md-nav__link">
    <span class="md-ellipsis">
      ES.84: Don't try to declare a local variable with no name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es85-make-empty-statements-visible" class="md-nav__link">
    <span class="md-ellipsis">
      ES.85: Make empty statements visible
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es86-avoid-modifying-loop-control-variables-inside-the-body-of-raw-for-loops" class="md-nav__link">
    <span class="md-ellipsis">
      ES.86: Avoid modifying loop control variables inside the body of raw for-loops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es87-dont-add-redundant-or-to-conditions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.87: Don't add redundant == or != to conditions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arithmetic" class="md-nav__link">
    <span class="md-ellipsis">
      Arithmetic
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Arithmetic">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es100-dont-mix-signed-and-unsigned-arithmetic" class="md-nav__link">
    <span class="md-ellipsis">
      ES.100: Don't mix signed and unsigned arithmetic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es101-use-unsigned-types-for-bit-manipulation" class="md-nav__link">
    <span class="md-ellipsis">
      ES.101: Use unsigned types for bit manipulation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es102-use-signed-types-for-arithmetic" class="md-nav__link">
    <span class="md-ellipsis">
      ES.102: Use signed types for arithmetic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es103-dont-overflow" class="md-nav__link">
    <span class="md-ellipsis">
      ES.103: Don't overflow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es104-dont-underflow" class="md-nav__link">
    <span class="md-ellipsis">
      ES.104: Don't underflow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es105-dont-divide-by-integer-zero" class="md-nav__link">
    <span class="md-ellipsis">
      ES.105: Don't divide by integer zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es106-dont-try-to-avoid-negative-values-by-using-unsigned" class="md-nav__link">
    <span class="md-ellipsis">
      ES.106: Don't try to avoid negative values by using unsigned
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es107-dont-use-unsigned-for-subscripts-prefer-gslindex" class="md-nav__link">
    <span class="md-ellipsis">
      ES.107: Don't use unsigned for subscripts, prefer gsl::index
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../per-performance/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Per: Performance
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cp-concurrency-and-parallelism/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    CP: Concurrency and parallelism
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../e-error-handling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    E: Error handling
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../con-constants-and-immutability/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Con: Constants and immutability
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../t-templates-and-generic-programming/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    T: Templates and generic programming
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cpl-c-style-programming/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    CPL: C-style programming
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../sf-source-files/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    SF: Source files
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../sl-the-standard-library/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    SL: The Standard Library
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../a-architectural-ideas/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    A: Architectural ideas
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../nr-non-rules-and-myths/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    NR: Non-Rules and myths
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../rf-references/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    RF: References
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../pro-profiles/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Pro: Profiles
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../gsl-guidelines-support-library/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    GSL: Guidelines support library
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../nl-naming-and-layout-suggestions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    NL: Naming and layout suggestions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq-answers-to-frequently-asked-questions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FAQ: Answers to frequently asked questions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-a-libraries/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Appendix A: Libraries
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-b-modernizing-code/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Appendix B: Modernizing code
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-c-discussion/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Appendix C: Discussion
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../appendix-d-supporting-tools/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Appendix D: Supporting tools
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../glossary/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Glossary
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../to-do-unclassified-proto-rules/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    To-do: Unclassified proto-rules
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../bibliography/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Bibliography
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#es1-prefer-the-standard-library-to-other-libraries-and-to-handcrafted-code" class="md-nav__link">
    <span class="md-ellipsis">
      ES.1: Prefer the standard library to other libraries and to "handcrafted code"
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#es2-prefer-suitable-abstractions-to-direct-use-of-language-features" class="md-nav__link">
    <span class="md-ellipsis">
      ES.2: Prefer suitable abstractions to direct use of language features
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#es3-dont-repeat-yourself-avoid-redundant-code" class="md-nav__link">
    <span class="md-ellipsis">
      ES.3: Don't repeat yourself, avoid redundant code
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esdcl-declarations" class="md-nav__link">
    <span class="md-ellipsis">
      ES.dcl: Declarations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ES.dcl: Declarations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es5-keep-scopes-small" class="md-nav__link">
    <span class="md-ellipsis">
      ES.5: Keep scopes small
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es6-declare-names-in-for-statement-initializers-and-conditions-to-limit-scope" class="md-nav__link">
    <span class="md-ellipsis">
      ES.6: Declare names in for-statement initializers and conditions to limit scope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es7-keep-common-and-local-names-short-and-keep-uncommon-and-non-local-names-longer" class="md-nav__link">
    <span class="md-ellipsis">
      ES.7: Keep common and local names short, and keep uncommon and non-local names longer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es8-avoid-similar-looking-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.8: Avoid similar-looking names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es9-avoid-all_caps-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.9: Avoid ALL_CAPS names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es10-declare-one-name-only-per-declaration" class="md-nav__link">
    <span class="md-ellipsis">
      ES.10: Declare one name (only) per declaration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es11-use-auto-to-avoid-redundant-repetition-of-type-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.11: Use auto to avoid redundant repetition of type names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es12-do-not-reuse-names-in-nested-scopes" class="md-nav__link">
    <span class="md-ellipsis">
      ES.12: Do not reuse names in nested scopes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es20-always-initialize-an-object" class="md-nav__link">
    <span class="md-ellipsis">
      ES.20: Always initialize an object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es21-dont-introduce-a-variable-or-constant-before-you-need-to-use-it" class="md-nav__link">
    <span class="md-ellipsis">
      ES.21: Don't introduce a variable (or constant) before you need to use it
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es22-dont-declare-a-variable-until-you-have-a-value-to-initialize-it-with" class="md-nav__link">
    <span class="md-ellipsis">
      ES.22: Don't declare a variable until you have a value to initialize it with
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es23-prefer-the-initializer-syntax" class="md-nav__link">
    <span class="md-ellipsis">
      ES.23: Prefer the {}-initializer syntax
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es24-use-a-unique_ptrt-to-hold-pointers" class="md-nav__link">
    <span class="md-ellipsis">
      ES.24: Use a unique_ptr&lt;T&gt; to hold pointers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es25-declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on" class="md-nav__link">
    <span class="md-ellipsis">
      ES.25: Declare an object const or constexpr unless you want to modify its value later on
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es26-dont-use-a-variable-for-two-unrelated-purposes" class="md-nav__link">
    <span class="md-ellipsis">
      ES.26: Don't use a variable for two unrelated purposes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es27-use-stdarray-or-stack_array-for-arrays-on-the-stack" class="md-nav__link">
    <span class="md-ellipsis">
      ES.27: Use std::array or stack_array for arrays on the stack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es28-use-lambdas-for-complex-initialization-especially-of-const-variables" class="md-nav__link">
    <span class="md-ellipsis">
      ES.28: Use lambdas for complex initialization, especially of const variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es30-dont-use-macros-for-program-text-manipulation" class="md-nav__link">
    <span class="md-ellipsis">
      ES.30: Don't use macros for program text manipulation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es31-dont-use-macros-for-constants-or-functions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.31: Don't use macros for constants or "functions"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es32-use-all_caps-for-all-macro-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.32: Use ALL_CAPS for all macro names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es33-if-you-must-use-macros-give-them-unique-names" class="md-nav__link">
    <span class="md-ellipsis">
      ES.33: If you must use macros, give them unique names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es34-dont-define-a-c-style-variadic-function" class="md-nav__link">
    <span class="md-ellipsis">
      ES.34: Don't define a (C-style) variadic function
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esexpr-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.expr: Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ES.expr: Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es40-avoid-complicated-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.40: Avoid complicated expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es41-if-in-doubt-about-operator-precedence-parenthesize" class="md-nav__link">
    <span class="md-ellipsis">
      ES.41: If in doubt about operator precedence, parenthesize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es42-keep-use-of-pointers-simple-and-straightforward" class="md-nav__link">
    <span class="md-ellipsis">
      ES.42: Keep use of pointers simple and straightforward
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es43-avoid-expressions-with-undefined-order-of-evaluation" class="md-nav__link">
    <span class="md-ellipsis">
      ES.43: Avoid expressions with undefined order of evaluation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es44-dont-depend-on-order-of-evaluation-of-function-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      ES.44: Don't depend on order of evaluation of function arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es45-avoid-magic-constants-use-symbolic-constants" class="md-nav__link">
    <span class="md-ellipsis">
      ES.45: Avoid "magic constants"; use symbolic constants
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es46-avoid-lossy-narrowing-truncating-arithmetic-conversions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es47-use-nullptr-rather-than-0-or-null" class="md-nav__link">
    <span class="md-ellipsis">
      ES.47: Use nullptr rather than 0 or NULL
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es48-avoid-casts" class="md-nav__link">
    <span class="md-ellipsis">
      ES.48: Avoid casts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es49-if-you-must-use-a-cast-use-a-named-cast" class="md-nav__link">
    <span class="md-ellipsis">
      ES.49: If you must use a cast, use a named cast
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es50-dont-cast-away-const" class="md-nav__link">
    <span class="md-ellipsis">
      ES.50: Don't cast away const
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es55-avoid-the-need-for-range-checking" class="md-nav__link">
    <span class="md-ellipsis">
      ES.55: Avoid the need for range checking
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope" class="md-nav__link">
    <span class="md-ellipsis">
      ES.56: Write std::move() only when you need to explicitly move an object to another scope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es60-avoid-new-and-delete-outside-resource-management-functions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.60: Avoid new and delete outside resource management functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es61-delete-arrays-using-delete-and-non-arrays-using-delete" class="md-nav__link">
    <span class="md-ellipsis">
      ES.61: Delete arrays using delete[] and non-arrays using delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es62-dont-compare-pointers-into-different-arrays" class="md-nav__link">
    <span class="md-ellipsis">
      ES.62: Don't compare pointers into different arrays
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es63-dont-slice" class="md-nav__link">
    <span class="md-ellipsis">
      ES.63: Don't slice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es64-use-the-tenotation-for-construction" class="md-nav__link">
    <span class="md-ellipsis">
      ES.64: Use the T{e}notation for construction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es65-dont-dereference-an-invalid-pointer" class="md-nav__link">
    <span class="md-ellipsis">
      ES.65: Don't dereference an invalid pointer
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#esstmt-statements" class="md-nav__link">
    <span class="md-ellipsis">
      ES.stmt: Statements
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ES.stmt: Statements">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es70-prefer-a-switch-statement-to-an-if-statement-when-there-is-a-choice" class="md-nav__link">
    <span class="md-ellipsis">
      ES.70: Prefer a switch-statement to an if-statement when there is a choice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice" class="md-nav__link">
    <span class="md-ellipsis">
      ES.71: Prefer a range-for-statement to a for-statement when there is a choice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es72-prefer-a-for-statement-to-a-while-statement-when-there-is-an-obvious-loop-variable" class="md-nav__link">
    <span class="md-ellipsis">
      ES.72: Prefer a for-statement to a while-statement when there is an obvious loop variable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es73-prefer-a-while-statement-to-a-for-statement-when-there-is-no-obvious-loop-variable" class="md-nav__link">
    <span class="md-ellipsis">
      ES.73: Prefer a while-statement to a for-statement when there is no obvious loop variable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es74-prefer-to-declare-a-loop-variable-in-the-initializer-part-of-a-for-statement" class="md-nav__link">
    <span class="md-ellipsis">
      ES.74: Prefer to declare a loop variable in the initializer part of a for-statement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es75-avoid-do-statements" class="md-nav__link">
    <span class="md-ellipsis">
      ES.75: Avoid do-statements
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es76-avoid-goto" class="md-nav__link">
    <span class="md-ellipsis">
      ES.76: Avoid goto
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es77-minimize-the-use-of-break-and-continue-in-loops" class="md-nav__link">
    <span class="md-ellipsis">
      ES.77: Minimize the use of break and continue in loops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es78-dont-rely-on-implicit-fallthrough-in-switch-statements" class="md-nav__link">
    <span class="md-ellipsis">
      ES.78: Don't rely on implicit fallthrough in switch statements
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es79-use-default-to-handle-common-cases-only" class="md-nav__link">
    <span class="md-ellipsis">
      ES.79: Use default to handle common cases (only)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es84-dont-try-to-declare-a-local-variable-with-no-name" class="md-nav__link">
    <span class="md-ellipsis">
      ES.84: Don't try to declare a local variable with no name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es85-make-empty-statements-visible" class="md-nav__link">
    <span class="md-ellipsis">
      ES.85: Make empty statements visible
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es86-avoid-modifying-loop-control-variables-inside-the-body-of-raw-for-loops" class="md-nav__link">
    <span class="md-ellipsis">
      ES.86: Avoid modifying loop control variables inside the body of raw for-loops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es87-dont-add-redundant-or-to-conditions" class="md-nav__link">
    <span class="md-ellipsis">
      ES.87: Don't add redundant == or != to conditions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arithmetic" class="md-nav__link">
    <span class="md-ellipsis">
      Arithmetic
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Arithmetic">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#es100-dont-mix-signed-and-unsigned-arithmetic" class="md-nav__link">
    <span class="md-ellipsis">
      ES.100: Don't mix signed and unsigned arithmetic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es101-use-unsigned-types-for-bit-manipulation" class="md-nav__link">
    <span class="md-ellipsis">
      ES.101: Use unsigned types for bit manipulation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es102-use-signed-types-for-arithmetic" class="md-nav__link">
    <span class="md-ellipsis">
      ES.102: Use signed types for arithmetic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es103-dont-overflow" class="md-nav__link">
    <span class="md-ellipsis">
      ES.103: Don't overflow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es104-dont-underflow" class="md-nav__link">
    <span class="md-ellipsis">
      ES.104: Don't underflow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es105-dont-divide-by-integer-zero" class="md-nav__link">
    <span class="md-ellipsis">
      ES.105: Don't divide by integer zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es106-dont-try-to-avoid-negative-values-by-using-unsigned" class="md-nav__link">
    <span class="md-ellipsis">
      ES.106: Don't try to avoid negative values by using unsigned
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#es107-dont-use-unsigned-for-subscripts-prefer-gslindex" class="md-nav__link">
    <span class="md-ellipsis">
      ES.107: Don't use unsigned for subscripts, prefer gsl::index
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="es-expressions-and-statements-s-expr">ES: Expressions and statements {#S-expr}<a class="headerlink" href="#es-expressions-and-statements-s-expr" title="Permanent link">&para;</a></h1>
<p>Expressions and statements are the lowest and most direct way of expressing actions and computation. Declarations in local scopes are statements.</p>
<p>For naming, commenting, and indentation rules, see <a href="#S-naming">NL: Naming and layout</a>.</p>
<p>General rules:</p>
<ul>
<li><a href="#Res-lib">ES.1: Prefer the standard library to other libraries and to "handcrafted code"</a></li>
<li><a href="#Res-abstr">ES.2: Prefer suitable abstractions to direct use of language features</a></li>
<li><a href="#Res-DRY">ES.3: Don't repeat yourself, avoid redundant code</a></li>
</ul>
<p>Declaration rules:</p>
<ul>
<li><a href="#Res-scope">ES.5: Keep scopes small</a></li>
<li><a href="#Res-cond">ES.6: Declare names in for-statement initializers and conditions to limit scope</a></li>
<li><a href="#Res-name-length">ES.7: Keep common and local names short, and keep uncommon and non-local names longer</a></li>
<li><a href="#Res-name-similar">ES.8: Avoid similar-looking names</a></li>
<li><a href="#Res-not-CAPS">ES.9: Avoid <code>ALL_CAPS</code> names</a></li>
<li><a href="#Res-name-one">ES.10: Declare one name (only) per declaration</a></li>
<li><a href="#Res-auto">ES.11: Use <code>auto</code> to avoid redundant repetition of type names</a></li>
<li><a href="#Res-reuse">ES.12: Do not reuse names in nested scopes</a></li>
<li><a href="#Res-always">ES.20: Always initialize an object</a></li>
<li><a href="#Res-introduce">ES.21: Don't introduce a variable (or constant) before you need to use it</a></li>
<li><a href="#Res-init">ES.22: Don't declare a variable until you have a value to initialize it with</a></li>
<li><a href="#Res-list">ES.23: Prefer the <code>{}</code>-initializer syntax</a></li>
<li><a href="#Res-unique">ES.24: Use a <code>unique_ptr&lt;T&gt;</code> to hold pointers</a></li>
<li><a href="#Res-const">ES.25: Declare an object <code>const</code> or <code>constexpr</code> unless you want to modify its value later on</a></li>
<li><a href="#Res-recycle">ES.26: Don't use a variable for two unrelated purposes</a></li>
<li><a href="#Res-stack">ES.27: Use <code>std::array</code> or <code>stack_array</code> for arrays on the stack</a></li>
<li><a href="#Res-lambda-init">ES.28: Use lambdas for complex initialization, especially of <code>const</code> variables</a></li>
<li><a href="#Res-macros">ES.30: Don't use macros for program text manipulation</a></li>
<li><a href="#Res-macros2">ES.31: Don't use macros for constants or "functions"</a></li>
<li><a href="#Res-ALL_CAPS">ES.32: Use <code>ALL_CAPS</code> for all macro names</a></li>
<li><a href="#Res-MACROS">ES.33: If you must use macros, give them unique names</a></li>
<li><a href="#Res-ellipses">ES.34: Don't define a (C-style) variadic function</a></li>
</ul>
<p>Expression rules:</p>
<ul>
<li><a href="#Res-complicated">ES.40: Avoid complicated expressions</a></li>
<li><a href="#Res-parens">ES.41: If in doubt about operator precedence, parenthesize</a></li>
<li><a href="#Res-ptr">ES.42: Keep use of pointers simple and straightforward</a></li>
<li><a href="#Res-order">ES.43: Avoid expressions with undefined order of evaluation</a></li>
<li><a href="#Res-order-fct">ES.44: Don't depend on order of evaluation of function arguments</a></li>
<li><a href="#Res-magic">ES.45: Avoid "magic constants"; use symbolic constants</a></li>
<li><a href="#Res-narrowing">ES.46: Avoid narrowing conversions</a></li>
<li><a href="#Res-nullptr">ES.47: Use <code>nullptr</code> rather than <code>0</code> or <code>NULL</code></a></li>
<li><a href="#Res-casts">ES.48: Avoid casts</a></li>
<li><a href="#Res-casts-named">ES.49: If you must use a cast, use a named cast</a></li>
<li><a href="#Res-casts-const">ES.50: Don't cast away <code>const</code></a></li>
<li><a href="#Res-range-checking">ES.55: Avoid the need for range checking</a></li>
<li><a href="#Res-move">ES.56: Write <code>std::move()</code> only when you need to explicitly move an object to another scope</a></li>
<li><a href="#Res-new">ES.60: Avoid <code>new</code> and <code>delete</code> outside resource management functions</a></li>
<li><a href="#Res-del">ES.61: Delete arrays using <code>delete[]</code> and non-arrays using <code>delete</code></a></li>
<li><a href="#Res-arr2">ES.62: Don't compare pointers into different arrays</a></li>
<li><a href="#Res-slice">ES.63: Don't slice</a></li>
<li><a href="#Res-construct">ES.64: Use the <code>T{e}</code>notation for construction</a></li>
<li><a href="#Res-deref">ES.65: Don't dereference an invalid pointer</a></li>
</ul>
<p>Statement rules:</p>
<ul>
<li><a href="#Res-switch-if">ES.70: Prefer a <code>switch</code>-statement to an <code>if</code>-statement when there is a choice</a></li>
<li><a href="#Res-for-range">ES.71: Prefer a range-<code>for</code>-statement to a <code>for</code>-statement when there is a choice</a></li>
<li><a href="#Res-for-while">ES.72: Prefer a <code>for</code>-statement to a <code>while</code>-statement when there is an obvious loop variable</a></li>
<li><a href="#Res-while-for">ES.73: Prefer a <code>while</code>-statement to a <code>for</code>-statement when there is no obvious loop variable</a></li>
<li><a href="#Res-for-init">ES.74: Prefer to declare a loop variable in the initializer part of a <code>for</code>-statement</a></li>
<li><a href="#Res-do">ES.75: Avoid <code>do</code>-statements</a></li>
<li><a href="#Res-goto">ES.76: Avoid <code>goto</code></a></li>
<li><a href="#Res-continue">ES.77: Minimize the use of <code>break</code> and <code>continue</code> in loops</a></li>
<li><a href="#Res-break">ES.78: Don't rely on implicit fallthrough in <code>switch</code> statements</a></li>
<li><a href="#Res-default">ES.79: Use <code>default</code> to handle common cases (only)</a></li>
<li><a href="#Res-noname">ES.84: Don't try to declare a local variable with no name</a></li>
<li><a href="#Res-empty">ES.85: Make empty statements visible</a></li>
<li><a href="#Res-loop-counter">ES.86: Avoid modifying loop control variables inside the body of raw for-loops</a></li>
<li><a href="#Res-if">ES.87: Don't add redundant <code>==</code> or <code>!=</code> to conditions</a></li>
</ul>
<p>Arithmetic rules:</p>
<ul>
<li><a href="#Res-mix">ES.100: Don't mix signed and unsigned arithmetic</a></li>
<li><a href="#Res-unsigned">ES.101: Use unsigned types for bit manipulation</a></li>
<li><a href="#Res-signed">ES.102: Use signed types for arithmetic</a></li>
<li><a href="#Res-overflow">ES.103: Don't overflow</a></li>
<li><a href="#Res-underflow">ES.104: Don't underflow</a></li>
<li><a href="#Res-zero">ES.105: Don't divide by integer zero</a></li>
<li><a href="#Res-nonnegative">ES.106: Don't try to avoid negative values by using <code>unsigned</code></a></li>
<li><a href="#Res-subscripts">ES.107: Don't use <code>unsigned</code> for subscripts, prefer <code>gsl::index</code></a></li>
</ul>
<h3 id="es1-prefer-the-standard-library-to-other-libraries-and-to-handcrafted-code"><a name="Res-lib"></a>ES.1: Prefer the standard library to other libraries and to "handcrafted code"<a class="headerlink" href="#es1-prefer-the-standard-library-to-other-libraries-and-to-handcrafted-code" title="Permanent link">&para;</a></h3>
<h5 id="reason">Reason<a class="headerlink" href="#reason" title="Permanent link">&para;</a></h5>
<p>Code using a library can be much easier to write than code working directly with language features, much shorter, tend to be of a higher level of abstraction, and the library code is presumably already tested.
The ISO C++ Standard Library is among the most widely known and best tested libraries.
It is available as part of all C++ implementations.</p>
<h5 id="example">Example<a class="headerlink" href="#example" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>auto sum = accumulate(begin(a), end(a), 0.0);   // good
</code></pre></div>
<p>a range version of <code>accumulate</code> would be even better:</p>
<div class="language-text highlight"><pre><span></span><code>auto sum = accumulate(v, 0.0); // better
</code></pre></div>
<p>but don't hand-code a well-known algorithm:</p>
<div class="language-text highlight"><pre><span></span><code>int max = v.size();   // bad: verbose, purpose unstated
double sum = 0.0;
for (int i = 0; i &lt; max; ++i)
    sum = sum + v[i];
</code></pre></div>
<h5 id="exception">Exception<a class="headerlink" href="#exception" title="Permanent link">&para;</a></h5>
<p>Large parts of the standard library rely on dynamic allocation (free store). These parts, notably the containers but not the algorithms, are unsuitable for some hard-real-time and embedded applications. In such cases, consider providing/using similar facilities, e.g.,  a standard-library-style container implemented using a pool allocator.</p>
<h5 id="enforcement">Enforcement<a class="headerlink" href="#enforcement" title="Permanent link">&para;</a></h5>
<p>Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of built-in types. Cyclomatic complexity?</p>
<h3 id="es2-prefer-suitable-abstractions-to-direct-use-of-language-features"><a name="Res-abstr"></a>ES.2: Prefer suitable abstractions to direct use of language features<a class="headerlink" href="#es2-prefer-suitable-abstractions-to-direct-use-of-language-features" title="Permanent link">&para;</a></h3>
<h5 id="reason_1">Reason<a class="headerlink" href="#reason_1" title="Permanent link">&para;</a></h5>
<p>A "suitable abstraction" (e.g., library or class) is closer to the application concepts than the bare language, leads to shorter and clearer code, and is likely to be better tested.</p>
<h5 id="example_1">Example<a class="headerlink" href="#example_1" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>vector&lt;string&gt; read1(istream&amp; is)   // good
{
    vector&lt;string&gt; res;
    for (string s; is &gt;&gt; s;)
        res.push_back(s);
    return res;
}
</code></pre></div>
<p>The more traditional and lower-level near-equivalent is longer, messier, harder to get right, and most likely slower:</p>
<div class="language-text highlight"><pre><span></span><code>char** read2(istream&amp; is, int maxelem, int maxstring, int* nread)   // bad: verbose and incomplete
{
    auto res = new char*[maxelem];
    int elemcount = 0;
    while (is &amp;&amp; elemcount &lt; maxelem) {
        auto s = new char[maxstring];
        is.read(s, maxstring);
        res[elemcount++] = s;
    }
    *nread = elemcount;
    return res;
}
</code></pre></div>
<p>Once the checking for overflow and error handling has been added that code gets quite messy, and there is the problem remembering to <code>delete</code> the returned pointer and the C-style strings that array contains.</p>
<h5 id="enforcement_1">Enforcement<a class="headerlink" href="#enforcement_1" title="Permanent link">&para;</a></h5>
<p>Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of built-in types. Cyclomatic complexity?</p>
<h3 id="es3-dont-repeat-yourself-avoid-redundant-code"><a name="Res-DRY"></a>ES.3: Don't repeat yourself, avoid redundant code<a class="headerlink" href="#es3-dont-repeat-yourself-avoid-redundant-code" title="Permanent link">&para;</a></h3>
<p>Duplicated or otherwise redundant code obscures intent, makes it harder to understand the logic, and makes maintenance harder, among other problems. It often arises from cut-and-paste programming.</p>
<p>Use standard algorithms where appropriate, instead of writing some own implementation.</p>
<p><strong>See also</strong>: <a href="#Rsl-lib">SL.1</a>, <a href="#Res-auto">ES.11</a></p>
<h5 id="example_2">Example<a class="headerlink" href="#example_2" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void func(bool flag)    // Bad, duplicated code.
{
    if (flag) {
        x();
        y();
    }
    else {
        x();
        z();
    }
}

void func(bool flag)    // Better, no duplicated code.
{
    x();

    if (flag)
        y();
    else
        z();
}
</code></pre></div>
<h5 id="enforcement_2">Enforcement<a class="headerlink" href="#enforcement_2" title="Permanent link">&para;</a></h5>
<ul>
<li>Use a static analyzer. It will catch at least some redundant constructs.</li>
<li>Code review</li>
</ul>
<h2 id="esdcl-declarations">ES.dcl: Declarations<a class="headerlink" href="#esdcl-declarations" title="Permanent link">&para;</a></h2>
<p>A declaration is a statement. A declaration introduces a name into a scope and might cause the construction of a named object.</p>
<h3 id="es5-keep-scopes-small"><a name="Res-scope"></a>ES.5: Keep scopes small<a class="headerlink" href="#es5-keep-scopes-small" title="Permanent link">&para;</a></h3>
<h5 id="reason_2">Reason<a class="headerlink" href="#reason_2" title="Permanent link">&para;</a></h5>
<p>Readability. Minimize resource retention. Avoid accidental misuse of value.</p>
<p><strong>Alternative formulation</strong>: Don't declare a name in an unnecessarily large scope.</p>
<h5 id="example_3">Example<a class="headerlink" href="#example_3" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void use()
{
    int i;    // bad: i is needlessly accessible after loop
    for (i = 0; i &lt; 20; ++i) { /* ... */ }
    // no intended use of i here
    for (int i = 0; i &lt; 20; ++i) { /* ... */ }  // good: i is local to for-loop

    if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) {  // good: pc is local to if-statement
        // ... deal with Circle ...
    }
    else {
        // ... handle error ...
    }
}
</code></pre></div>
<h5 id="example-bad">Example, bad<a class="headerlink" href="#example-bad" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void use(const string&amp; name)
{
    string fn = name + &quot;.txt&quot;;
    ifstream is {fn};
    Record r;
    is &gt;&gt; r;
    // ... 200 lines of code without intended use of fn or is ...
}
</code></pre></div>
<p>This function is by most measures too long anyway, but the point is that the resources used by <code>fn</code> and the file handle held by <code>is</code>
are retained for much longer than needed and that unanticipated use of <code>is</code> and <code>fn</code> could happen later in the function.
In this case, it might be a good idea to factor out the read:</p>
<div class="language-text highlight"><pre><span></span><code>Record load_record(const string&amp; name)
{
    string fn = name + &quot;.txt&quot;;
    ifstream is {fn};
    Record r;
    is &gt;&gt; r;
    return r;
}

void use(const string&amp; name)
{
    Record r = load_record(name);
    // ... 200 lines of code ...
}
</code></pre></div>
<h5 id="enforcement_3">Enforcement<a class="headerlink" href="#enforcement_3" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag loop variable declared outside a loop and not used after the loop</li>
<li>Flag when expensive resources, such as file handles and locks are not used for N-lines (for some suitable N)</li>
</ul>
<h3 id="es6-declare-names-in-for-statement-initializers-and-conditions-to-limit-scope"><a name="Res-cond"></a>ES.6: Declare names in for-statement initializers and conditions to limit scope<a class="headerlink" href="#es6-declare-names-in-for-statement-initializers-and-conditions-to-limit-scope" title="Permanent link">&para;</a></h3>
<h5 id="reason_3">Reason<a class="headerlink" href="#reason_3" title="Permanent link">&para;</a></h5>
<p>Readability.
Limit the loop variable visibility to the scope of the loop.
Avoid using the loop variable for other purposes after the loop.
Minimize resource retention.</p>
<h5 id="example_4">Example<a class="headerlink" href="#example_4" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void use()
{
    for (string s; cin &gt;&gt; s;)
        v.push_back(s);

    for (int i = 0; i &lt; 20; ++i) {   // good: i is local to for-loop
        // ...
    }

    if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) {   // good: pc is local to if-statement
        // ... deal with Circle ...
    }
    else {
        // ... handle error ...
    }
}
</code></pre></div>
<h5 id="example-dont">Example, don't<a class="headerlink" href="#example-dont" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int j;                            // BAD: j is visible outside the loop
for (j = 0; j &lt; 100; ++j) {
    // ...
}
// j is still visible here and isn&#39;t needed
</code></pre></div>
<p><strong>See also</strong>: <a href="#Res-recycle">Don't use a variable for two unrelated purposes</a></p>
<h5 id="enforcement_4">Enforcement<a class="headerlink" href="#enforcement_4" title="Permanent link">&para;</a></h5>
<ul>
<li>Warn when a variable modified inside the <code>for</code>-statement is declared outside the loop and not being used outside the loop.</li>
<li>(hard) Flag loop variables declared before the loop and used after the loop for an unrelated purpose.</li>
</ul>
<p><strong>Discussion</strong>: Scoping the loop variable to the loop body also helps code optimizers greatly. Recognizing that the induction variable
is only accessible in the loop body unblocks optimizations such as hoisting, strength reduction, loop-invariant code motion, etc.</p>
<h5 id="c17-and-c20-example">C++17 and C++20 example<a class="headerlink" href="#c17-and-c20-example" title="Permanent link">&para;</a></h5>
<p>Note: C++17 and C++20 also add <code>if</code>, <code>switch</code>, and range-<code>for</code> initializer statements. These require C++17 and C++20 support.</p>
<div class="language-text highlight"><pre><span></span><code>map&lt;int, string&gt; mymap;

if (auto result = mymap.insert(value); result.second) {
    // insert succeeded, and result is valid for this block
    use(result.first);  // ok
    // ...
} // result is destroyed here
</code></pre></div>
<h5 id="c17-and-c20-enforcement-if-using-a-c17-or-c20-compiler">C++17 and C++20 enforcement (if using a C++17 or C++20 compiler)<a class="headerlink" href="#c17-and-c20-enforcement-if-using-a-c17-or-c20-compiler" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag selection/loop variables declared before the body and not used after the body</li>
<li>(hard) Flag selection/loop variables declared before the body and used after the body for an unrelated purpose.</li>
</ul>
<h3 id="es7-keep-common-and-local-names-short-and-keep-uncommon-and-non-local-names-longer"><a name="Res-name-length"></a>ES.7: Keep common and local names short, and keep uncommon and non-local names longer<a class="headerlink" href="#es7-keep-common-and-local-names-short-and-keep-uncommon-and-non-local-names-longer" title="Permanent link">&para;</a></h3>
<h5 id="reason_4">Reason<a class="headerlink" href="#reason_4" title="Permanent link">&para;</a></h5>
<p>Readability. Lowering the chance of clashes between unrelated non-local names.</p>
<h5 id="example_5">Example<a class="headerlink" href="#example_5" title="Permanent link">&para;</a></h5>
<p>Conventional short, local names increase readability:</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;    // good
void print(ostream&amp; os, const vector&lt;T&gt;&amp; v)
{
    for (gsl::index i = 0; i &lt; v.size(); ++i)
        os &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;
}
</code></pre></div>
<p>An index is conventionally called <code>i</code> and there is no hint about the meaning of the vector in this generic function, so <code>v</code> is as good name as any. Compare</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename Element_type&gt;   // bad: verbose, hard to read
void print(ostream&amp; target_stream, const vector&lt;Element_type&gt;&amp; current_vector)
{
    for (gsl::index current_element_index = 0;
         current_element_index &lt; current_vector.size();
         ++current_element_index
    )
    target_stream &lt;&lt; current_vector[current_element_index] &lt;&lt; &#39;\n&#39;;
}
</code></pre></div>
<p>Yes, it is a caricature, but we have seen worse.</p>
<h5 id="example_6">Example<a class="headerlink" href="#example_6" title="Permanent link">&para;</a></h5>
<p>Unconventional and short non-local names obscure code:</p>
<div class="language-text highlight"><pre><span></span><code>void use1(const string&amp; s)
{
    // ...
    tt(s);   // bad: what is tt()?
    // ...
}
</code></pre></div>
<p>Better, give non-local entities readable names:</p>
<div class="language-text highlight"><pre><span></span><code>void use1(const string&amp; s)
{
    // ...
    trim_tail(s);   // better
    // ...
}
</code></pre></div>
<p>Here, there is a chance that the reader knows what <code>trim_tail</code> means and that the reader can remember it after looking it up.</p>
<h5 id="example-bad_1">Example, bad<a class="headerlink" href="#example-bad_1" title="Permanent link">&para;</a></h5>
<p>Argument names of large functions are de facto non-local and should be meaningful:</p>
<div class="language-text highlight"><pre><span></span><code>void complicated_algorithm(vector&lt;Record&gt;&amp; vr, const vector&lt;int&gt;&amp; vi, map&lt;string, int&gt;&amp; out)
// read from events in vr (marking used Records) for the indices in
// vi placing (name, index) pairs into out
{
    // ... 500 lines of code using vr, vi, and out ...
}
</code></pre></div>
<p>We recommend keeping functions short, but that rule isn't universally adhered to and naming should reflect that.</p>
<h5 id="enforcement_5">Enforcement<a class="headerlink" href="#enforcement_5" title="Permanent link">&para;</a></h5>
<p>Check length of local and non-local names. Also take function length into account.</p>
<h3 id="es8-avoid-similar-looking-names"><a name="Res-name-similar"></a>ES.8: Avoid similar-looking names<a class="headerlink" href="#es8-avoid-similar-looking-names" title="Permanent link">&para;</a></h3>
<h5 id="reason_5">Reason<a class="headerlink" href="#reason_5" title="Permanent link">&para;</a></h5>
<p>Code clarity and readability. Too-similar names slow down comprehension and increase the likelihood of error.</p>
<h5 id="example-bad_2">Example, bad<a class="headerlink" href="#example-bad_2" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();
</code></pre></div>
<h5 id="example-bad_3">Example, bad<a class="headerlink" href="#example-bad_3" title="Permanent link">&para;</a></h5>
<p>Do not declare a non-type with the same name as a type in the same scope. This removes the need to disambiguate with a keyword such as <code>struct</code> or <code>enum</code>. It also removes a source of errors, as <code>struct X</code> can implicitly declare <code>X</code> if lookup fails.</p>
<div class="language-text highlight"><pre><span></span><code>struct foo { int n; };
struct foo foo();       // BAD, foo is a type already in scope
struct foo x = foo();   // requires disambiguation
</code></pre></div>
<h5 id="exception_1">Exception<a class="headerlink" href="#exception_1" title="Permanent link">&para;</a></h5>
<p>Antique header files might declare non-types and types with the same name in the same scope.</p>
<h5 id="enforcement_6">Enforcement<a class="headerlink" href="#enforcement_6" title="Permanent link">&para;</a></h5>
<ul>
<li>Check names against a list of known confusing letter and digit combinations.</li>
<li>Flag a declaration of a variable, function, or enumerator that hides a class or enumeration declared in the same scope.</li>
</ul>
<h3 id="es9-avoid-all_caps-names"><a name="Res-not-CAPS"></a>ES.9: Avoid <code>ALL_CAPS</code> names<a class="headerlink" href="#es9-avoid-all_caps-names" title="Permanent link">&para;</a></h3>
<h5 id="reason_6">Reason<a class="headerlink" href="#reason_6" title="Permanent link">&para;</a></h5>
<p>Such names are commonly used for macros. Thus, <code>ALL_CAPS</code> name are vulnerable to unintended macro substitution.</p>
<h5 id="example_7">Example<a class="headerlink" href="#example_7" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>// somewhere in some header:
#define NE !=

// somewhere else in some other header:
enum Coord { N, NE, NW, S, SE, SW, E, W };

// somewhere third in some poor programmer&#39;s .cpp:
switch (direction) {
case N:
    // ...
case NE:
    // ...
// ...
}
</code></pre></div>
<h5 id="note">Note<a class="headerlink" href="#note" title="Permanent link">&para;</a></h5>
<p>Do not use <code>ALL_CAPS</code> for constants just because constants used to be macros.</p>
<h5 id="enforcement_7">Enforcement<a class="headerlink" href="#enforcement_7" title="Permanent link">&para;</a></h5>
<p>Flag all uses of ALL CAPS. For older code, accept ALL CAPS for macro names and flag all non-ALL-CAPS macro names.</p>
<h3 id="es10-declare-one-name-only-per-declaration"><a name="Res-name-one"></a>ES.10: Declare one name (only) per declaration<a class="headerlink" href="#es10-declare-one-name-only-per-declaration" title="Permanent link">&para;</a></h3>
<h5 id="reason_7">Reason<a class="headerlink" href="#reason_7" title="Permanent link">&para;</a></h5>
<p>One declaration per line increases readability and avoids mistakes related to
the C/C++ grammar. It also leaves room for a more descriptive end-of-line
comment.</p>
<h5 id="example-bad_4">Example, bad<a class="headerlink" href="#example-bad_4" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>char *p, c, a[7], *pp[7], **aa[10];   // yuck!
</code></pre></div>
<h5 id="exception_2">Exception<a class="headerlink" href="#exception_2" title="Permanent link">&para;</a></h5>
<p>A function declaration can contain several function argument declarations.</p>
<h5 id="exception_3">Exception<a class="headerlink" href="#exception_3" title="Permanent link">&para;</a></h5>
<p>A structured binding (C++17) is specifically designed to introduce several variables:</p>
<div class="language-text highlight"><pre><span></span><code>auto [iter, inserted] = m.insert_or_assign(k, val);
if (inserted) { /* new entry was inserted */ }
</code></pre></div>
<h5 id="example_8">Example<a class="headerlink" href="#example_8" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;class InputIterator, class Predicate&gt;
bool any_of(InputIterator first, InputIterator last, Predicate pred);
</code></pre></div>
<p>or better using concepts:</p>
<div class="language-text highlight"><pre><span></span><code>bool any_of(input_iterator auto first, input_iterator auto last, predicate auto pred);
</code></pre></div>
<h5 id="example_9">Example<a class="headerlink" href="#example_9" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>double scalbn(double x, int n);   // OK: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2
</code></pre></div>
<p>or:</p>
<div class="language-text highlight"><pre><span></span><code>double scalbn(    // better: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2
    double x,     // base value
    int n         // exponent
);
</code></pre></div>
<p>or:</p>
<div class="language-text highlight"><pre><span></span><code>// better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually 2
double scalbn(double base, int exponent);
</code></pre></div>
<h5 id="example_10">Example<a class="headerlink" href="#example_10" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int a = 10, b = 11, c = 12, d, e = 14, f = 15;
</code></pre></div>
<p>In a long list of declarators it is easy to overlook an uninitialized variable.</p>
<h5 id="enforcement_8">Enforcement<a class="headerlink" href="#enforcement_8" title="Permanent link">&para;</a></h5>
<p>Flag variable and constant declarations with multiple declarators (e.g., <code>int* p, q;</code>)</p>
<h3 id="es11-use-auto-to-avoid-redundant-repetition-of-type-names"><a name="Res-auto"></a>ES.11: Use <code>auto</code> to avoid redundant repetition of type names<a class="headerlink" href="#es11-use-auto-to-avoid-redundant-repetition-of-type-names" title="Permanent link">&para;</a></h3>
<h5 id="reason_8">Reason<a class="headerlink" href="#reason_8" title="Permanent link">&para;</a></h5>
<ul>
<li>Simple repetition is tedious and error-prone.</li>
<li>When you use <code>auto</code>, the name of the declared entity is in a fixed position in the declaration, increasing readability.</li>
<li>In a function template declaration the return type can be a member type.</li>
</ul>
<h5 id="example_11">Example<a class="headerlink" href="#example_11" title="Permanent link">&para;</a></h5>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>auto p = v.begin();      // vector&lt;DataRecord&gt;::iterator
auto z1 = v[3];          // makes copy of DataRecord
auto&amp; z2 = v[3];         // avoids copy
const auto&amp; z3 = v[3];   // const and avoids copy
auto h = t.future();
auto q = make_unique&lt;int[]&gt;(s);
auto f = [](int x) { return x + 10; };
</code></pre></div>
<p>In each case, we save writing a longish, hard-to-remember type that the compiler already knows but a programmer could get wrong.</p>
<h5 id="example_12">Example<a class="headerlink" href="#example_12" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;class T&gt;
auto Container&lt;T&gt;::first() -&gt; Iterator;   // Container&lt;T&gt;::Iterator
</code></pre></div>
<h5 id="exception_4">Exception<a class="headerlink" href="#exception_4" title="Permanent link">&para;</a></h5>
<p>Avoid <code>auto</code> for initializer lists and in cases where you know exactly which type you want and where an initializer might require conversion.</p>
<h5 id="example_13">Example<a class="headerlink" href="#example_13" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>auto lst = { 1, 2, 3 };   // lst is an initializer list
auto x{1};   // x is an int (in C++17; initializer_list in C++11)
</code></pre></div>
<h5 id="note_1">Note<a class="headerlink" href="#note_1" title="Permanent link">&para;</a></h5>
<p>As of C++20, we can (and should) use concepts to be more specific about the type we are deducing:</p>
<div class="language-text highlight"><pre><span></span><code>// ...
forward_iterator auto p = algo(x, y, z);
</code></pre></div>
<h5 id="example-c17">Example (C++17)<a class="headerlink" href="#example-c17" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>std::set&lt;int&gt; values;
// ...
auto [ position, newly_inserted ] = values.insert(5);   // break out the members of the std::pair
</code></pre></div>
<h5 id="enforcement_9">Enforcement<a class="headerlink" href="#enforcement_9" title="Permanent link">&para;</a></h5>
<p>Flag redundant repetition of type names in a declaration.</p>
<h3 id="es12-do-not-reuse-names-in-nested-scopes"><a name="Res-reuse"></a>ES.12: Do not reuse names in nested scopes<a class="headerlink" href="#es12-do-not-reuse-names-in-nested-scopes" title="Permanent link">&para;</a></h3>
<h5 id="reason_9">Reason<a class="headerlink" href="#reason_9" title="Permanent link">&para;</a></h5>
<p>It is easy to get confused about which variable is used.
Can cause maintenance problems.</p>
<h5 id="example-bad_5">Example, bad<a class="headerlink" href="#example-bad_5" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int d = 0;
// ...
if (cond) {
    // ...
    d = 9;
    // ...
}
else {
    // ...
    int d = 7;
    // ...
    d = value_to_be_returned;
    // ...
}

return d;
</code></pre></div>
<p>If this is a large <code>if</code>-statement, it is easy to overlook that a new <code>d</code> has been introduced in the inner scope.
This is a known source of bugs.
Sometimes such reuse of a name in an inner scope is called "shadowing".</p>
<h5 id="note_2">Note<a class="headerlink" href="#note_2" title="Permanent link">&para;</a></h5>
<p>Shadowing is primarily a problem when functions are too large and too complex.</p>
<h5 id="example_14">Example<a class="headerlink" href="#example_14" title="Permanent link">&para;</a></h5>
<p>Shadowing of function arguments in the outermost block is disallowed by the language:</p>
<div class="language-text highlight"><pre><span></span><code>void f(int x)
{
    int x = 4;  // error: reuse of function argument name

    if (x) {
        int x = 7;  // allowed, but bad
        // ...
    }
}
</code></pre></div>
<h5 id="example-bad_6">Example, bad<a class="headerlink" href="#example-bad_6" title="Permanent link">&para;</a></h5>
<p>Reuse of a member name as a local variable can also be a problem:</p>
<div class="language-text highlight"><pre><span></span><code>struct S {
    int m;
    void f(int x);
};

void S::f(int x)
{
    m = 7;    // assign to member
    if (x) {
        int m = 9;
        // ...
        m = 99; // assign to local variable
        // ...
    }
}
</code></pre></div>
<h5 id="exception_5">Exception<a class="headerlink" href="#exception_5" title="Permanent link">&para;</a></h5>
<p>We often reuse function names from a base class in a derived class:</p>
<div class="language-text highlight"><pre><span></span><code>struct B {
    void f(int);
};

struct D : B {
    void f(double);
    using B::f;
};
</code></pre></div>
<p>This is error-prone.
For example, had we forgotten the using declaration, a call <code>d.f(1)</code> would not have found the <code>int</code> version of <code>f</code>.</p>
<p>??? Do we need a specific rule about shadowing/hiding in class hierarchies?</p>
<h5 id="enforcement_10">Enforcement<a class="headerlink" href="#enforcement_10" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag reuse of a name in nested local scopes</li>
<li>Flag reuse of a member name as a local variable in a member function</li>
<li>Flag reuse of a global name as a local variable or a member name</li>
<li>Flag reuse of a base class member name in a derived class (except for function names)</li>
</ul>
<h3 id="es20-always-initialize-an-object"><a name="Res-always"></a>ES.20: Always initialize an object<a class="headerlink" href="#es20-always-initialize-an-object" title="Permanent link">&para;</a></h3>
<h5 id="reason_10">Reason<a class="headerlink" href="#reason_10" title="Permanent link">&para;</a></h5>
<p>Avoid used-before-set errors and their associated undefined behavior.
Avoid problems with comprehension of complex initialization.
Simplify refactoring.</p>
<h5 id="example_15">Example<a class="headerlink" href="#example_15" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void use(int arg)
{
    int i;   // bad: uninitialized variable
    // ...
    i = 7;   // initialize i
}
</code></pre></div>
<p>No, <code>i = 7</code> does not initialize <code>i</code>; it assigns to it. Also, <code>i</code> can be read in the <code>...</code> part. Better:</p>
<div class="language-text highlight"><pre><span></span><code>void use(int arg)   // OK
{
    int i = 7;   // OK: initialized
    string s;    // OK: default initialized
    // ...
}
</code></pre></div>
<h5 id="note_3">Note<a class="headerlink" href="#note_3" title="Permanent link">&para;</a></h5>
<p>The <em>always initialize</em> rule is deliberately stronger than the <em>an object must be set before used</em> language rule.
The latter, more relaxed rule, catches the technical bugs, but:</p>
<ul>
<li>It leads to less readable code</li>
<li>It encourages people to declare names in greater than necessary scopes</li>
<li>It leads to harder to read code</li>
<li>It leads to logic bugs by encouraging complex code</li>
<li>It hampers refactoring</li>
</ul>
<p>The <em>always initialize</em> rule is a style rule aimed to improve maintainability as well as a rule protecting against used-before-set errors.</p>
<h5 id="example_16">Example<a class="headerlink" href="#example_16" title="Permanent link">&para;</a></h5>
<p>Here is an example that is often considered to demonstrate the need for a more relaxed rule for initialization</p>
<div class="language-text highlight"><pre><span></span><code>widget i;    // &quot;widget&quot; a type that&#39;s expensive to initialize, possibly a large trivial type
widget j;

if (cond) {  // bad: i and j are initialized &quot;late&quot;
    i = f1();
    j = f2();
}
else {
    i = f3();
    j = f4();
}
</code></pre></div>
<p>This cannot trivially be rewritten to initialize <code>i</code> and <code>j</code> with initializers.
Note that for types with a default constructor, attempting to postpone initialization simply leads to a default initialization followed by an assignment.
A popular reason for such examples is "efficiency", but a compiler that can detect whether we made a used-before-set error can also eliminate any redundant double initialization.</p>
<p>Assuming that there is a logical connection between <code>i</code> and <code>j</code>, that connection should probably be expressed in code:</p>
<div class="language-text highlight"><pre><span></span><code>pair&lt;widget, widget&gt; make_related_widgets(bool x)
{
    return (x) ? {f1(), f2()} : {f3(), f4()};
}

auto [i, j] = make_related_widgets(cond);    // C++17
</code></pre></div>
<p>If the <code>make_related_widgets</code> function is otherwise redundant,
we can eliminate it by using a lambda <a href="#Res-lambda-init">ES.28</a>:</p>
<div class="language-text highlight"><pre><span></span><code>auto [i, j] = [x] { return (x) ? pair{f1(), f2()} : pair{f3(), f4()} }();    // C++17
</code></pre></div>
<p>Using a value representing "uninitialized" is a symptom of a problem and not a solution:</p>
<div class="language-text highlight"><pre><span></span><code>widget i = uninit;  // bad
widget j = uninit;

// ...
use(i);         // possibly used before set
// ...

if (cond) {     // bad: i and j are initialized &quot;late&quot;
    i = f1();
    j = f2();
}
else {
    i = f3();
    j = f4();
}
</code></pre></div>
<p>Now the compiler cannot even simply detect a used-before-set. Further, we've introduced complexity in the state space for widget: which operations are valid on an <code>uninit</code> widget and which are not?</p>
<h5 id="note_4">Note<a class="headerlink" href="#note_4" title="Permanent link">&para;</a></h5>
<p>Complex initialization has been popular with clever programmers for decades.
It has also been a major source of errors and complexity.
Many such errors are introduced during maintenance years after the initial implementation.</p>
<h5 id="example_17">Example<a class="headerlink" href="#example_17" title="Permanent link">&para;</a></h5>
<p>This rule covers data members.</p>
<div class="language-text highlight"><pre><span></span><code>class X {
public:
    X(int i, int ci) : m2{i}, cm2{ci} {}
    // ...

private:
    int m1 = 7;
    int m2;
    int m3;

    const int cm1 = 7;
    const int cm2;
    const int cm3;
};
</code></pre></div>
<p>The compiler will flag the uninitialized <code>cm3</code> because it is a <code>const</code>, but it will not catch the lack of initialization of <code>m3</code>.
Usually, a rare spurious member initialization is worth the absence of errors from lack of initialization and often an optimizer
can eliminate a redundant initialization (e.g., an initialization that occurs immediately before an assignment).</p>
<h5 id="exception_6">Exception<a class="headerlink" href="#exception_6" title="Permanent link">&para;</a></h5>
<p>If you are declaring an object that is just about to be initialized from input, initializing it would cause a double initialization.
However, beware that this might leave uninitialized data beyond the input -- and that has been a fertile source of errors and security breaches:</p>
<div class="language-text highlight"><pre><span></span><code>constexpr int max = 8 * 1024;
int buf[max];         // OK, but suspicious: uninitialized
f.read(buf, max);
</code></pre></div>
<p>The cost of initializing that array could be significant in some situations.
However, such examples do tend to leave uninitialized variables accessible, so they should be treated with suspicion.</p>
<div class="language-text highlight"><pre><span></span><code>constexpr int max = 8 * 1024;
int buf[max] = {};   // zero all elements; better in some situations
f.read(buf, max);
</code></pre></div>
<p>Because of the restrictive initialization rules for arrays and <code>std::array</code>, they offer the most compelling examples of the need for this exception.</p>
<p>When feasible use a library function that is known not to overflow. For example:</p>
<div class="language-text highlight"><pre><span></span><code>string s;   // s is default initialized to &quot;&quot;
cin &gt;&gt; s;   // s expands to hold the string
</code></pre></div>
<p>Don't consider simple variables that are targets for input operations exceptions to this rule:</p>
<div class="language-text highlight"><pre><span></span><code>int i;   // bad
// ...
cin &gt;&gt; i;
</code></pre></div>
<p>In the not uncommon case where the input target and the input operation get separated (as they should not) the possibility of used-before-set opens up.</p>
<div class="language-text highlight"><pre><span></span><code>int i2 = 0;   // better, assuming that zero is an acceptable value for i2
// ...
cin &gt;&gt; i2;
</code></pre></div>
<p>A good optimizer should know about input operations and eliminate the redundant operation.</p>
<h5 id="note_5">Note<a class="headerlink" href="#note_5" title="Permanent link">&para;</a></h5>
<p>Sometimes, a lambda can be used as an initializer to avoid an uninitialized variable:</p>
<div class="language-text highlight"><pre><span></span><code>error_code ec;
Value v = [&amp;] {
    auto p = get_value();   // get_value() returns a pair&lt;error_code, Value&gt;
    ec = p.first;
    return p.second;
}();
</code></pre></div>
<p>or maybe:</p>
<div class="language-text highlight"><pre><span></span><code>Value v = [] {
    auto p = get_value();   // get_value() returns a pair&lt;error_code, Value&gt;
    if (p.first) throw Bad_value{p.first};
    return p.second;
}();
</code></pre></div>
<p><strong>See also</strong>: <a href="#Res-lambda-init">ES.28</a></p>
<h5 id="enforcement_11">Enforcement<a class="headerlink" href="#enforcement_11" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag every uninitialized variable.
  Don't flag variables of user-defined types with default constructors.</li>
<li>Check that an uninitialized buffer is written into <em>immediately</em> after declaration.
  Passing an uninitialized variable as a reference to non-<code>const</code> argument can be assumed to be a write into the variable.</li>
</ul>
<h3 id="es21-dont-introduce-a-variable-or-constant-before-you-need-to-use-it"><a name="Res-introduce"></a>ES.21: Don't introduce a variable (or constant) before you need to use it<a class="headerlink" href="#es21-dont-introduce-a-variable-or-constant-before-you-need-to-use-it" title="Permanent link">&para;</a></h3>
<h5 id="reason_11">Reason<a class="headerlink" href="#reason_11" title="Permanent link">&para;</a></h5>
<p>Readability. To limit the scope in which the variable can be used.</p>
<h5 id="example_18">Example<a class="headerlink" href="#example_18" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int x = 7;
// ... no use of x here ...
++x;
</code></pre></div>
<h5 id="enforcement_12">Enforcement<a class="headerlink" href="#enforcement_12" title="Permanent link">&para;</a></h5>
<p>Flag declarations that are distant from their first use.</p>
<h3 id="es22-dont-declare-a-variable-until-you-have-a-value-to-initialize-it-with"><a name="Res-init"></a>ES.22: Don't declare a variable until you have a value to initialize it with<a class="headerlink" href="#es22-dont-declare-a-variable-until-you-have-a-value-to-initialize-it-with" title="Permanent link">&para;</a></h3>
<h5 id="reason_12">Reason<a class="headerlink" href="#reason_12" title="Permanent link">&para;</a></h5>
<p>Readability. Limit the scope in which a variable can be used. Don't risk used-before-set. Initialization is often more efficient than assignment.</p>
<h5 id="example-bad_7">Example, bad<a class="headerlink" href="#example-bad_7" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>string s;
// ... no use of s here ...
s = &quot;what a waste&quot;;
</code></pre></div>
<h5 id="example-bad_8">Example, bad<a class="headerlink" href="#example-bad_8" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>SomeLargeType var;  // Hard-to-read CaMeLcAsEvArIaBlE

if (cond)   // some non-trivial condition
    Set(&amp;var);
else if (cond2 || !cond3) {
    var = Set2(3.14);
}
else {
    var = 0;
    for (auto&amp; e : something)
        var += e;
}

// use var; that this isn&#39;t done too early can be enforced statically with only control flow
</code></pre></div>
<p>This would be fine if there was a default initialization for <code>SomeLargeType</code> that wasn't too expensive.
Otherwise, a programmer might very well wonder if every possible path through the maze of conditions has been covered.
If not, we have a "use before set" bug. This is a maintenance trap.</p>
<p>For initializers of moderate complexity, including for <code>const</code> variables, consider using a lambda to express the initializer; see <a href="#Res-lambda-init">ES.28</a>.</p>
<h5 id="enforcement_13">Enforcement<a class="headerlink" href="#enforcement_13" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag declarations with default initialization that are assigned to before they are first read.</li>
<li>Flag any complicated computation after an uninitialized variable and before its use.</li>
</ul>
<h3 id="es23-prefer-the-initializer-syntax"><a name="Res-list"></a>ES.23: Prefer the <code>{}</code>-initializer syntax<a class="headerlink" href="#es23-prefer-the-initializer-syntax" title="Permanent link">&para;</a></h3>
<h5 id="reason_13">Reason<a class="headerlink" href="#reason_13" title="Permanent link">&para;</a></h5>
<p>Prefer <code>{}</code>. The rules for <code>{}</code> initialization are simpler, more general, less ambiguous, and safer than for other forms of initialization.</p>
<p>Use <code>=</code> only when you are sure that there can be no narrowing conversions. For built-in arithmetic types, use <code>=</code> only with <code>auto</code>.</p>
<p>Avoid <code>()</code> initialization, which allows parsing ambiguities.</p>
<h5 id="example_19">Example<a class="headerlink" href="#example_19" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int x {f(99)};
int y = x;
vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6};
</code></pre></div>
<h5 id="exception_7">Exception<a class="headerlink" href="#exception_7" title="Permanent link">&para;</a></h5>
<p>For containers, there is a tradition for using <code>{...}</code> for a list of elements and <code>(...)</code> for sizes:</p>
<div class="language-text highlight"><pre><span></span><code>vector&lt;int&gt; v1(10);    // vector of 10 elements with the default value 0
vector&lt;int&gt; v2{10};    // vector of 1 element with the value 10

vector&lt;int&gt; v3(1, 2);  // vector of 1 element with the value 2
vector&lt;int&gt; v4{1, 2};  // vector of 2 elements with the values 1 and 2
</code></pre></div>
<h5 id="note_6">Note<a class="headerlink" href="#note_6" title="Permanent link">&para;</a></h5>
<p><code>{}</code>-initializers do not allow narrowing conversions (and that is usually a good thing) and allow explicit constructors (which is fine, we're intentionally initializing a new variable).</p>
<h5 id="example_20">Example<a class="headerlink" href="#example_20" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int x {7.9};   // error: narrowing
int y = 7.9;   // OK: y becomes 7. Hope for a compiler warning
int z {gsl::narrow_cast&lt;int&gt;(7.9)};    // OK: you asked for it
auto zz = gsl::narrow_cast&lt;int&gt;(7.9);  // OK: you asked for it
</code></pre></div>
<h5 id="note_7">Note<a class="headerlink" href="#note_7" title="Permanent link">&para;</a></h5>
<p><code>{}</code> initialization can be used for nearly all initialization; other forms of initialization can't:</p>
<div class="language-text highlight"><pre><span></span><code>auto p = new vector&lt;int&gt; {1, 2, 3, 4, 5};   // initialized vector
D::D(int a, int b) :m{a, b} {   // member initializer (e.g., m might be a pair)
    // ...
};
X var {};   // initialize var to be empty
struct S {
    int m {7};   // default initializer for a member
    // ...
};
</code></pre></div>
<p>For that reason, <code>{}</code>-initialization is often called "uniform initialization"
(though there unfortunately are a few irregularities left).</p>
<h5 id="note_8">Note<a class="headerlink" href="#note_8" title="Permanent link">&para;</a></h5>
<p>Initialization of a variable declared using <code>auto</code> with a single value, e.g., <code>{v}</code>, had surprising results until C++17.
The C++17 rules are somewhat less surprising:</p>
<div class="language-text highlight"><pre><span></span><code>auto x1 {7};        // x1 is an int with the value 7
auto x2 = {7};      // x2 is an initializer_list&lt;int&gt; with an element 7

auto x11 {7, 8};    // error: two initializers
auto x22 = {7, 8};  // x22 is an initializer_list&lt;int&gt; with elements 7 and 8
</code></pre></div>
<p>Use <code>={...}</code> if you really want an <code>initializer_list&lt;T&gt;</code></p>
<div class="language-text highlight"><pre><span></span><code>auto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};   // fib10 is a list
</code></pre></div>
<h5 id="note_9">Note<a class="headerlink" href="#note_9" title="Permanent link">&para;</a></h5>
<p><code>={}</code> gives copy initialization whereas <code>{}</code> gives direct initialization.
Like the distinction between copy-initialization and direct-initialization itself, this can lead to surprises.
<code>{}</code> accepts <code>explicit</code> constructors; <code>={}</code> does not. For example:</p>
<div class="language-text highlight"><pre><span></span><code>struct Z { explicit Z() {} };

Z z1{};     // OK: direct initialization, so we use explicit constructor
Z z2 = {};  // error: copy initialization, so we cannot use the explicit constructor
</code></pre></div>
<p>Use plain <code>{}</code>-initialization unless you specifically want to disable explicit constructors.</p>
<h5 id="example_21">Example<a class="headerlink" href="#example_21" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
void f()
{
    T x1(1);    // T initialized with 1
    T x0();     // bad: function declaration (often a mistake)

    T y1 {1};   // T initialized with 1
    T y0 {};    // default initialized T
    // ...
}
</code></pre></div>
<p><strong>See also</strong>: <a href="#???">Discussion</a></p>
<h5 id="enforcement_14">Enforcement<a class="headerlink" href="#enforcement_14" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag uses of <code>=</code> to initialize arithmetic types where narrowing occurs.</li>
<li>Flag uses of <code>()</code> initialization syntax that are actually declarations. (Many compilers should warn on this already.)</li>
</ul>
<h3 id="es24-use-a-unique_ptrt-to-hold-pointers"><a name="Res-unique"></a>ES.24: Use a <code>unique_ptr&lt;T&gt;</code> to hold pointers<a class="headerlink" href="#es24-use-a-unique_ptrt-to-hold-pointers" title="Permanent link">&para;</a></h3>
<h5 id="reason_14">Reason<a class="headerlink" href="#reason_14" title="Permanent link">&para;</a></h5>
<p>Using <code>std::unique_ptr</code> is the simplest way to avoid leaks. It is reliable, it
makes the type system do much of the work to validate ownership safety, it
increases readability, and it has zero or near zero run-time cost.</p>
<h5 id="example_22">Example<a class="headerlink" href="#example_22" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void use(bool leak)
{
    auto p1 = make_unique&lt;int&gt;(7);   // OK
    int* p2 = new int{7};            // bad: might leak
    // ... no assignment to p2 ...
    if (leak) return;
    // ... no assignment to p2 ...
    vector&lt;int&gt; v(7);
    v.at(7) = 0;                    // exception thrown
    delete p2;                      // too late to prevent leaks
    // ...
}
</code></pre></div>
<p>If <code>leak == true</code> the object pointed to by <code>p2</code> is leaked and the object pointed to by <code>p1</code> is not.
The same is the case when <code>at()</code> throws. In both cases, the <code>delete p2</code> statement is not reached.</p>
<h5 id="enforcement_15">Enforcement<a class="headerlink" href="#enforcement_15" title="Permanent link">&para;</a></h5>
<p>Look for raw pointers that are targets of <code>new</code>, <code>malloc()</code>, or functions that might return such pointers.</p>
<h3 id="es25-declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on"><a name="Res-const"></a>ES.25: Declare an object <code>const</code> or <code>constexpr</code> unless you want to modify its value later on<a class="headerlink" href="#es25-declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on" title="Permanent link">&para;</a></h3>
<h5 id="reason_15">Reason<a class="headerlink" href="#reason_15" title="Permanent link">&para;</a></h5>
<p>That way you can't change the value by mistake. That way might offer the compiler optimization opportunities.</p>
<h5 id="example_23">Example<a class="headerlink" href="#example_23" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(int n)
{
    const int bufmax = 2 * n + 2;  // good: we can&#39;t change bufmax by accident
    int xmax = n;                  // suspicious: is xmax intended to change?
    // ...
}
</code></pre></div>
<h5 id="enforcement_16">Enforcement<a class="headerlink" href="#enforcement_16" title="Permanent link">&para;</a></h5>
<p>Look to see if a variable is actually mutated, and flag it if
not. Unfortunately, it might be impossible to detect when a non-<code>const</code> was not
<em>intended</em> to vary (vs when it merely did not vary).</p>
<h3 id="es26-dont-use-a-variable-for-two-unrelated-purposes"><a name="Res-recycle"></a>ES.26: Don't use a variable for two unrelated purposes<a class="headerlink" href="#es26-dont-use-a-variable-for-two-unrelated-purposes" title="Permanent link">&para;</a></h3>
<h5 id="reason_16">Reason<a class="headerlink" href="#reason_16" title="Permanent link">&para;</a></h5>
<p>Readability and safety.</p>
<h5 id="example-bad_9">Example, bad<a class="headerlink" href="#example-bad_9" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void use()
{
    int i;
    for (i = 0; i &lt; 20; ++i) { /* ... */ }
    for (i = 0; i &lt; 200; ++i) { /* ... */ } // bad: i recycled
}
</code></pre></div>
<h5 id="note_10">Note<a class="headerlink" href="#note_10" title="Permanent link">&para;</a></h5>
<p>As an optimization, you might want to reuse a buffer as a scratch pad, but even then prefer to limit the variable's scope as much as possible and be careful not to cause bugs from data left in a recycled buffer as this is a common source of security bugs.</p>
<div class="language-text highlight"><pre><span></span><code>void write_to_file()
{
    std::string buffer;             // to avoid reallocations on every loop iteration
    for (auto&amp; o : objects) {
        // First part of the work.
        generate_first_string(buffer, o);
        write_to_file(buffer);

        // Second part of the work.
        generate_second_string(buffer, o);
        write_to_file(buffer);

        // etc...
    }
}
</code></pre></div>
<h5 id="enforcement_17">Enforcement<a class="headerlink" href="#enforcement_17" title="Permanent link">&para;</a></h5>
<p>Flag recycled variables.</p>
<h3 id="es27-use-stdarray-or-stack_array-for-arrays-on-the-stack"><a name="Res-stack"></a>ES.27: Use <code>std::array</code> or <code>stack_array</code> for arrays on the stack<a class="headerlink" href="#es27-use-stdarray-or-stack_array-for-arrays-on-the-stack" title="Permanent link">&para;</a></h3>
<h5 id="reason_17">Reason<a class="headerlink" href="#reason_17" title="Permanent link">&para;</a></h5>
<p>They are readable and don't implicitly convert to pointers.
They are not confused with non-standard extensions of built-in arrays.</p>
<h5 id="example-bad_10">Example, bad<a class="headerlink" href="#example-bad_10" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>const int n = 7;
int m = 9;

void f()
{
    int a1[n];
    int a2[m];   // error: not ISO C++
    // ...
}
</code></pre></div>
<h5 id="note_11">Note<a class="headerlink" href="#note_11" title="Permanent link">&para;</a></h5>
<p>The definition of <code>a1</code> is legal C++ and has always been.
There is a lot of such code.
It is error-prone, though, especially when the bound is non-local.
Also, it is a "popular" source of errors (buffer overflow, pointers from array decay, etc.).
The definition of <code>a2</code> is C but not C++ and is considered a security risk</p>
<h5 id="example_24">Example<a class="headerlink" href="#example_24" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>const int n = 7;
int m = 9;

void f()
{
    array&lt;int, n&gt; a1;
    stack_array&lt;int&gt; a2(m);
    // ...
}
</code></pre></div>
<h5 id="enforcement_18">Enforcement<a class="headerlink" href="#enforcement_18" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag arrays with non-constant bounds (C-style VLAs)</li>
<li>Flag arrays with non-local constant bounds</li>
</ul>
<h3 id="es28-use-lambdas-for-complex-initialization-especially-of-const-variables"><a name="Res-lambda-init"></a>ES.28: Use lambdas for complex initialization, especially of <code>const</code> variables<a class="headerlink" href="#es28-use-lambdas-for-complex-initialization-especially-of-const-variables" title="Permanent link">&para;</a></h3>
<h5 id="reason_18">Reason<a class="headerlink" href="#reason_18" title="Permanent link">&para;</a></h5>
<p>It nicely encapsulates local initialization, including cleaning up scratch variables needed only for the initialization, without needing to create a needless non-local yet non-reusable function. It also works for variables that should be <code>const</code> but only after some initialization work.</p>
<h5 id="example-bad_11">Example, bad<a class="headerlink" href="#example-bad_11" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>widget x;   // should be const, but:
for (auto i = 2; i &lt;= N; ++i) {          // this could be some
    x += some_obj.do_something_with(i);  // arbitrarily long code
}                                        // needed to initialize x
// from here, x should be const, but we can&#39;t say so in code in this style
</code></pre></div>
<h5 id="example-good">Example, good<a class="headerlink" href="#example-good" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>const widget x = [&amp;] {
    widget val;                                // assume that widget has a default constructor
    for (auto i = 2; i &lt;= N; ++i) {            // this could be some
        val += some_obj.do_something_with(i);  // arbitrarily long code
    }                                          // needed to initialize x
    return val;
}();
</code></pre></div>
<p>If at all possible, reduce the conditions to a simple set of alternatives (e.g., an <code>enum</code>) and don't mix up selection and initialization.</p>
<h5 id="enforcement_19">Enforcement<a class="headerlink" href="#enforcement_19" title="Permanent link">&para;</a></h5>
<p>Hard. At best a heuristic. Look for an uninitialized variable followed by a loop assigning to it.</p>
<h3 id="es30-dont-use-macros-for-program-text-manipulation"><a name="Res-macros"></a>ES.30: Don't use macros for program text manipulation<a class="headerlink" href="#es30-dont-use-macros-for-program-text-manipulation" title="Permanent link">&para;</a></h3>
<h5 id="reason_19">Reason<a class="headerlink" href="#reason_19" title="Permanent link">&para;</a></h5>
<p>Macros are a major source of bugs.
Macros don't obey the usual scope and type rules.
Macros ensure that the human reader sees something different from what the compiler sees.
Macros complicate tool building.</p>
<h5 id="example-bad_12">Example, bad<a class="headerlink" href="#example-bad_12" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>#define Case break; case   /* BAD */
</code></pre></div>
<p>This innocuous-looking macro makes a single lower case <code>c</code> instead of a <code>C</code> into a bad flow-control bug.</p>
<h5 id="note_12">Note<a class="headerlink" href="#note_12" title="Permanent link">&para;</a></h5>
<p>This rule does not ban the use of macros for "configuration control" use in <code>#ifdef</code>s, etc.</p>
<p>In the future, modules are likely to eliminate the need for macros in configuration control.</p>
<h5 id="note_13">Note<a class="headerlink" href="#note_13" title="Permanent link">&para;</a></h5>
<p>This rule is meant to also discourage use of <code>#</code> for stringification and <code>##</code> for concatenation.
As usual for macros, there are uses that are "mostly harmless", but even these can create problems for tools,
such as auto completers, static analyzers, and debuggers.
Often the desire to use fancy macros is a sign of an overly complex design.
Also, <code>#</code> and <code>##</code> encourages the definition and use of macros:</p>
<div class="language-text highlight"><pre><span></span><code>#define CAT(a, b) a ## b
#define STRINGIFY(a) #a

void f(int x, int y)
{
    string CAT(x, y) = &quot;asdf&quot;;   // BAD: hard for tools to handle (and ugly)
    string sx2 = STRINGIFY(x);
    // ...
}
</code></pre></div>
<p>There are workarounds for low-level string manipulation using macros. For example:</p>
<div class="language-text highlight"><pre><span></span><code>enum E { a, b };

template&lt;int x&gt;
constexpr const char* stringify()
{
    switch (x) {
    case a: return &quot;a&quot;;
    case b: return &quot;b&quot;;
    }
}

void f()
{
    string s1 = stringify&lt;a&gt;();
    string s2 = stringify&lt;b&gt;();
    // ...
}
</code></pre></div>
<p>This is not as convenient as a macro to define, but as easy to use, has zero overhead, and is typed and scoped.</p>
<p>In the future, static reflection is likely to eliminate the last needs for the preprocessor for program text manipulation.</p>
<h5 id="enforcement_20">Enforcement<a class="headerlink" href="#enforcement_20" title="Permanent link">&para;</a></h5>
<p>Scream when you see a macro that isn't just used for source control (e.g., <code>#ifdef</code>)</p>
<h3 id="es31-dont-use-macros-for-constants-or-functions"><a name="Res-macros2"></a>ES.31: Don't use macros for constants or "functions"<a class="headerlink" href="#es31-dont-use-macros-for-constants-or-functions" title="Permanent link">&para;</a></h3>
<h5 id="reason_20">Reason<a class="headerlink" href="#reason_20" title="Permanent link">&para;</a></h5>
<p>Macros are a major source of bugs.
Macros don't obey the usual scope and type rules.
Macros don't obey the usual rules for argument passing.
Macros ensure that the human reader sees something different from what the compiler sees.
Macros complicate tool building.</p>
<h5 id="example-bad_13">Example, bad<a class="headerlink" href="#example-bad_13" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>#define PI 3.14
#define SQUARE(a, b) (a * b)
</code></pre></div>
<p>Even if we hadn't left a well-known bug in <code>SQUARE</code> there are much better behaved alternatives; for example:</p>
<div class="language-text highlight"><pre><span></span><code>constexpr double pi = 3.14;
template&lt;typename T&gt; T square(T a, T b) { return a * b; }
</code></pre></div>
<h5 id="enforcement_21">Enforcement<a class="headerlink" href="#enforcement_21" title="Permanent link">&para;</a></h5>
<p>Scream when you see a macro that isn't just used for source control (e.g., <code>#ifdef</code>)</p>
<h3 id="es32-use-all_caps-for-all-macro-names"><a name="Res-ALL_CAPS"></a>ES.32: Use <code>ALL_CAPS</code> for all macro names<a class="headerlink" href="#es32-use-all_caps-for-all-macro-names" title="Permanent link">&para;</a></h3>
<h5 id="reason_21">Reason<a class="headerlink" href="#reason_21" title="Permanent link">&para;</a></h5>
<p>Convention. Readability. Distinguishing macros.</p>
<h5 id="example_25">Example<a class="headerlink" href="#example_25" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>#define forever for (;;)   /* very BAD */

#define FOREVER for (;;)   /* Still evil, but at least visible to humans */
</code></pre></div>
<h5 id="enforcement_22">Enforcement<a class="headerlink" href="#enforcement_22" title="Permanent link">&para;</a></h5>
<p>Scream when you see a lower case macro.</p>
<h3 id="es33-if-you-must-use-macros-give-them-unique-names"><a name="Res-MACROS"></a>ES.33: If you must use macros, give them unique names<a class="headerlink" href="#es33-if-you-must-use-macros-give-them-unique-names" title="Permanent link">&para;</a></h3>
<h5 id="reason_22">Reason<a class="headerlink" href="#reason_22" title="Permanent link">&para;</a></h5>
<p>Macros do not obey scope rules.</p>
<h5 id="example_26">Example<a class="headerlink" href="#example_26" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>#define MYCHAR        /* BAD, will eventually clash with someone else&#39;s MYCHAR*/

#define ZCORP_CHAR    /* Still evil, but less likely to clash */
</code></pre></div>
<h5 id="note_14">Note<a class="headerlink" href="#note_14" title="Permanent link">&para;</a></h5>
<p>Avoid macros if you can: <a href="#Res-macros">ES.30</a>, <a href="#Res-macros2">ES.31</a>, and <a href="#Res-ALL_CAPS">ES.32</a>.
However, there are billions of lines of code littered with macros and a long tradition for using and overusing macros.
If you are forced to use macros, use long names and supposedly unique prefixes (e.g., your organization's name) to lower the likelihood of a clash.</p>
<h5 id="enforcement_23">Enforcement<a class="headerlink" href="#enforcement_23" title="Permanent link">&para;</a></h5>
<p>Warn against short macro names.</p>
<h3 id="es34-dont-define-a-c-style-variadic-function"><a name="Res-ellipses"></a> ES.34: Don't define a (C-style) variadic function<a class="headerlink" href="#es34-dont-define-a-c-style-variadic-function" title="Permanent link">&para;</a></h3>
<h5 id="reason_23">Reason<a class="headerlink" href="#reason_23" title="Permanent link">&para;</a></h5>
<p>Not type safe.
Requires messy cast-and-macro-laden code to get working right.</p>
<h5 id="example_27">Example<a class="headerlink" href="#example_27" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>#include &lt;cstdarg&gt;

// &quot;severity&quot; followed by a zero-terminated list of char*s; write the C-style strings to cerr
void error(int severity ...)
{
    va_list ap;             // a magic type for holding arguments
    va_start(ap, severity); // arg startup: &quot;severity&quot; is the first argument of error()

    for (;;) {
        // treat the next var as a char*; no checking: a cast in disguise
        char* p = va_arg(ap, char*);
        if (!p) break;
        cerr &lt;&lt; p &lt;&lt; &#39; &#39;;
    }

    va_end(ap);             // arg cleanup (don&#39;t forget this)

    cerr &lt;&lt; &#39;\n&#39;;
    if (severity) exit(severity);
}

void use()
{
    error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;, nullptr);
    error(7); // crash
    error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;);  // crash
    const char* is = &quot;is&quot;;
    string an = &quot;an&quot;;
    error(7, &quot;this&quot;, is, an, &quot;error&quot;); // crash
}
</code></pre></div>
<p><strong>Alternative</strong>: Overloading. Templates. Variadic templates.</p>
<div class="language-text highlight"><pre><span></span><code>#include &lt;iostream&gt;

void error(int severity)
{
    std::cerr &lt;&lt; &#39;\n&#39;;
    std::exit(severity);
}

template&lt;typename T, typename... Ts&gt;
constexpr void error(int severity, T head, Ts... tail)
{
    std::cerr &lt;&lt; head;
    error(severity, tail...);
}

void use()
{
    error(7); // No crash!
    error(5, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, &quot;an&quot;, &quot;error&quot;); // No crash!

    std::string an = &quot;an&quot;;
    error(7, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, an, &quot;error&quot;); // No crash!

    error(5, &quot;oh&quot;, &quot;no&quot;, nullptr); // Compile error! No need for nullptr.
}
</code></pre></div>
<h5 id="note_15">Note<a class="headerlink" href="#note_15" title="Permanent link">&para;</a></h5>
<p>This is basically the way <code>printf</code> is implemented.</p>
<h5 id="enforcement_24">Enforcement<a class="headerlink" href="#enforcement_24" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag definitions of C-style variadic functions.</li>
<li>Flag <code>#include &lt;cstdarg&gt;</code> and <code>#include &lt;stdarg.h&gt;</code></li>
</ul>
<h2 id="esexpr-expressions">ES.expr: Expressions<a class="headerlink" href="#esexpr-expressions" title="Permanent link">&para;</a></h2>
<p>Expressions manipulate values.</p>
<h3 id="es40-avoid-complicated-expressions"><a name="Res-complicated"></a>ES.40: Avoid complicated expressions<a class="headerlink" href="#es40-avoid-complicated-expressions" title="Permanent link">&para;</a></h3>
<h5 id="reason_24">Reason<a class="headerlink" href="#reason_24" title="Permanent link">&para;</a></h5>
<p>Complicated expressions are error-prone.</p>
<h5 id="example_28">Example<a class="headerlink" href="#example_28" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>// bad: assignment hidden in subexpression
while ((c = getc()) != -1)

// bad: two non-local variables assigned in sub-expressions
while ((cin &gt;&gt; c1, cin &gt;&gt; c2), c1 == c2)

// better, but possibly still too complicated
for (char c1, c2; cin &gt;&gt; c1 &gt;&gt; c2 &amp;&amp; c1 == c2;)

// OK: if i and j are not aliased
int x = ++i + ++j;

// OK: if i != j and i != k
v[i] = v[j] + v[k];

// bad: multiple assignments &quot;hidden&quot; in subexpressions
x = a + (b = f()) + (c = g()) * 7;

// bad: relies on commonly misunderstood precedence rules
x = a &amp; b + c * d &amp;&amp; e ^ f == 7;

// bad: undefined behavior
x = x++ + x++ + ++x;
</code></pre></div>
<p>Some of these expressions are unconditionally bad (e.g., they rely on undefined behavior). Others are simply so complicated and/or unusual that even good programmers could misunderstand them or overlook a problem when in a hurry.</p>
<h5 id="note_16">Note<a class="headerlink" href="#note_16" title="Permanent link">&para;</a></h5>
<p>C++17 tightens up the rules for the order of evaluation
(left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified; <a href="#Res-order">see ES.43</a>),
but that doesn't change the fact that complicated expressions are potentially confusing.</p>
<h5 id="note_17">Note<a class="headerlink" href="#note_17" title="Permanent link">&para;</a></h5>
<p>A programmer should know and use the basic rules for expressions.</p>
<h5 id="example_29">Example<a class="headerlink" href="#example_29" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>x = k * y + z;             // OK

auto t1 = k * y;           // bad: unnecessarily verbose
x = t1 + z;

if (0 &lt;= x &amp;&amp; x &lt; max)   // OK

auto t1 = 0 &lt;= x;        // bad: unnecessarily verbose
auto t2 = x &lt; max;
if (t1 &amp;&amp; t2)            // ...
</code></pre></div>
<h5 id="enforcement_25">Enforcement<a class="headerlink" href="#enforcement_25" title="Permanent link">&para;</a></h5>
<p>Tricky. How complicated must an expression be to be considered complicated? Writing computations as statements with one operation each is also confusing. Things to consider:</p>
<ul>
<li>side effects: side effects on multiple non-local variables (for some definition of non-local) can be suspect, especially if the side effects are in separate subexpressions</li>
<li>writes to aliased variables</li>
<li>more than N operators (and what should N be?)</li>
<li>reliance of subtle precedence rules</li>
<li>uses undefined behavior (can we catch all undefined behavior?)</li>
<li>implementation defined behavior?</li>
<li>???</li>
</ul>
<h3 id="es41-if-in-doubt-about-operator-precedence-parenthesize"><a name="Res-parens"></a>ES.41: If in doubt about operator precedence, parenthesize<a class="headerlink" href="#es41-if-in-doubt-about-operator-precedence-parenthesize" title="Permanent link">&para;</a></h3>
<h5 id="reason_25">Reason<a class="headerlink" href="#reason_25" title="Permanent link">&para;</a></h5>
<p>Avoid errors. Readability. Not everyone has the operator table memorized.</p>
<h5 id="example_30">Example<a class="headerlink" href="#example_30" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>const unsigned int flag = 2;
unsigned int a = flag;

if (a &amp; flag != 0)  // bad: means a&amp;(flag != 0)
</code></pre></div>
<p>Note: We recommend that programmers know their precedence table for the arithmetic operations, the logical operations, but consider mixing bitwise logical operations with other operators in need of parentheses.</p>
<div class="language-text highlight"><pre><span></span><code>if ((a &amp; flag) != 0)  // OK: works as intended
</code></pre></div>
<h5 id="note_18">Note<a class="headerlink" href="#note_18" title="Permanent link">&para;</a></h5>
<p>You should know enough not to need parentheses for:</p>
<div class="language-text highlight"><pre><span></span><code>if (a &lt; 0 || a &lt;= max) {
    // ...
}
</code></pre></div>
<h5 id="enforcement_26">Enforcement<a class="headerlink" href="#enforcement_26" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag combinations of bitwise-logical operators and other operators.</li>
<li>Flag assignment operators not as the leftmost operator.</li>
<li>???</li>
</ul>
<h3 id="es42-keep-use-of-pointers-simple-and-straightforward"><a name="Res-ptr"></a>ES.42: Keep use of pointers simple and straightforward<a class="headerlink" href="#es42-keep-use-of-pointers-simple-and-straightforward" title="Permanent link">&para;</a></h3>
<h5 id="reason_26">Reason<a class="headerlink" href="#reason_26" title="Permanent link">&para;</a></h5>
<p>Complicated pointer manipulation is a major source of errors.</p>
<h5 id="note_19">Note<a class="headerlink" href="#note_19" title="Permanent link">&para;</a></h5>
<p>Use <code>gsl::span</code> instead.
Pointers should <a href="#Ri-array">only refer to single objects</a>.
Pointer arithmetic is fragile and easy to get wrong, the source of many, many bad bugs and security violations.
<code>span</code> is a bounds-checked, safe type for accessing arrays of data.
Access into an array with known bounds using a constant as a subscript can be validated by the compiler.</p>
<h5 id="example-bad_14">Example, bad<a class="headerlink" href="#example-bad_14" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(int* p, int count)
{
    if (count &lt; 2) return;

    int* q = p + 1;    // BAD

    ptrdiff_t d;
    int n;
    d = (p - &amp;n);      // OK
    d = (q - p);       // OK

    int n = *p++;      // BAD

    if (count &lt; 6) return;

    p[4] = 1;          // BAD

    p[count - 1] = 2;  // BAD

    use(&amp;p[0], 3);     // BAD
}
</code></pre></div>
<h5 id="example-good_1">Example, good<a class="headerlink" href="#example-good_1" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(span&lt;int&gt; a) // BETTER: use span in the function declaration
{
    if (a.size() &lt; 2) return;

    int n = a[0];      // OK

    span&lt;int&gt; q = a.subspan(1); // OK

    if (a.size() &lt; 6) return;

    a[4] = 1;          // OK

    a[a.size() - 1] = 2;  // OK

    use(a.data(), 3);  // OK
}
</code></pre></div>
<h5 id="note_20">Note<a class="headerlink" href="#note_20" title="Permanent link">&para;</a></h5>
<p>Subscripting with a variable is difficult for both tools and humans to validate as safe.
<code>span</code> is a run-time bounds-checked, safe type for accessing arrays of data.
<code>at()</code> is another alternative that ensures single accesses are bounds-checked.
If iterators are needed to access an array, use the iterators from a <code>span</code> constructed over the array.</p>
<h5 id="example-bad_15">Example, bad<a class="headerlink" href="#example-bad_15" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(array&lt;int, 10&gt; a, int pos)
{
    a[pos / 2] = 1; // BAD
    a[pos - 1] = 2; // BAD
    a[-1] = 3;    // BAD (but easily caught by tools) -- no replacement, just don&#39;t do this
    a[10] = 4;    // BAD (but easily caught by tools) -- no replacement, just don&#39;t do this
}
</code></pre></div>
<h5 id="example-good_2">Example, good<a class="headerlink" href="#example-good_2" title="Permanent link">&para;</a></h5>
<p>Use a <code>span</code>:</p>
<div class="language-text highlight"><pre><span></span><code>void f1(span&lt;int, 10&gt; a, int pos) // A1: Change parameter type to use span
{
    a[pos / 2] = 1; // OK
    a[pos - 1] = 2; // OK
}

void f2(array&lt;int, 10&gt; arr, int pos) // A2: Add local span and use that
{
    span&lt;int&gt; a = {arr.data(), pos};
    a[pos / 2] = 1; // OK
    a[pos - 1] = 2; // OK
}
</code></pre></div>
<p>Use <code>at()</code>:</p>
<div class="language-text highlight"><pre><span></span><code>void f3(array&lt;int, 10&gt; a, int pos) // ALTERNATIVE B: Use at() for access
{
    at(a, pos / 2) = 1; // OK
    at(a, pos - 1) = 2; // OK
}
</code></pre></div>
<h5 id="example-bad_16">Example, bad<a class="headerlink" href="#example-bad_16" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    int arr[COUNT];
    for (int i = 0; i &lt; COUNT; ++i)
        arr[i] = i; // BAD, cannot use non-constant indexer
}
</code></pre></div>
<h5 id="example-good_3">Example, good<a class="headerlink" href="#example-good_3" title="Permanent link">&para;</a></h5>
<p>Use a <code>span</code>:</p>
<div class="language-text highlight"><pre><span></span><code>void f1()
{
    int arr[COUNT];
    span&lt;int&gt; av = arr;
    for (int i = 0; i &lt; COUNT; ++i)
        av[i] = i;
}
</code></pre></div>
<p>Use a <code>span</code> and range-<code>for</code>:</p>
<div class="language-text highlight"><pre><span></span><code>void f1a()
{
     int arr[COUNT];
     span&lt;int, COUNT&gt; av = arr;
     int i = 0;
     for (auto&amp; e : av)
         e = i++;
}
</code></pre></div>
<p>Use <code>at()</code> for access:</p>
<div class="language-text highlight"><pre><span></span><code>void f2()
{
    int arr[COUNT];
    for (int i = 0; i &lt; COUNT; ++i)
        at(arr, i) = i;
}
</code></pre></div>
<p>Use a range-<code>for</code>:</p>
<div class="language-text highlight"><pre><span></span><code>void f3()
{
    int arr[COUNT];
    int i = 0;
    for (auto&amp; e : arr)
         e = i++;
}
</code></pre></div>
<h5 id="note_21">Note<a class="headerlink" href="#note_21" title="Permanent link">&para;</a></h5>
<p>Tooling can offer rewrites of array accesses that involve dynamic index expressions to use <code>at()</code> instead:</p>
<div class="language-text highlight"><pre><span></span><code>static int a[10];

void f(int i, int j)
{
    a[i + j] = 12;      // BAD, could be rewritten as ...
    at(a, i + j) = 12;  // OK -- bounds-checked
}
</code></pre></div>
<h5 id="example_31">Example<a class="headerlink" href="#example_31" title="Permanent link">&para;</a></h5>
<p>Turning an array into a pointer (as the language does essentially always) removes opportunities for checking, so avoid it</p>
<div class="language-text highlight"><pre><span></span><code>void g(int* p);

void f()
{
    int a[5];
    g(a);        // BAD: are we trying to pass an array?
    g(&amp;a[0]);    // OK: passing one object
}
</code></pre></div>
<p>If you want to pass an array, say so:</p>
<div class="language-text highlight"><pre><span></span><code>void g(int* p, size_t length);  // old (dangerous) code

void g1(span&lt;int&gt; av); // BETTER: get g() changed.

void f2()
{
    int a[5];
    span&lt;int&gt; av = a;

    g(av.data(), av.size());   // OK, if you have no choice
    g1(a);                     // OK -- no decay here, instead use implicit span ctor
}
</code></pre></div>
<h5 id="enforcement_27">Enforcement<a class="headerlink" href="#enforcement_27" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag any arithmetic operation on an expression of pointer type that results in a value of pointer type.</li>
<li>Flag any indexing expression on an expression or variable of array type (either static array or <code>std::array</code>) where the indexer is not a compile-time constant expression with a value between <code>0</code> and the upper bound of the array.</li>
<li>Flag any expression that would rely on implicit conversion of an array type to a pointer type.</li>
</ul>
<p>This rule is part of the <a href="#SS-bounds">bounds-safety profile</a>.</p>
<h3 id="es43-avoid-expressions-with-undefined-order-of-evaluation"><a name="Res-order"></a>ES.43: Avoid expressions with undefined order of evaluation<a class="headerlink" href="#es43-avoid-expressions-with-undefined-order-of-evaluation" title="Permanent link">&para;</a></h3>
<h5 id="reason_27">Reason<a class="headerlink" href="#reason_27" title="Permanent link">&para;</a></h5>
<p>You have no idea what such code does. Portability.
Even if it does something sensible for you, it might do something different on another compiler (e.g., the next release of your compiler) or with a different optimizer setting.</p>
<h5 id="note_22">Note<a class="headerlink" href="#note_22" title="Permanent link">&para;</a></h5>
<p>C++17 tightens up the rules for the order of evaluation:
left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified.</p>
<p>However, remember that your code might be compiled with a pre-C++17 compiler (e.g., through cut-and-paste) so don't be too clever.</p>
<h5 id="example_32">Example<a class="headerlink" href="#example_32" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>v[i] = ++i;   //  the result is undefined
</code></pre></div>
<p>A good rule of thumb is that you should not read a value twice in an expression where you write to it.</p>
<h5 id="enforcement_28">Enforcement<a class="headerlink" href="#enforcement_28" title="Permanent link">&para;</a></h5>
<p>Can be detected by a good analyzer.</p>
<h3 id="es44-dont-depend-on-order-of-evaluation-of-function-arguments"><a name="Res-order-fct"></a>ES.44: Don't depend on order of evaluation of function arguments<a class="headerlink" href="#es44-dont-depend-on-order-of-evaluation-of-function-arguments" title="Permanent link">&para;</a></h3>
<h5 id="reason_28">Reason<a class="headerlink" href="#reason_28" title="Permanent link">&para;</a></h5>
<p>Because that order is unspecified.</p>
<h5 id="note_23">Note<a class="headerlink" href="#note_23" title="Permanent link">&para;</a></h5>
<p>C++17 tightens up the rules for the order of evaluation, but the order of evaluation of function arguments is still unspecified.</p>
<h5 id="example_33">Example<a class="headerlink" href="#example_33" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int i = 0;
f(++i, ++i);
</code></pre></div>
<p>Before C++17, the behavior is undefined, so the behavior could be anything (e.g., <code>f(2, 2)</code>).
Since C++17, this code does not have undefined behavior, but it is still not specified which argument is evaluated first. The call will be <code>f(1, 2)</code> or <code>f(2, 1)</code>, but you don't know which.</p>
<h5 id="example_34">Example<a class="headerlink" href="#example_34" title="Permanent link">&para;</a></h5>
<p>Overloaded operators can lead to order of evaluation problems:</p>
<div class="language-text highlight"><pre><span></span><code>f1()-&gt;m(f2());          // m(f1(), f2())
cout &lt;&lt; f1() &lt;&lt; f2();   // operator&lt;&lt;(operator&lt;&lt;(cout, f1()), f2())
</code></pre></div>
<p>In C++17, these examples work as expected (left to right) and assignments are evaluated right to left (just as ='s binding is right-to-left)</p>
<div class="language-text highlight"><pre><span></span><code>f1() = f2();    // undefined behavior in C++14; in C++17, f2() is evaluated before f1()
</code></pre></div>
<h5 id="enforcement_29">Enforcement<a class="headerlink" href="#enforcement_29" title="Permanent link">&para;</a></h5>
<p>Can be detected by a good analyzer.</p>
<h3 id="es45-avoid-magic-constants-use-symbolic-constants"><a name="Res-magic"></a>ES.45: Avoid "magic constants"; use symbolic constants<a class="headerlink" href="#es45-avoid-magic-constants-use-symbolic-constants" title="Permanent link">&para;</a></h3>
<h5 id="reason_29">Reason<a class="headerlink" href="#reason_29" title="Permanent link">&para;</a></h5>
<p>Unnamed constants embedded in expressions are easily overlooked and often hard to understand:</p>
<h5 id="example_35">Example<a class="headerlink" href="#example_35" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>for (int m = 1; m &lt;= 12; ++m)   // don&#39;t: magic constant 12
    cout &lt;&lt; month[m] &lt;&lt; &#39;\n&#39;;
</code></pre></div>
<p>No, we don't all know that there are 12 months, numbered 1..12, in a year. Better:</p>
<div class="language-text highlight"><pre><span></span><code>// months are indexed 1..12
constexpr int first_month = 1;
constexpr int last_month = 12;

for (int m = first_month; m &lt;= last_month; ++m)   // better
    cout &lt;&lt; month[m] &lt;&lt; &#39;\n&#39;;
</code></pre></div>
<p>Better still, don't expose constants:</p>
<div class="language-text highlight"><pre><span></span><code>for (auto m : month)
    cout &lt;&lt; m &lt;&lt; &#39;\n&#39;;
</code></pre></div>
<h5 id="enforcement_30">Enforcement<a class="headerlink" href="#enforcement_30" title="Permanent link">&para;</a></h5>
<p>Flag literals in code. Give a pass to <code>0</code>, <code>1</code>, <code>nullptr</code>, <code>\n</code>, <code>""</code>, and others on a positive list.</p>
<h3 id="es46-avoid-lossy-narrowing-truncating-arithmetic-conversions"><a name="Res-narrowing"></a>ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions<a class="headerlink" href="#es46-avoid-lossy-narrowing-truncating-arithmetic-conversions" title="Permanent link">&para;</a></h3>
<h5 id="reason_30">Reason<a class="headerlink" href="#reason_30" title="Permanent link">&para;</a></h5>
<p>A narrowing conversion destroys information, often unexpectedly so.</p>
<h5 id="example-bad_17">Example, bad<a class="headerlink" href="#example-bad_17" title="Permanent link">&para;</a></h5>
<p>A key example is basic narrowing:</p>
<div class="language-text highlight"><pre><span></span><code>double d = 7.9;
int i = d;    // bad: narrowing: i becomes 7
i = (int) d;  // bad: we&#39;re going to claim this is still not explicit enough

void f(int x, long y, double d)
{
    char c1 = x;   // bad: narrowing
    char c2 = y;   // bad: narrowing
    char c3 = d;   // bad: narrowing
}
</code></pre></div>
<h5 id="note_24">Note<a class="headerlink" href="#note_24" title="Permanent link">&para;</a></h5>
<p>The guidelines support library offers a <code>narrow_cast</code> operation for specifying that narrowing is acceptable and a <code>narrow</code> ("narrow if") that throws an exception if a narrowing would throw away legal values:</p>
<div class="language-text highlight"><pre><span></span><code>i = gsl::narrow_cast&lt;int&gt;(d);   // OK (you asked for it): narrowing: i becomes 7
i = gsl::narrow&lt;int&gt;(d);        // OK: throws narrowing_error
</code></pre></div>
<p>We also include lossy arithmetic casts, such as from a negative floating point type to an unsigned integral type:</p>
<div class="language-text highlight"><pre><span></span><code>double d = -7.9;
unsigned u = 0;

u = d;                               // bad: narrowing
u = gsl::narrow_cast&lt;unsigned&gt;(d);   // OK (you asked for it): u becomes 4294967289
u = gsl::narrow&lt;unsigned&gt;(d);        // OK: throws narrowing_error
</code></pre></div>
<h5 id="note_25">Note<a class="headerlink" href="#note_25" title="Permanent link">&para;</a></h5>
<p>This rule does not apply to <a href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Contextual_conversions">contextual conversions to bool</a>:</p>
<div class="language-text highlight"><pre><span></span><code>if (ptr) do_something(*ptr);   // OK: ptr is used as a condition
bool b = ptr;                  // bad: narrowing
</code></pre></div>
<h5 id="enforcement_31">Enforcement<a class="headerlink" href="#enforcement_31" title="Permanent link">&para;</a></h5>
<p>A good analyzer can detect all narrowing conversions. However, flagging all narrowing conversions will lead to a lot of false positives. Suggestions:</p>
<ul>
<li>Flag all floating-point to integer conversions (maybe only <code>float</code>-&gt;<code>char</code> and <code>double</code>-&gt;<code>int</code>. Here be dragons! we need data).</li>
<li>Flag all <code>long</code>-&gt;<code>char</code> (I suspect <code>int</code>-&gt;<code>char</code> is very common. Here be dragons! we need data).</li>
<li>Consider narrowing conversions for function arguments especially suspect.</li>
</ul>
<h3 id="es47-use-nullptr-rather-than-0-or-null"><a name="Res-nullptr"></a>ES.47: Use <code>nullptr</code> rather than <code>0</code> or <code>NULL</code><a class="headerlink" href="#es47-use-nullptr-rather-than-0-or-null" title="Permanent link">&para;</a></h3>
<h5 id="reason_31">Reason<a class="headerlink" href="#reason_31" title="Permanent link">&para;</a></h5>
<p>Readability. Minimize surprises: <code>nullptr</code> cannot be confused with an
<code>int</code>. <code>nullptr</code> also has a well-specified (very restrictive) type, and thus
works in more scenarios where type deduction might do the wrong thing on <code>NULL</code>
or <code>0</code>.</p>
<h5 id="example_36">Example<a class="headerlink" href="#example_36" title="Permanent link">&para;</a></h5>
<p>Consider:</p>
<div class="language-text highlight"><pre><span></span><code>void f(int);
void f(char*);
f(0);         // call f(int)
f(nullptr);   // call f(char*)
</code></pre></div>
<h5 id="enforcement_32">Enforcement<a class="headerlink" href="#enforcement_32" title="Permanent link">&para;</a></h5>
<p>Flag uses of <code>0</code> and <code>NULL</code> for pointers. The transformation might be helped by simple program transformation.</p>
<h3 id="es48-avoid-casts"><a name="Res-casts"></a>ES.48: Avoid casts<a class="headerlink" href="#es48-avoid-casts" title="Permanent link">&para;</a></h3>
<h5 id="reason_32">Reason<a class="headerlink" href="#reason_32" title="Permanent link">&para;</a></h5>
<p>Casts are a well-known source of errors and make some optimizations unreliable.</p>
<h5 id="example-bad_18">Example, bad<a class="headerlink" href="#example-bad_18" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>double d = 2;
auto p = (long*)&amp;d;
auto q = (long long*)&amp;d;
cout &lt;&lt; d &lt;&lt; &#39; &#39; &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; *q &lt;&lt; &#39;\n&#39;;
</code></pre></div>
<p>What would you think this fragment prints? The result is at best implementation defined. I got</p>
<div class="language-text highlight"><pre><span></span><code>2 0 4611686018427387904
</code></pre></div>
<p>Adding</p>
<div class="language-text highlight"><pre><span></span><code>*q = 666;
cout &lt;&lt; d &lt;&lt; &#39; &#39; &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; *q &lt;&lt; &#39;\n&#39;;
</code></pre></div>
<p>I got</p>
<div class="language-text highlight"><pre><span></span><code>3.29048e-321 666 666
</code></pre></div>
<p>Surprised? I'm just glad I didn't crash the program.</p>
<h5 id="note_26">Note<a class="headerlink" href="#note_26" title="Permanent link">&para;</a></h5>
<p>Programmers who write casts typically assume that they know what they are doing,
or that writing a cast makes the program "easier to read".
In fact, they often disable the general rules for using values.
Overload resolution and template instantiation usually pick the right function if there is a right function to pick.
If there is not, maybe there ought to be, rather than applying a local fix (cast).</p>
<h5 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h5>
<p>Casts are necessary in a systems programming language.  For example, how else
would we get the address of a device register into a pointer?  However, casts
are seriously overused as well as a major source of errors.</p>
<p>If you feel the need for a lot of casts, there might be a fundamental design problem.</p>
<p>The <a href="#Pro-type-reinterpretcast">type profile</a> bans <code>reinterpret_cast</code> and C-style casts.</p>
<p>Never cast to <code>(void)</code> to ignore a <code>[[nodiscard]]</code>return value.
If you deliberately want to discard such a result, first think hard about whether that is really a good idea (there is usually a good reason the author of the function or of the return type used <code>[[nodiscard]]</code> in the first place).
If you still think it's appropriate and your code reviewer agrees, use <code>std::ignore =</code> to turn off the warning which is simple, portable, and easy to grep.</p>
<h5 id="alternatives">Alternatives<a class="headerlink" href="#alternatives" title="Permanent link">&para;</a></h5>
<p>Casts are widely (mis)used. Modern C++ has rules and constructs that eliminate the need for casts in many contexts, such as</p>
<ul>
<li>Use templates</li>
<li>Use <code>std::variant</code></li>
<li>Rely on the well-defined, safe, implicit conversions between pointer types</li>
<li>Use <code>std::ignore =</code> to ignore <code>[[nodiscard]]</code> values.</li>
</ul>
<h5 id="enforcement_33">Enforcement<a class="headerlink" href="#enforcement_33" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag all C-style casts, including to <code>void</code>.</li>
<li>Flag functional style casts using <code>Type(value)</code>. Use <code>Type{value}</code> instead which is not narrowing. (See <a href="#Res-construct">ES.64</a>.)</li>
<li>Flag <a href="#Pro-type-identitycast">identity casts</a> between pointer types, where the source and target types are the same (#Pro-type-identitycast).</li>
<li>Flag an explicit pointer cast that could be <a href="#Pro-type-implicitpointercast">implicit</a>.</li>
</ul>
<h3 id="es49-if-you-must-use-a-cast-use-a-named-cast"><a name="Res-casts-named"></a>ES.49: If you must use a cast, use a named cast<a class="headerlink" href="#es49-if-you-must-use-a-cast-use-a-named-cast" title="Permanent link">&para;</a></h3>
<h5 id="reason_33">Reason<a class="headerlink" href="#reason_33" title="Permanent link">&para;</a></h5>
<p>Readability. Error avoidance.
Named casts are more specific than a C-style or functional cast, allowing the compiler to catch some errors.</p>
<p>The named casts are:</p>
<ul>
<li><code>static_cast</code></li>
<li><code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>dynamic_cast</code></li>
<li><code>std::move</code>         // <code>move(x)</code> is an rvalue reference to <code>x</code></li>
<li><code>std::forward</code>      // <code>forward&lt;T&gt;(x)</code> is an rvalue or an lvalue reference to <code>x</code> depending on <code>T</code></li>
<li><code>gsl::narrow_cast</code>  // <code>narrow_cast&lt;T&gt;(x)</code> is <code>static_cast&lt;T&gt;(x)</code></li>
<li><code>gsl::narrow</code>       // <code>narrow&lt;T&gt;(x)</code> is <code>static_cast&lt;T&gt;(x)</code> if <code>static_cast&lt;T&gt;(x) == x</code> or it throws <code>narrowing_error</code></li>
</ul>
<h5 id="example_37">Example<a class="headerlink" href="#example_37" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class B { /* ... */ };
class D { /* ... */ };

template&lt;typename D&gt; D* upcast(B* pb)
{
    D* pd0 = pb;                        // error: no implicit conversion from B* to D*
    D* pd1 = (D*)pb;                    // legal, but what is done?
    D* pd2 = static_cast&lt;D*&gt;(pb);       // error: D is not derived from B
    D* pd3 = reinterpret_cast&lt;D*&gt;(pb);  // OK: on your head be it!
    D* pd4 = dynamic_cast&lt;D*&gt;(pb);      // OK: return nullptr
    // ...
}
</code></pre></div>
<p>The example was synthesized from real-world bugs where <code>D</code> used to be derived from <code>B</code>, but someone refactored the hierarchy.
The C-style cast is dangerous because it can do any kind of conversion, depriving us of any protection from mistakes (now or in the future).</p>
<h5 id="note_27">Note<a class="headerlink" href="#note_27" title="Permanent link">&para;</a></h5>
<p>When converting between types with no information loss (e.g. from <code>float</code> to
<code>double</code> or from <code>int32</code> to <code>int64</code>), brace initialization might be used instead.</p>
<div class="language-text highlight"><pre><span></span><code>double d {some_float};
int64_t i {some_int32};
</code></pre></div>
<p>This makes it clear that the type conversion was intended and also prevents
conversions between types that might result in loss of precision. (It is a
compilation error to try to initialize a <code>float</code> from a <code>double</code> in this fashion,
for example.)</p>
<h5 id="note_28">Note<a class="headerlink" href="#note_28" title="Permanent link">&para;</a></h5>
<p><code>reinterpret_cast</code> can be essential, but the essential uses (e.g., turning a machine address into pointer) are not type safe:</p>
<div class="language-text highlight"><pre><span></span><code>auto p = reinterpret_cast&lt;Device_register&gt;(0x800);  // inherently dangerous
</code></pre></div>
<h5 id="enforcement_34">Enforcement<a class="headerlink" href="#enforcement_34" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag all C-style casts, including to <code>void</code>.</li>
<li>Flag functional style casts using <code>Type(value)</code>. Use <code>Type{value}</code> instead which is not narrowing. (See <a href="#Res-construct">ES.64</a>.)</li>
<li>The <a href="#Pro-type-reinterpretcast">type profile</a> bans <code>reinterpret_cast</code>.</li>
<li>The <a href="#Pro-type-arithmeticcast">type profile</a> warns when using <code>static_cast</code> between arithmetic types.</li>
</ul>
<h3 id="es50-dont-cast-away-const"><a name="Res-casts-const"></a>ES.50: Don't cast away <code>const</code><a class="headerlink" href="#es50-dont-cast-away-const" title="Permanent link">&para;</a></h3>
<h5 id="reason_34">Reason<a class="headerlink" href="#reason_34" title="Permanent link">&para;</a></h5>
<p>It makes a lie out of <code>const</code>.
If the variable is actually declared <code>const</code>, modifying it results in undefined behavior.</p>
<h5 id="example-bad_19">Example, bad<a class="headerlink" href="#example-bad_19" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(const int&amp; x)
{
    const_cast&lt;int&amp;&gt;(x) = 42;   // BAD
}

static int i = 0;
static const int j = 0;

f(i); // silent side effect
f(j); // undefined behavior
</code></pre></div>
<h5 id="example_38">Example<a class="headerlink" href="#example_38" title="Permanent link">&para;</a></h5>
<p>Sometimes, you might be tempted to resort to <code>const_cast</code> to avoid code duplication, such as when two accessor functions that differ only in <code>const</code>-ness have similar implementations. For example:</p>
<div class="language-text highlight"><pre><span></span><code>class Bar;

class Foo {
public:
    // BAD, duplicates logic
    Bar&amp; get_bar()
    {
        /* complex logic around getting a non-const reference to my_bar */
    }

    const Bar&amp; get_bar() const
    {
        /* same complex logic around getting a const reference to my_bar */
    }
private:
    Bar my_bar;
};
</code></pre></div>
<p>Instead, prefer to share implementations. Normally, you can just have the non-<code>const</code> function call the <code>const</code> function. However, when there is complex logic this can lead to the following pattern that still resorts to a <code>const_cast</code>:</p>
<div class="language-text highlight"><pre><span></span><code>class Foo {
public:
    // not great, non-const calls const version but resorts to const_cast
    Bar&amp; get_bar()
    {
        return const_cast&lt;Bar&amp;&gt;(static_cast&lt;const Foo&amp;&gt;(*this).get_bar());
    }
    const Bar&amp; get_bar() const
    {
        /* the complex logic around getting a const reference to my_bar */
    }
private:
    Bar my_bar;
};
</code></pre></div>
<p>Although this pattern is safe when applied correctly, because the caller must have had a non-<code>const</code> object to begin with, it's not ideal because the safety is hard to enforce automatically as a checker rule.</p>
<p>Instead, prefer to put the common code in a common helper function -- and make it a template so that it deduces <code>const</code>. This doesn't use any <code>const_cast</code> at all:</p>
<div class="language-text highlight"><pre><span></span><code>class Foo {
public:                         // good
          Bar&amp; get_bar()       { return get_bar_impl(*this); }
    const Bar&amp; get_bar() const { return get_bar_impl(*this); }
private:
    Bar my_bar;

    template&lt;class T&gt;           // good, deduces whether T is const or non-const
    static auto&amp; get_bar_impl(T&amp; t)
        { /* the complex logic around getting a possibly-const reference to my_bar */ }
};
</code></pre></div>
<p>Note: Don't do large non-dependent work inside a template, which leads to code bloat. For example, a further improvement would be if all or part of <code>get_bar_impl</code> can be non-dependent and factored out into a common non-template function, for a potentially big reduction in code size.</p>
<h5 id="exception_8">Exception<a class="headerlink" href="#exception_8" title="Permanent link">&para;</a></h5>
<p>You might need to cast away <code>const</code> when calling <code>const</code>-incorrect functions.
Prefer to wrap such functions in inline <code>const</code>-correct wrappers to encapsulate the cast in one place.</p>
<h5 id="example_39">Example<a class="headerlink" href="#example_39" title="Permanent link">&para;</a></h5>
<p>Sometimes, "cast away <code>const</code>" is to allow the updating of some transient information of an otherwise immutable object.
Examples are caching, memoization, and precomputation.
Such examples are often handled as well or better using <code>mutable</code> or an indirection than with a <code>const_cast</code>.</p>
<p>Consider keeping previously computed results around for a costly operation:</p>
<div class="language-text highlight"><pre><span></span><code>int compute(int x); // compute a value for x; assume this to be costly

class Cache {   // some type implementing a cache for an int-&gt;int operation
public:
    pair&lt;bool, int&gt; find(int x) const;   // is there a value for x?
    void set(int x, int v);             // make y the value for x
    // ...
private:
    // ...
};

class X {
public:
    int get_val(int x)
    {
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache.set(x, val); // insert value for x
        return val;
    }
    // ...
private:
    Cache cache;
};
</code></pre></div>
<p>Here, <code>get_val()</code> is logically constant, so we would like to make it a <code>const</code> member.
To do this we still need to mutate <code>cache</code>, so people sometimes resort to a <code>const_cast</code>:</p>
<div class="language-text highlight"><pre><span></span><code>class X {   // Suspicious solution based on casting
public:
    int get_val(int x) const
    {
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        const_cast&lt;Cache&amp;&gt;(cache).set(x, val);   // ugly
        return val;
    }
    // ...
private:
    Cache cache;
};
</code></pre></div>
<p>Fortunately, there is a better solution:
State that <code>cache</code> is mutable even for a <code>const</code> object:</p>
<div class="language-text highlight"><pre><span></span><code>class X {   // better solution
public:
    int get_val(int x) const
    {
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache.set(x, val);
        return val;
    }
    // ...
private:
    mutable Cache cache;
};
</code></pre></div>
<p>An alternative solution would be to store a pointer to the <code>cache</code>:</p>
<div class="language-text highlight"><pre><span></span><code>class X {   // OK, but slightly messier solution
public:
    int get_val(int x) const
    {
        auto p = cache-&gt;find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache-&gt;set(x, val);
        return val;
    }
    // ...
private:
    unique_ptr&lt;Cache&gt; cache;
};
</code></pre></div>
<p>That solution is the most flexible, but requires explicit construction and destruction of <code>*cache</code>
(most likely in the constructor and destructor of <code>X</code>).</p>
<p>In any variant, we must guard against data races on the <code>cache</code> in multi-threaded code, possibly using a <code>std::mutex</code>.</p>
<h5 id="enforcement_35">Enforcement<a class="headerlink" href="#enforcement_35" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag <code>const_cast</code>s.</li>
<li>This rule is part of the <a href="#Pro-type-constcast">type-safety profile</a> for the related Profile.</li>
</ul>
<h3 id="es55-avoid-the-need-for-range-checking"><a name="Res-range-checking"></a>ES.55: Avoid the need for range checking<a class="headerlink" href="#es55-avoid-the-need-for-range-checking" title="Permanent link">&para;</a></h3>
<h5 id="reason_35">Reason<a class="headerlink" href="#reason_35" title="Permanent link">&para;</a></h5>
<p>Constructs that cannot overflow do not overflow (and usually run faster):</p>
<h5 id="example_40">Example<a class="headerlink" href="#example_40" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>for (auto&amp; x : v)      // print all elements of v
    cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

auto p = find(v, x);   // find x in v
</code></pre></div>
<h5 id="enforcement_36">Enforcement<a class="headerlink" href="#enforcement_36" title="Permanent link">&para;</a></h5>
<p>Look for explicit range checks and heuristically suggest alternatives.</p>
<h3 id="es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope"><a name="Res-move"></a>ES.56: Write <code>std::move()</code> only when you need to explicitly move an object to another scope<a class="headerlink" href="#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope" title="Permanent link">&para;</a></h3>
<h5 id="reason_36">Reason<a class="headerlink" href="#reason_36" title="Permanent link">&para;</a></h5>
<p>We move, rather than copy, to avoid duplication and for improved performance.</p>
<p>A move typically leaves behind an empty object (<a href="#Rc-move-semantic">C.64</a>), which can be surprising or even dangerous, so we try to avoid moving from lvalues (they might be accessed later).</p>
<h5 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h5>
<p>Moving is done implicitly when the source is an rvalue (e.g., value in a <code>return</code> treatment or a function result), so don't pointlessly complicate code in those cases by writing <code>move</code> explicitly. Instead, write short functions that return values, and both the function's return and the caller's accepting of the return will be optimized naturally.</p>
<p>In general, following the guidelines in this document (including not making variables' scopes needlessly large, writing short functions that return values, returning local variables) help eliminate most need for explicit <code>std::move</code>.</p>
<p>Explicit <code>move</code> is needed to explicitly move an object to another scope, notably to pass it to a "sink" function and in the implementations of the move operations themselves (move constructor, move assignment operator) and swap operations.</p>
<h5 id="example-bad_20">Example, bad<a class="headerlink" href="#example-bad_20" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void sink(X&amp;&amp; x);   // sink takes ownership of x

void user()
{
    X x;
    // error: cannot bind an lvalue to a rvalue reference
    sink(x);
    // OK: sink takes the contents of x, x must now be assumed to be empty
    sink(std::move(x));

    // ...

    // probably a mistake
    use(x);
}
</code></pre></div>
<p>Usually, a <code>std::move()</code> is used as an argument to a <code>&amp;&amp;</code> parameter.
And after you do that, assume the object has been moved from (see <a href="#Rc-move-semantic">C.64</a>) and don't read its state again until you first set it to a new value.</p>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    string s1 = &quot;supercalifragilisticexpialidocious&quot;;

    string s2 = s1;             // ok, takes a copy
    assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);  // ok

    // bad, if you want to keep using s1&#39;s value
    string s3 = move(s1);

    // bad, assert will likely fail, s1 likely changed
    assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);
}
</code></pre></div>
<h5 id="example_41">Example<a class="headerlink" href="#example_41" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void sink(unique_ptr&lt;widget&gt; p);  // pass ownership of p to sink()

void f()
{
    auto w = make_unique&lt;widget&gt;();
    // ...
    sink(std::move(w));               // ok, give to sink()
    // ...
    sink(w);    // Error: unique_ptr is carefully designed so that you cannot copy it
}
</code></pre></div>
<h5 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h5>
<p><code>std::move()</code> is a cast to <code>&amp;&amp;</code> in disguise; it doesn't itself move anything, but marks a named object as a candidate that can be moved from.
The language already knows the common cases where objects can be moved from, especially when returning values from functions, so don't complicate code with redundant <code>std::move()</code>'s.</p>
<p>Never write <code>std::move()</code> just because you've heard "it's more efficient."
In general, don't believe claims of "efficiency" without data (???).
In general, don't complicate your code without reason (??).
Never write <code>std::move()</code> on a const object, it is silently transformed into a copy (see Item 23 in <a href="#Meyers15">Meyers15</a>)</p>
<h5 id="example-bad_21">Example, bad<a class="headerlink" href="#example-bad_21" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>vector&lt;int&gt; make_vector()
{
    vector&lt;int&gt; result;
    // ... load result with data
    return std::move(result);       // bad; just write &quot;return result;&quot;
}
</code></pre></div>
<p>Never write <code>return move(local_variable);</code>, because the language already knows the variable is a move candidate.
Writing <code>move</code> in this code won't help, and can actually be detrimental because on some compilers it interferes with RVO (the return value optimization) by creating an additional reference alias to the local variable.</p>
<h5 id="example-bad_22">Example, bad<a class="headerlink" href="#example-bad_22" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>vector&lt;int&gt; v = std::move(make_vector());   // bad; the std::move is entirely redundant
</code></pre></div>
<p>Never write <code>move</code> on a returned value such as <code>x = move(f());</code> where <code>f</code> returns by value.
The language already knows that a returned value is a temporary object that can be moved from.</p>
<h5 id="example_42">Example<a class="headerlink" href="#example_42" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void mover(X&amp;&amp; x)
{
    call_something(std::move(x));         // ok
    call_something(std::forward&lt;X&gt;(x));   // bad, don&#39;t std::forward an rvalue reference
    call_something(x);                    // suspicious, why not std::move?
}

template&lt;class T&gt;
void forwarder(T&amp;&amp; t)
{
    call_something(std::move(t));         // bad, don&#39;t std::move a forwarding reference
    call_something(std::forward&lt;T&gt;(t));   // ok
    call_something(t);                    // suspicious, why not std::forward?
}
</code></pre></div>
<h5 id="enforcement_37">Enforcement<a class="headerlink" href="#enforcement_37" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag use of <code>std::move(x)</code> where <code>x</code> is an rvalue or the language will already treat it as an rvalue, including <code>return std::move(local_variable);</code> and <code>std::move(f())</code> on a function that returns by value.</li>
<li>Flag functions taking an <code>S&amp;&amp;</code> parameter if there is no <code>const S&amp;</code> overload to take care of lvalues.</li>
<li>Flag a <code>std::move</code>d argument passed to a parameter, except when the parameter type is an <code>X&amp;&amp;</code> rvalue reference or the type is move-only and the parameter is passed by value.</li>
<li>Flag when <code>std::move</code> is applied to a forwarding reference (<code>T&amp;&amp;</code> where <code>T</code> is a template parameter type). Use <code>std::forward</code> instead.</li>
<li>Flag when <code>std::move</code> is applied to other than an rvalue reference to non-const. (More general case of the previous rule to cover the non-forwarding cases.)</li>
<li>Flag when <code>std::forward</code> is applied to an rvalue reference (<code>X&amp;&amp;</code> where <code>X</code> is a non-template parameter type). Use <code>std::move</code> instead.</li>
<li>Flag when <code>std::forward</code> is applied to other than a forwarding reference. (More general case of the previous rule to cover the non-moving cases.)</li>
<li>Flag when an object is potentially moved from and the next operation is a <code>const</code> operation; there should first be an intervening non-<code>const</code> operation, ideally assignment, to first reset the object's value.</li>
</ul>
<h3 id="es60-avoid-new-and-delete-outside-resource-management-functions"><a name="Res-new"></a>ES.60: Avoid <code>new</code> and <code>delete</code> outside resource management functions<a class="headerlink" href="#es60-avoid-new-and-delete-outside-resource-management-functions" title="Permanent link">&para;</a></h3>
<h5 id="reason_37">Reason<a class="headerlink" href="#reason_37" title="Permanent link">&para;</a></h5>
<p>Direct resource management in application code is error-prone and tedious.</p>
<h5 id="note_29">Note<a class="headerlink" href="#note_29" title="Permanent link">&para;</a></h5>
<p>This is also known as the rule of "No naked <code>new</code>!"</p>
<h5 id="example-bad_23">Example, bad<a class="headerlink" href="#example-bad_23" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(int n)
{
    auto p = new X[n];   // n default constructed Xs
    // ...
    delete[] p;
}
</code></pre></div>
<p>There can be code in the <code>...</code> part that causes the <code>delete</code> never to happen.</p>
<p><strong>See also</strong>: <a href="#S-resource">R: Resource management</a></p>
<h5 id="enforcement_38">Enforcement<a class="headerlink" href="#enforcement_38" title="Permanent link">&para;</a></h5>
<p>Flag naked <code>new</code>s and naked <code>delete</code>s.</p>
<h3 id="es61-delete-arrays-using-delete-and-non-arrays-using-delete"><a name="Res-del"></a>ES.61: Delete arrays using <code>delete[]</code> and non-arrays using <code>delete</code><a class="headerlink" href="#es61-delete-arrays-using-delete-and-non-arrays-using-delete" title="Permanent link">&para;</a></h3>
<h5 id="reason_38">Reason<a class="headerlink" href="#reason_38" title="Permanent link">&para;</a></h5>
<p>That's what the language requires, and mismatches can lead to resource release errors and/or memory corruption.</p>
<h5 id="example-bad_24">Example, bad<a class="headerlink" href="#example-bad_24" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(int n)
{
    auto p = new X[n];   // n default constructed Xs
    // ...
    delete p;   // error: just delete the object p, rather than delete the array p[]
}
</code></pre></div>
<h5 id="note_30">Note<a class="headerlink" href="#note_30" title="Permanent link">&para;</a></h5>
<p>This example not only violates the <a href="#Res-new">no naked <code>new</code> rule</a> as in the previous example, it has many more problems.</p>
<h5 id="enforcement_39">Enforcement<a class="headerlink" href="#enforcement_39" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag mismatched <code>new</code> and <code>delete</code> if they are in the same scope.</li>
<li>Flag mismatched <code>new</code> and <code>delete</code> if they are in a constructor/destructor pair.</li>
</ul>
<h3 id="es62-dont-compare-pointers-into-different-arrays"><a name="Res-arr2"></a>ES.62: Don't compare pointers into different arrays<a class="headerlink" href="#es62-dont-compare-pointers-into-different-arrays" title="Permanent link">&para;</a></h3>
<h5 id="reason_39">Reason<a class="headerlink" href="#reason_39" title="Permanent link">&para;</a></h5>
<p>The result of doing so is undefined.</p>
<h5 id="example-bad_25">Example, bad<a class="headerlink" href="#example-bad_25" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    int a1[7];
    int a2[9];
    if (&amp;a1[5] &lt; &amp;a2[7]) {}       // bad: undefined
    if (0 &lt; &amp;a1[5] - &amp;a2[7]) {}   // bad: undefined
}
</code></pre></div>
<h5 id="note_31">Note<a class="headerlink" href="#note_31" title="Permanent link">&para;</a></h5>
<p>This example has many more problems.</p>
<h5 id="enforcement_40">Enforcement<a class="headerlink" href="#enforcement_40" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="es63-dont-slice"><a name="Res-slice"></a>ES.63: Don't slice<a class="headerlink" href="#es63-dont-slice" title="Permanent link">&para;</a></h3>
<h5 id="reason_40">Reason<a class="headerlink" href="#reason_40" title="Permanent link">&para;</a></h5>
<p>Slicing -- that is, copying only part of an object using assignment or initialization -- most often leads to errors because
the object was meant to be considered as a whole.
In the rare cases where the slicing was deliberate the code can be surprising.</p>
<h5 id="example_43">Example<a class="headerlink" href="#example_43" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>class Shape { /* ... */ };
class Circle : public Shape { /* ... */ Point c; int r; };

Circle c { {0, 0}, 42 };
Shape s {c};    // copy construct only the Shape part of Circle
s = c;          // or copy assign only the Shape part of Circle

void assign(const Shape&amp; src, Shape&amp; dest)
{
    dest = src;
}
Circle c2 { {1, 1}, 43 };
assign(c, c2);   // oops, not the whole state is transferred
assert(c == c2); // if we supply copying, we should also provide comparison,
                 // but this will likely return false
</code></pre></div>
<p>The result will be meaningless because the center and radius will not be copied from <code>c</code> into <code>s</code>.
The first defense against this is to <a href="#Rc-copy-virtual">define the base class <code>Shape</code> not to allow this</a>.</p>
<h5 id="alternative">Alternative<a class="headerlink" href="#alternative" title="Permanent link">&para;</a></h5>
<p>If you mean to slice, define an explicit operation to do so.
This saves readers from confusion.
For example:</p>
<div class="language-text highlight"><pre><span></span><code>class Smiley : public Circle {
    public:
    Circle copy_circle();
    // ...
};

Smiley sm { /* ... */ };
Circle c1 {sm};  // ideally prevented by the definition of Circle
Circle c2 {sm.copy_circle()};
</code></pre></div>
<h5 id="enforcement_41">Enforcement<a class="headerlink" href="#enforcement_41" title="Permanent link">&para;</a></h5>
<p>Warn against slicing.</p>
<h3 id="es64-use-the-tenotation-for-construction"><a name="Res-construct"></a>ES.64: Use the <code>T{e}</code>notation for construction<a class="headerlink" href="#es64-use-the-tenotation-for-construction" title="Permanent link">&para;</a></h3>
<h5 id="reason_41">Reason<a class="headerlink" href="#reason_41" title="Permanent link">&para;</a></h5>
<p>The <code>T{e}</code> construction syntax makes it explicit that construction is desired.
The <code>T{e}</code> construction syntax doesn't allow narrowing.
<code>T{e}</code> is the only safe and general expression for constructing a value of type <code>T</code> from an expression <code>e</code>.
The casts notations <code>T(e)</code> and <code>(T)e</code> are neither safe nor general.</p>
<h5 id="example_44">Example<a class="headerlink" href="#example_44" title="Permanent link">&para;</a></h5>
<p>For built-in types, the construction notation protects against narrowing and reinterpretation</p>
<div class="language-text highlight"><pre><span></span><code>void use(char ch, int i, double d, char* p, long long lng)
{
    int x1 = int{ch};     // OK, but redundant
    int x2 = int{d};      // error: double-&gt;int narrowing; use a cast if you need to
    int x3 = int{p};      // error: pointer to-&gt;int; use a reinterpret_cast if you really need to
    int x4 = int{lng};    // error: long long-&gt;int narrowing; use a cast if you need to

    int y1 = int(ch);     // OK, but redundant
    int y2 = int(d);      // bad: double-&gt;int narrowing; use a cast if you need to
    int y3 = int(p);      // bad: pointer to-&gt;int; use a reinterpret_cast if you really need to
    int y4 = int(lng);    // bad: long long-&gt;int narrowing; use a cast if you need to

    int z1 = (int)ch;     // OK, but redundant
    int z2 = (int)d;      // bad: double-&gt;int narrowing; use a cast if you need to
    int z3 = (int)p;      // bad: pointer to-&gt;int; use a reinterpret_cast if you really need to
    int z4 = (int)lng;    // bad: long long-&gt;int narrowing; use a cast if you need to
}
</code></pre></div>
<p>The integer to/from pointer conversions are implementation defined when using the <code>T(e)</code> or <code>(T)e</code> notations, and non-portable
between platforms with different integer and pointer sizes.</p>
<h5 id="note_32">Note<a class="headerlink" href="#note_32" title="Permanent link">&para;</a></h5>
<p><a href="#Res-casts">Avoid casts</a> (explicit type conversion) and if you must <a href="#Res-casts-named">prefer named casts</a>.</p>
<h5 id="note_33">Note<a class="headerlink" href="#note_33" title="Permanent link">&para;</a></h5>
<p>When unambiguous, the <code>T</code> can be left out of <code>T{e}</code>.</p>
<div class="language-text highlight"><pre><span></span><code>complex&lt;double&gt; f(complex&lt;double&gt;);

auto z = f({2*pi, 1});
</code></pre></div>
<h5 id="note_34">Note<a class="headerlink" href="#note_34" title="Permanent link">&para;</a></h5>
<p>The construction notation is the most general <a href="#Res-list">initializer notation</a>.</p>
<h5 id="exception_9">Exception<a class="headerlink" href="#exception_9" title="Permanent link">&para;</a></h5>
<p><code>std::vector</code> and other containers were defined before we had <code>{}</code> as a notation for construction.
Consider:</p>
<div class="language-text highlight"><pre><span></span><code>vector&lt;string&gt; vs {10};                           // ten empty strings
vector&lt;int&gt; vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // ten elements 1..10
vector&lt;int&gt; vi2 {10};                             // one element with the value 10
</code></pre></div>
<p>How do we get a <code>vector</code> of 10 default initialized <code>int</code>s?</p>
<div class="language-text highlight"><pre><span></span><code>vector&lt;int&gt; v3(10); // ten elements with value 0
</code></pre></div>
<p>The use of <code>()</code> rather than <code>{}</code> for number of elements is conventional (going back to the early 1980s), hard to change, but still
a design error: for a container where the element type can be confused with the number of elements, we have an ambiguity that
must be resolved.
The conventional resolution is to interpret <code>{10}</code> as a list of one element and use <code>(10)</code> to distinguish a size.</p>
<p>This mistake need not be repeated in new code.
We can define a type to represent the number of elements:</p>
<div class="language-text highlight"><pre><span></span><code>struct Count { int n; };

template&lt;typename T&gt;
class Vector {
public:
    Vector(Count n);                     // n default-initialized elements
    Vector(initializer_list&lt;T&gt; init);    // init.size() elements
    // ...
};

Vector&lt;int&gt; v1{10};
Vector&lt;int&gt; v2{Count{10}};
Vector&lt;Count&gt; v3{Count{10}};    // yes, there is still a very minor problem
</code></pre></div>
<p>The main problem left is to find a suitable name for <code>Count</code>.</p>
<h5 id="enforcement_42">Enforcement<a class="headerlink" href="#enforcement_42" title="Permanent link">&para;</a></h5>
<p>Flag the C-style <code>(T)e</code> and functional-style <code>T(e)</code> casts.</p>
<h3 id="es65-dont-dereference-an-invalid-pointer"><a name="Res-deref"></a>ES.65: Don't dereference an invalid pointer<a class="headerlink" href="#es65-dont-dereference-an-invalid-pointer" title="Permanent link">&para;</a></h3>
<h5 id="reason_42">Reason<a class="headerlink" href="#reason_42" title="Permanent link">&para;</a></h5>
<p>Dereferencing an invalid pointer, such as <code>nullptr</code>, is undefined behavior, typically leading to immediate crashes,
wrong results, or memory corruption.</p>
<h5 id="note_35">Note<a class="headerlink" href="#note_35" title="Permanent link">&para;</a></h5>
<p>By pointer here we mean any indirection to an object, including equivalently an iterator or view.</p>
<h5 id="note_36">Note<a class="headerlink" href="#note_36" title="Permanent link">&para;</a></h5>
<p>This rule is an obvious and well-known language rule, but can be hard to follow.
It takes good coding style, library support, and static analysis to eliminate violations without major overhead.
This is a major part of the discussion of <a href="#Stroustrup15">C++'s model for type- and resource-safety</a>.</p>
<p><strong>See also</strong>:</p>
<ul>
<li>Use <a href="#Rr-raii">RAII</a> to avoid lifetime problems.</li>
<li>Use <a href="#Rf-unique_ptr">unique_ptr</a> to avoid lifetime problems.</li>
<li>Use <a href="#Rf-shared_ptr">shared_ptr</a> to avoid lifetime problems.</li>
<li>Use <a href="#Rf-ptr-ref">references</a> when <code>nullptr</code> isn't a possibility.</li>
<li>Use <a href="#Rf-nullptr">not_null</a> to catch unexpected <code>nullptr</code> early.</li>
<li>Use the <a href="#SS-bounds">bounds profile</a> to avoid range errors.</li>
</ul>
<h5 id="example_45">Example<a class="headerlink" href="#example_45" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    int x = 0;
    int* p = &amp;x;

    if (condition()) {
        int y = 0;
        p = &amp;y;
    } // invalidates p

    *p = 42;            // BAD, p might be invalid if the branch was taken
}
</code></pre></div>
<p>To resolve the problem, either extend the lifetime of the object the pointer is intended to refer to, or shorten the lifetime of the pointer (move the dereference to before the pointed-to object's lifetime ends).</p>
<div class="language-text highlight"><pre><span></span><code>void f1()
{
    int x = 0;
    int* p = &amp;x;

    int y = 0;
    if (condition()) {
        p = &amp;y;
    }

    *p = 42;            // OK, p points to x or y and both are still in scope
}
</code></pre></div>
<p>Unfortunately, most invalid pointer problems are harder to spot and harder to fix.</p>
<h5 id="example_46">Example<a class="headerlink" href="#example_46" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(int* p)
{
    int x = *p; // BAD: how do we know that p is valid?
}
</code></pre></div>
<p>There is a huge amount of such code.
Most works -- after lots of testing -- but in isolation it is impossible to tell whether <code>p</code> could be the <code>nullptr</code>.
Consequently, this is also a major source of errors.
There are many approaches to dealing with this potential problem:</p>
<div class="language-text highlight"><pre><span></span><code>void f1(int* p) // deal with nullptr
{
    if (!p) {
        // deal with nullptr (allocate, return, throw, make p point to something, whatever
    }
    int x = *p;
}
</code></pre></div>
<p>There are two potential problems with testing for <code>nullptr</code>:</p>
<ul>
<li>it is not always obvious what to do if we find <code>nullptr</code></li>
<li>the test can be redundant and/or relatively expensive</li>
<li>it is not obvious if the test is to protect against a violation or part of the required logic.</li>
</ul>
<!-- comment needed for code block after list -->
<div class="language-text highlight"><pre><span></span><code>void f2(int* p) // state that p is not supposed to be nullptr
{
    assert(p);
    int x = *p;
}
</code></pre></div>
<p>This would carry a cost only when the assertion checking was enabled and would give a compiler/analyzer useful information.
This would work even better if/when C++ gets direct support for contracts:</p>
<div class="language-text highlight"><pre><span></span><code>void f3(int* p) // state that p is not supposed to be nullptr
    [[expects: p]]
{
    int x = *p;
}
</code></pre></div>
<p>Alternatively, we could use <code>gsl::not_null</code> to ensure that <code>p</code> is not the <code>nullptr</code>.</p>
<div class="language-text highlight"><pre><span></span><code>void f(not_null&lt;int*&gt; p)
{
    int x = *p;
}
</code></pre></div>
<p>These remedies take care of <code>nullptr</code> only.
Remember that there are other ways of getting an invalid pointer.</p>
<h5 id="example_47">Example<a class="headerlink" href="#example_47" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f(int* p)  // old code, doesn&#39;t use owner
{
    delete p;
}

void g()        // old code: uses naked new
{
    auto q = new int{7};
    f(q);
    int x = *q; // BAD: dereferences invalid pointer
}
</code></pre></div>
<h5 id="example_48">Example<a class="headerlink" href="#example_48" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    vector&lt;int&gt; v(10);
    int* p = &amp;v[5];
    v.push_back(99); // could reallocate v&#39;s elements
    int x = *p; // BAD: dereferences potentially invalid pointer
}
</code></pre></div>
<h5 id="enforcement_43">Enforcement<a class="headerlink" href="#enforcement_43" title="Permanent link">&para;</a></h5>
<p>This rule is part of the <a href="#SS-lifetime">lifetime safety profile</a></p>
<ul>
<li>Flag a dereference of a pointer that points to an object that has gone out of scope</li>
<li>Flag a dereference of a pointer that might have been invalidated by assigning a <code>nullptr</code></li>
<li>Flag a dereference of a pointer that might have been invalidated by a <code>delete</code></li>
<li>Flag a dereference to a pointer to a container element that might have been invalidated by dereference</li>
</ul>
<h2 id="esstmt-statements">ES.stmt: Statements<a class="headerlink" href="#esstmt-statements" title="Permanent link">&para;</a></h2>
<p>Statements control the flow of control (except for function calls and exception throws, which are expressions).</p>
<h3 id="es70-prefer-a-switch-statement-to-an-if-statement-when-there-is-a-choice"><a name="Res-switch-if"></a>ES.70: Prefer a <code>switch</code>-statement to an <code>if</code>-statement when there is a choice<a class="headerlink" href="#es70-prefer-a-switch-statement-to-an-if-statement-when-there-is-a-choice" title="Permanent link">&para;</a></h3>
<h5 id="reason_43">Reason<a class="headerlink" href="#reason_43" title="Permanent link">&para;</a></h5>
<ul>
<li>Readability.</li>
<li>Efficiency: A <code>switch</code> compares against constants and is usually better optimized than a series of tests in an <code>if</code>-<code>then</code>-<code>else</code> chain.</li>
<li>A <code>switch</code> enables some heuristic consistency checking. For example, have all values of an <code>enum</code> been covered? If not, is there a <code>default</code>?</li>
</ul>
<h5 id="example_49">Example<a class="headerlink" href="#example_49" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void use(int n)
{
    switch (n) {   // good
    case 0:
        // ...
        break;
    case 7:
        // ...
        break;
    default:
        // ...
        break;
    }
}
</code></pre></div>
<p>rather than:</p>
<div class="language-text highlight"><pre><span></span><code>void use2(int n)
{
    if (n == 0)   // bad: if-then-else chain comparing against a set of constants
        // ...
    else if (n == 7)
        // ...
}
</code></pre></div>
<h5 id="enforcement_44">Enforcement<a class="headerlink" href="#enforcement_44" title="Permanent link">&para;</a></h5>
<p>Flag <code>if</code>-<code>then</code>-<code>else</code> chains that check against constants (only).</p>
<h3 id="es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice"><a name="Res-for-range"></a>ES.71: Prefer a range-<code>for</code>-statement to a <code>for</code>-statement when there is a choice<a class="headerlink" href="#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice" title="Permanent link">&para;</a></h3>
<h5 id="reason_44">Reason<a class="headerlink" href="#reason_44" title="Permanent link">&para;</a></h5>
<p>Readability. Error prevention. Efficiency.</p>
<h5 id="example_50">Example<a class="headerlink" href="#example_50" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>for (gsl::index i = 0; i &lt; v.size(); ++i)   // bad
    cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;

for (auto p = v.begin(); p != v.end(); ++p)   // bad
    cout &lt;&lt; *p &lt;&lt; &#39;\n&#39;;

for (auto&amp; x : v)    // OK
    cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 1; i &lt; v.size(); ++i) // touches two elements: can&#39;t be a range-for
    cout &lt;&lt; v[i] + v[i - 1] &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 0; i &lt; v.size(); ++i) // possible side effect: can&#39;t be a range-for
    cout &lt;&lt; f(v, &amp;v[i]) &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 0; i &lt; v.size(); ++i) { // body messes with loop variable: can&#39;t be a range-for
    if (i % 2 != 0)
        cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; // output odd elements
}
</code></pre></div>
<p>A human or a good static analyzer might determine that there really isn't a side effect on <code>v</code> in <code>f(v, &amp;v[i])</code> so that the loop can be rewritten.</p>
<p>"Messing with the loop variable" in the body of a loop is typically best avoided.</p>
<h5 id="note_37">Note<a class="headerlink" href="#note_37" title="Permanent link">&para;</a></h5>
<p>Don't use expensive copies of the loop variable of a range-<code>for</code> loop:</p>
<div class="language-text highlight"><pre><span></span><code>for (string s : vs) // ...
</code></pre></div>
<p>This will copy each element of <code>vs</code> into <code>s</code>. Better:</p>
<div class="language-text highlight"><pre><span></span><code>for (string&amp; s : vs) // ...
</code></pre></div>
<p>Better still, if the loop variable isn't modified or copied:</p>
<div class="language-text highlight"><pre><span></span><code>for (const string&amp; s : vs) // ...
</code></pre></div>
<h5 id="enforcement_45">Enforcement<a class="headerlink" href="#enforcement_45" title="Permanent link">&para;</a></h5>
<p>Look at loops, if a traditional loop just looks at each element of a sequence, and there are no side effects on what it does with the elements, rewrite the loop to a ranged-<code>for</code> loop.</p>
<h3 id="es72-prefer-a-for-statement-to-a-while-statement-when-there-is-an-obvious-loop-variable"><a name="Res-for-while"></a>ES.72: Prefer a <code>for</code>-statement to a <code>while</code>-statement when there is an obvious loop variable<a class="headerlink" href="#es72-prefer-a-for-statement-to-a-while-statement-when-there-is-an-obvious-loop-variable" title="Permanent link">&para;</a></h3>
<h5 id="reason_45">Reason<a class="headerlink" href="#reason_45" title="Permanent link">&para;</a></h5>
<p>Readability: the complete logic of the loop is visible "up front". The scope of the loop variable can be limited.</p>
<h5 id="example_51">Example<a class="headerlink" href="#example_51" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>for (gsl::index i = 0; i &lt; vec.size(); i++) {
    // do work
}
</code></pre></div>
<h5 id="example-bad_26">Example, bad<a class="headerlink" href="#example-bad_26" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int i = 0;
while (i &lt; vec.size()) {
    // do work
    i++;
}
</code></pre></div>
<h5 id="enforcement_46">Enforcement<a class="headerlink" href="#enforcement_46" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="es73-prefer-a-while-statement-to-a-for-statement-when-there-is-no-obvious-loop-variable"><a name="Res-while-for"></a>ES.73: Prefer a <code>while</code>-statement to a <code>for</code>-statement when there is no obvious loop variable<a class="headerlink" href="#es73-prefer-a-while-statement-to-a-for-statement-when-there-is-no-obvious-loop-variable" title="Permanent link">&para;</a></h3>
<h5 id="reason_46">Reason<a class="headerlink" href="#reason_46" title="Permanent link">&para;</a></h5>
<p>Readability.</p>
<h5 id="example_52">Example<a class="headerlink" href="#example_52" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int events = 0;
for (; wait_for_event(); ++events) {  // bad, confusing
    // ...
}
</code></pre></div>
<p>The "event loop" is misleading because the <code>events</code> counter has nothing to do with the loop condition (<code>wait_for_event()</code>).
Better</p>
<div class="language-text highlight"><pre><span></span><code>int events = 0;
while (wait_for_event()) {      // better
    ++events;
    // ...
}
</code></pre></div>
<h5 id="enforcement_47">Enforcement<a class="headerlink" href="#enforcement_47" title="Permanent link">&para;</a></h5>
<p>Flag actions in <code>for</code>-initializers and <code>for</code>-increments that do not relate to the <code>for</code>-condition.</p>
<h3 id="es74-prefer-to-declare-a-loop-variable-in-the-initializer-part-of-a-for-statement"><a name="Res-for-init"></a>ES.74: Prefer to declare a loop variable in the initializer part of a <code>for</code>-statement<a class="headerlink" href="#es74-prefer-to-declare-a-loop-variable-in-the-initializer-part-of-a-for-statement" title="Permanent link">&para;</a></h3>
<p>See <a href="#Res-cond">ES.6</a></p>
<h3 id="es75-avoid-do-statements"><a name="Res-do"></a>ES.75: Avoid <code>do</code>-statements<a class="headerlink" href="#es75-avoid-do-statements" title="Permanent link">&para;</a></h3>
<h5 id="reason_47">Reason<a class="headerlink" href="#reason_47" title="Permanent link">&para;</a></h5>
<p>Readability, avoidance of errors.
The termination condition is at the end (where it can be overlooked) and the condition is not checked the first time through.</p>
<h5 id="example_53">Example<a class="headerlink" href="#example_53" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int x;
do {
    cin &gt;&gt; x;
    // ...
} while (x &lt; 0);
</code></pre></div>
<h5 id="note_38">Note<a class="headerlink" href="#note_38" title="Permanent link">&para;</a></h5>
<p>Yes, there are genuine examples where a <code>do</code>-statement is a clear statement of a solution, but also many bugs.</p>
<h5 id="enforcement_48">Enforcement<a class="headerlink" href="#enforcement_48" title="Permanent link">&para;</a></h5>
<p>Flag <code>do</code>-statements.</p>
<h3 id="es76-avoid-goto"><a name="Res-goto"></a>ES.76: Avoid <code>goto</code><a class="headerlink" href="#es76-avoid-goto" title="Permanent link">&para;</a></h3>
<h5 id="reason_48">Reason<a class="headerlink" href="#reason_48" title="Permanent link">&para;</a></h5>
<p>Readability, avoidance of errors. There are better control structures for humans; <code>goto</code> is for machine generated code.</p>
<h5 id="exception_10">Exception<a class="headerlink" href="#exception_10" title="Permanent link">&para;</a></h5>
<p>Breaking out of a nested loop.
In that case, always jump forwards.</p>
<div class="language-text highlight"><pre><span></span><code>for (int i = 0; i &lt; imax; ++i)
    for (int j = 0; j &lt; jmax; ++j) {
        if (a[i][j] &gt; elem_max) goto finished;
        // ...
    }
finished:
// ...
</code></pre></div>
<h5 id="example-bad_27">Example, bad<a class="headerlink" href="#example-bad_27" title="Permanent link">&para;</a></h5>
<p>There is a fair amount of use of the C goto-exit idiom:</p>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    // ...
        goto exit;
    // ...
        goto exit;
    // ...
exit:
    // ... common cleanup code ...
}
</code></pre></div>
<p>This is an ad-hoc simulation of destructors.
Declare your resources with handles with destructors that clean up.
If for some reason you cannot handle all cleanup with destructors for the variables used,
consider <code>gsl::finally()</code> as a cleaner and more reliable alternative to <code>goto exit</code></p>
<h5 id="enforcement_49">Enforcement<a class="headerlink" href="#enforcement_49" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag <code>goto</code>. Better still flag all <code>goto</code>s that do not jump from a nested loop to the statement immediately after a nest of loops.</li>
</ul>
<h3 id="es77-minimize-the-use-of-break-and-continue-in-loops"><a name="Res-continue"></a>ES.77: Minimize the use of <code>break</code> and <code>continue</code> in loops<a class="headerlink" href="#es77-minimize-the-use-of-break-and-continue-in-loops" title="Permanent link">&para;</a></h3>
<h5 id="reason_49">Reason<a class="headerlink" href="#reason_49" title="Permanent link">&para;</a></h5>
<p>In a non-trivial loop body, it is easy to overlook a <code>break</code> or a <code>continue</code>.</p>
<p>A <code>break</code> in a loop has a dramatically different meaning than a <code>break</code> in a <code>switch</code>-statement
 (and you can have <code>switch</code>-statement in a loop and a loop in a <code>switch</code>-case).</p>
<h5 id="example_54">Example<a class="headerlink" href="#example_54" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>switch(x) {
case 1 :
    while (/* some condition */) {
        // ...
    break;
    } // Oops! break switch or break while intended?
case 2 :
    // ...
    break;
}
</code></pre></div>
<h5 id="alternative_1">Alternative<a class="headerlink" href="#alternative_1" title="Permanent link">&para;</a></h5>
<p>Often, a loop that requires a <code>break</code> is a good candidate for a function (algorithm), in which case the <code>break</code> becomes a <code>return</code>.</p>
<div class="language-text highlight"><pre><span></span><code>//Original code: break inside loop
void use1()
{
    std::vector&lt;T&gt; vec = {/* initialized with some values */};
    T value;
    for (const T item : vec) {
        if (/* some condition*/) {
            value = item;
            break;
        }
    }
    /* then do something with value */
}

//BETTER: create a function and return inside loop
T search(const std::vector&lt;T&gt; &amp;vec)
{
    for (const T &amp;item : vec) {
        if (/* some condition*/) return item;
    }
    return T(); //default value
}

void use2()
{
    std::vector&lt;T&gt; vec = {/* initialized with some values */};
    T value = search(vec);
    /* then do something with value */
}
</code></pre></div>
<p>Often, a loop that uses <code>continue</code> can equivalently and as clearly be expressed by an <code>if</code>-statement.</p>
<div class="language-text highlight"><pre><span></span><code>for (int item : vec) {  // BAD
    if (item%2 == 0) continue;
    if (item == 5) continue;
    if (item &gt; 10) continue;
    /* do something with item */
}

for (int item : vec) {  // GOOD
    if (item%2 != 0 &amp;&amp; item != 5 &amp;&amp; item &lt;= 10) {
        /* do something with item */
    }
}
</code></pre></div>
<h5 id="note_39">Note<a class="headerlink" href="#note_39" title="Permanent link">&para;</a></h5>
<p>If you really need to break out a loop, a <code>break</code> is typically better than alternatives such as <a href="#Res-loop-counter">modifying the loop variable</a> or a <a href="#Res-goto"><code>goto</code></a>:</p>
<h5 id="enforcement_50">Enforcement<a class="headerlink" href="#enforcement_50" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="es78-dont-rely-on-implicit-fallthrough-in-switch-statements"><a name="Res-break"></a>ES.78: Don't rely on implicit fallthrough in <code>switch</code> statements<a class="headerlink" href="#es78-dont-rely-on-implicit-fallthrough-in-switch-statements" title="Permanent link">&para;</a></h3>
<h5 id="reason_50">Reason<a class="headerlink" href="#reason_50" title="Permanent link">&para;</a></h5>
<p>Always end a non-empty <code>case</code> with a <code>break</code>. Accidentally leaving out a <code>break</code> is a fairly common bug.
A deliberate fallthrough can be a maintenance hazard and should be rare and explicit.</p>
<h5 id="example_55">Example<a class="headerlink" href="#example_55" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>switch (eventType) {
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    // Bad - implicit fallthrough
case Error:
    display_error_window();
    break;
}
</code></pre></div>
<p>Multiple case labels of a single statement is OK:</p>
<div class="language-text highlight"><pre><span></span><code>switch (x) {
case &#39;a&#39;:
case &#39;b&#39;:
case &#39;f&#39;:
    do_something(x);
    break;
}
</code></pre></div>
<p>Return statements in a case label are also OK:</p>
<div class="language-text highlight"><pre><span></span><code>switch (x) {
case &#39;a&#39;:
    return 1;
case &#39;b&#39;:
    return 2;
case &#39;c&#39;:
    return 3;
}
</code></pre></div>
<h5 id="exceptions">Exceptions<a class="headerlink" href="#exceptions" title="Permanent link">&para;</a></h5>
<p>In rare cases if fallthrough is deemed appropriate, be explicit and use the <code>[[fallthrough]]</code> annotation:</p>
<div class="language-text highlight"><pre><span></span><code>switch (eventType) {
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    [[fallthrough]];
case Error:
    display_error_window();
    break;
}
</code></pre></div>
<h5 id="note_40">Note<a class="headerlink" href="#note_40" title="Permanent link">&para;</a></h5>
<h5 id="enforcement_51">Enforcement<a class="headerlink" href="#enforcement_51" title="Permanent link">&para;</a></h5>
<p>Flag all implicit fallthroughs from non-empty <code>case</code>s.</p>
<h3 id="es79-use-default-to-handle-common-cases-only"><a name="Res-default"></a>ES.79: Use <code>default</code> to handle common cases (only)<a class="headerlink" href="#es79-use-default-to-handle-common-cases-only" title="Permanent link">&para;</a></h3>
<h5 id="reason_51">Reason<a class="headerlink" href="#reason_51" title="Permanent link">&para;</a></h5>
<p>Code clarity.
 Improved opportunities for error detection.</p>
<h5 id="example_56">Example<a class="headerlink" href="#example_56" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>enum E { a, b, c, d };

void f1(E x)
{
    switch (x) {
    case a:
        do_something();
        break;
    case b:
        do_something_else();
        break;
    default:
        take_the_default_action();
        break;
    }
}
</code></pre></div>
<p>Here it is clear that there is a default action and that cases <code>a</code> and <code>b</code> are special.</p>
<h5 id="example_57">Example<a class="headerlink" href="#example_57" title="Permanent link">&para;</a></h5>
<p>But what if there is no default action and you mean to handle only specific cases?
In that case, have an empty default or else it is impossible to know if you meant to handle all cases:</p>
<div class="language-text highlight"><pre><span></span><code>void f2(E x)
{
    switch (x) {
    case a:
        do_something();
        break;
    case b:
        do_something_else();
        break;
    default:
        // do nothing for the rest of the cases
        break;
    }
}
</code></pre></div>
<p>If you leave out the <code>default</code>, a maintainer and/or a compiler might reasonably assume that you intended to handle all cases:</p>
<div class="language-text highlight"><pre><span></span><code>void f2(E x)
{
    switch (x) {
    case a:
        do_something();
        break;
    case b:
    case c:
        do_something_else();
        break;
    }
}
</code></pre></div>
<p>Did you forget case <code>d</code> or deliberately leave it out?
Forgetting a case typically happens when a case is added to an enumeration and the person doing so fails to add it to every
switch over the enumerators.</p>
<h5 id="enforcement_52">Enforcement<a class="headerlink" href="#enforcement_52" title="Permanent link">&para;</a></h5>
<p>Flag <code>switch</code>-statements over an enumeration that don't handle all enumerators and do not have a <code>default</code>.
This might yield too many false positives in some code bases; if so, flag only <code>switch</code>es that handle most but not all cases
(that was the strategy of the very first C++ compiler).</p>
<h3 id="es84-dont-try-to-declare-a-local-variable-with-no-name"><a name="Res-noname"></a>ES.84: Don't try to declare a local variable with no name<a class="headerlink" href="#es84-dont-try-to-declare-a-local-variable-with-no-name" title="Permanent link">&para;</a></h3>
<h5 id="reason_52">Reason<a class="headerlink" href="#reason_52" title="Permanent link">&para;</a></h5>
<p>There is no such thing.
What looks to a human like a variable without a name is to the compiler a statement consisting of a temporary that immediately goes out of scope.</p>
<h5 id="example-bad_28">Example, bad<a class="headerlink" href="#example-bad_28" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>void f()
{
    lock_guard&lt;mutex&gt;{mx};   // Bad
    // ...
}
</code></pre></div>
<p>This declares an unnamed <code>lock_guard</code> object that immediately goes out of scope at the point of the semicolon.
This is not an uncommon mistake.
In particular, this particular example can lead to hard-to find race conditions.</p>
<h5 id="note_41">Note<a class="headerlink" href="#note_41" title="Permanent link">&para;</a></h5>
<p>Unnamed function arguments are fine.</p>
<h5 id="enforcement_53">Enforcement<a class="headerlink" href="#enforcement_53" title="Permanent link">&para;</a></h5>
<p>Flag statements that are just a temporary.</p>
<h3 id="es85-make-empty-statements-visible"><a name="Res-empty"></a>ES.85: Make empty statements visible<a class="headerlink" href="#es85-make-empty-statements-visible" title="Permanent link">&para;</a></h3>
<h5 id="reason_53">Reason<a class="headerlink" href="#reason_53" title="Permanent link">&para;</a></h5>
<p>Readability.</p>
<h5 id="example_58">Example<a class="headerlink" href="#example_58" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>for (i = 0; i &lt; max; ++i);   // BAD: the empty statement is easily overlooked
v[i] = f(v[i]);

for (auto x : v) {           // better
    // nothing
}
v[i] = f(v[i]);
</code></pre></div>
<h5 id="enforcement_54">Enforcement<a class="headerlink" href="#enforcement_54" title="Permanent link">&para;</a></h5>
<p>Flag empty statements that are not blocks and don't contain comments.</p>
<h3 id="es86-avoid-modifying-loop-control-variables-inside-the-body-of-raw-for-loops"><a name="Res-loop-counter"></a>ES.86: Avoid modifying loop control variables inside the body of raw for-loops<a class="headerlink" href="#es86-avoid-modifying-loop-control-variables-inside-the-body-of-raw-for-loops" title="Permanent link">&para;</a></h3>
<h5 id="reason_54">Reason<a class="headerlink" href="#reason_54" title="Permanent link">&para;</a></h5>
<p>The loop control up front should enable correct reasoning about what is happening inside the loop. Modifying loop counters in both the iteration-expression and inside the body of the loop is a perennial source of surprises and bugs.</p>
<h5 id="example_59">Example<a class="headerlink" href="#example_59" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>for (int i = 0; i &lt; 10; ++i) {
    // no updates to i -- ok
}

for (int i = 0; i &lt; 10; ++i) {
    //
    if (/* something */) ++i; // BAD
    //
}

bool skip = false;
for (int i = 0; i &lt; 10; ++i) {
    if (skip) { skip = false; continue; }
    //
    if (/* something */) skip = true;  // Better: using two variables for two concepts.
    //
}
</code></pre></div>
<h5 id="enforcement_55">Enforcement<a class="headerlink" href="#enforcement_55" title="Permanent link">&para;</a></h5>
<p>Flag variables that are potentially updated (have a non-<code>const</code> use) in both the loop control iteration-expression and the loop body.</p>
<h3 id="es87-dont-add-redundant-or-to-conditions"><a name="Res-if"></a>ES.87: Don't add redundant <code>==</code> or <code>!=</code> to conditions<a class="headerlink" href="#es87-dont-add-redundant-or-to-conditions" title="Permanent link">&para;</a></h3>
<h5 id="reason_55">Reason<a class="headerlink" href="#reason_55" title="Permanent link">&para;</a></h5>
<p>Doing so avoids verbosity and eliminates some opportunities for mistakes.
Helps make style consistent and conventional.</p>
<h5 id="example_60">Example<a class="headerlink" href="#example_60" title="Permanent link">&para;</a></h5>
<p>By definition, a condition in an <code>if</code>-statement, <code>while</code>-statement, or a <code>for</code>-statement selects between <code>true</code> and <code>false</code>.
A numeric value is compared to <code>0</code> and a pointer value to <code>nullptr</code>.</p>
<div class="language-text highlight"><pre><span></span><code>// These all mean &quot;if p is not nullptr&quot;
if (p) { ... }            // good
if (p != 0) { ... }       // redundant !=0, bad: don&#39;t use 0 for pointers
if (p != nullptr) { ... } // redundant !=nullptr, not recommended
</code></pre></div>
<p>Often, <code>if (p)</code> is read as "if <code>p</code> is valid" which is a direct expression of the programmers intent,
whereas <code>if (p != nullptr)</code> would be a long-winded workaround.</p>
<h5 id="example_61">Example<a class="headerlink" href="#example_61" title="Permanent link">&para;</a></h5>
<p>This rule is especially useful when a declaration is used as a condition</p>
<div class="language-text highlight"><pre><span></span><code>if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) { ... } // execute if ps points to a kind of Circle, good

if (auto pc = dynamic_cast&lt;Circle*&gt;(ps); pc != nullptr) { ... } // not recommended
</code></pre></div>
<h5 id="example_62">Example<a class="headerlink" href="#example_62" title="Permanent link">&para;</a></h5>
<p>Note that implicit conversions to bool are applied in conditions.
For example:</p>
<div class="language-text highlight"><pre><span></span><code>for (string s; cin &gt;&gt; s; ) v.push_back(s);
</code></pre></div>
<p>This invokes <code>istream</code>'s <code>operator bool()</code>.</p>
<h5 id="note_42">Note<a class="headerlink" href="#note_42" title="Permanent link">&para;</a></h5>
<p>Explicit comparison of an integer to <code>0</code> is in general not redundant.
The reason is that (as opposed to pointers and Booleans) an integer often has more than two reasonable values.
Furthermore <code>0</code> (zero) is often used to indicate success.
Consequently, it is best to be specific about the comparison.</p>
<div class="language-text highlight"><pre><span></span><code>void f(int i)
{
    if (i)            // suspect
    // ...
    if (i == success) // possibly better
    // ...
}
</code></pre></div>
<p>Always remember that an integer can have more than two values.</p>
<h5 id="example-bad_29">Example, bad<a class="headerlink" href="#example-bad_29" title="Permanent link">&para;</a></h5>
<p>It has been noted that</p>
<div class="language-text highlight"><pre><span></span><code>if(strcmp(p1, p2)) { ... }   // are the two C-style strings equal? (mistake!)
</code></pre></div>
<p>is a common beginners error.
If you use C-style strings, you must know the <code>&lt;cstring&gt;</code> functions well.
Being verbose and writing</p>
<div class="language-text highlight"><pre><span></span><code>if(strcmp(p1, p2) != 0) { ... }   // are the two C-style strings equal? (mistake!)
</code></pre></div>
<p>would not in itself save you.</p>
<h5 id="note_43">Note<a class="headerlink" href="#note_43" title="Permanent link">&para;</a></h5>
<p>The opposite condition is most easily expressed using a negation:</p>
<div class="language-text highlight"><pre><span></span><code>// These all mean &quot;if p is nullptr&quot;
if (!p) { ... }           // good
if (p == 0) { ... }       // redundant == 0, bad: don&#39;t use 0 for pointers
if (p == nullptr) { ... } // redundant == nullptr, not recommended
</code></pre></div>
<h5 id="enforcement_56">Enforcement<a class="headerlink" href="#enforcement_56" title="Permanent link">&para;</a></h5>
<p>Easy, just check for redundant use of <code>!=</code> and <code>==</code> in conditions.</p>
<h2 id="arithmetic"><a name="SS-numbers"></a>Arithmetic<a class="headerlink" href="#arithmetic" title="Permanent link">&para;</a></h2>
<h3 id="es100-dont-mix-signed-and-unsigned-arithmetic"><a name="Res-mix"></a>ES.100: Don't mix signed and unsigned arithmetic<a class="headerlink" href="#es100-dont-mix-signed-and-unsigned-arithmetic" title="Permanent link">&para;</a></h3>
<h5 id="reason_56">Reason<a class="headerlink" href="#reason_56" title="Permanent link">&para;</a></h5>
<p>Avoid wrong results.</p>
<h5 id="example_63">Example<a class="headerlink" href="#example_63" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int x = -3;
unsigned int y = 7;

cout &lt;&lt; x - y &lt;&lt; &#39;\n&#39;;  // unsigned result, possibly 4294967286
cout &lt;&lt; x + y &lt;&lt; &#39;\n&#39;;  // unsigned result: 4
cout &lt;&lt; x * y &lt;&lt; &#39;\n&#39;;  // unsigned result, possibly 4294967275
</code></pre></div>
<p>It is harder to spot the problem in more realistic examples.</p>
<h5 id="note_44">Note<a class="headerlink" href="#note_44" title="Permanent link">&para;</a></h5>
<p>Unfortunately, C++ uses signed integers for array subscripts and the standard library uses unsigned integers for container subscripts.
This precludes consistency. Use <code>gsl::index</code> for subscripts; <a href="#Res-subscripts">see ES.107</a>.</p>
<h5 id="enforcement_57">Enforcement<a class="headerlink" href="#enforcement_57" title="Permanent link">&para;</a></h5>
<ul>
<li>Compilers already know and sometimes warn.</li>
<li>(To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is <code>sizeof</code> or a call to container <code>.size()</code> and the other is <code>ptrdiff_t</code>.</li>
</ul>
<h3 id="es101-use-unsigned-types-for-bit-manipulation"><a name="Res-unsigned"></a>ES.101: Use unsigned types for bit manipulation<a class="headerlink" href="#es101-use-unsigned-types-for-bit-manipulation" title="Permanent link">&para;</a></h3>
<h5 id="reason_57">Reason<a class="headerlink" href="#reason_57" title="Permanent link">&para;</a></h5>
<p>Unsigned types support bit manipulation without surprises from sign bits.</p>
<h5 id="example_64">Example<a class="headerlink" href="#example_64" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>unsigned char x = 0b1010&#39;1010;
unsigned char y = ~x;   // y == 0b0101&#39;0101;
</code></pre></div>
<h5 id="note_45">Note<a class="headerlink" href="#note_45" title="Permanent link">&para;</a></h5>
<p>Unsigned types can also be useful for modular arithmetic.
However, if you want modular arithmetic add
comments as necessary noting the reliance on wraparound behavior, as such code
can be surprising for many programmers.</p>
<h5 id="enforcement_58">Enforcement<a class="headerlink" href="#enforcement_58" title="Permanent link">&para;</a></h5>
<ul>
<li>Just about impossible in general because of the use of unsigned subscripts in the standard library</li>
<li>???</li>
</ul>
<h3 id="es102-use-signed-types-for-arithmetic"><a name="Res-signed"></a>ES.102: Use signed types for arithmetic<a class="headerlink" href="#es102-use-signed-types-for-arithmetic" title="Permanent link">&para;</a></h3>
<h5 id="reason_58">Reason<a class="headerlink" href="#reason_58" title="Permanent link">&para;</a></h5>
<p>Because most arithmetic is assumed to be signed;
<code>x - y</code> yields a negative number when <code>y &gt; x</code> except in the rare cases where you really want modular arithmetic.</p>
<h5 id="example_65">Example<a class="headerlink" href="#example_65" title="Permanent link">&para;</a></h5>
<p>Unsigned arithmetic can yield surprising results if you are not expecting it.
This is even more true for mixed signed and unsigned arithmetic.</p>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T, typename T2&gt;
T subtract(T x, T2 y)
{
    return x - y;
}

void test()
{
    int s = 5;
    unsigned int us = 5;
    cout &lt;&lt; subtract(s, 7) &lt;&lt; &#39;\n&#39;;       // -2
    cout &lt;&lt; subtract(us, 7u) &lt;&lt; &#39;\n&#39;;     // 4294967294
    cout &lt;&lt; subtract(s, 7u) &lt;&lt; &#39;\n&#39;;      // -2
    cout &lt;&lt; subtract(us, 7) &lt;&lt; &#39;\n&#39;;      // 4294967294
    cout &lt;&lt; subtract(s, us + 2) &lt;&lt; &#39;\n&#39;;  // -2
    cout &lt;&lt; subtract(us, s + 2) &lt;&lt; &#39;\n&#39;;  // 4294967294
}
</code></pre></div>
<p>Here we have been very explicit about what's happening,
but if you had seen <code>us - (s + 2)</code> or <code>s += 2; ...; us - s</code>, would you reliably have suspected that the result would print as <code>4294967294</code>?</p>
<h5 id="exception_11">Exception<a class="headerlink" href="#exception_11" title="Permanent link">&para;</a></h5>
<p>Use unsigned types if you really want modular arithmetic - add
comments as necessary noting the reliance on overflow behavior, as such code
is going to be surprising for many programmers.</p>
<h5 id="example_66">Example<a class="headerlink" href="#example_66" title="Permanent link">&para;</a></h5>
<p>The standard library uses unsigned types for subscripts.
The built-in array uses signed types for subscripts.
This makes surprises (and bugs) inevitable.</p>
<div class="language-text highlight"><pre><span></span><code>int a[10];
for (int i = 0; i &lt; 10; ++i) a[i] = i;
vector&lt;int&gt; v(10);
// compares signed to unsigned; some compilers warn, but we should not
for (gsl::index i = 0; i &lt; v.size(); ++i) v[i] = i;

int a2[-2];         // error: negative size

// OK, but the number of ints (4294967294) is so large that we should get an exception
vector&lt;int&gt; v2(-2);
</code></pre></div>
<p>Use <code>gsl::index</code> for subscripts; <a href="#Res-subscripts">see ES.107</a>.</p>
<h5 id="enforcement_59">Enforcement<a class="headerlink" href="#enforcement_59" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag mixed signed and unsigned arithmetic</li>
<li>Flag results of unsigned arithmetic assigned to or printed as signed.</li>
<li>Flag negative literals (e.g. <code>-2</code>) used as container subscripts.</li>
<li>(To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is <code>sizeof</code> or a call to container <code>.size()</code> and the other is <code>ptrdiff_t</code>.</li>
</ul>
<h3 id="es103-dont-overflow"><a name="Res-overflow"></a>ES.103: Don't overflow<a class="headerlink" href="#es103-dont-overflow" title="Permanent link">&para;</a></h3>
<h5 id="reason_59">Reason<a class="headerlink" href="#reason_59" title="Permanent link">&para;</a></h5>
<p>Overflow usually makes your numeric algorithm meaningless.
Incrementing a value beyond a maximum value can lead to memory corruption and undefined behavior.</p>
<h5 id="example-bad_30">Example, bad<a class="headerlink" href="#example-bad_30" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int a[10];
a[10] = 7;   // bad, array bounds overflow

for (int n = 0; n &lt;= 10; ++n)
    a[n] = 9;   // bad, array bounds overflow
</code></pre></div>
<h5 id="example-bad_31">Example, bad<a class="headerlink" href="#example-bad_31" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int n = numeric_limits&lt;int&gt;::max();
int m = n + 1;   // bad, numeric overflow
</code></pre></div>
<h5 id="example-bad_32">Example, bad<a class="headerlink" href="#example-bad_32" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int area(int h, int w) { return h * w; }

auto a = area(10&#39;000&#39;000, 100&#39;000&#39;000);   // bad, numeric overflow
</code></pre></div>
<h5 id="exception_12">Exception<a class="headerlink" href="#exception_12" title="Permanent link">&para;</a></h5>
<p>Use unsigned types if you really want modular arithmetic.</p>
<p><strong>Alternative</strong>: For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type.</p>
<h5 id="enforcement_60">Enforcement<a class="headerlink" href="#enforcement_60" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="es104-dont-underflow"><a name="Res-underflow"></a>ES.104: Don't underflow<a class="headerlink" href="#es104-dont-underflow" title="Permanent link">&para;</a></h3>
<h5 id="reason_60">Reason<a class="headerlink" href="#reason_60" title="Permanent link">&para;</a></h5>
<p>Decrementing a value beyond a minimum value can lead to memory corruption and undefined behavior.</p>
<h5 id="example-bad_33">Example, bad<a class="headerlink" href="#example-bad_33" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int a[10];
a[-2] = 7;   // bad

int n = 101;
while (n--)
    a[n - 1] = 9;   // bad (twice)
</code></pre></div>
<h5 id="exception_13">Exception<a class="headerlink" href="#exception_13" title="Permanent link">&para;</a></h5>
<p>Use unsigned types if you really want modular arithmetic.</p>
<h5 id="enforcement_61">Enforcement<a class="headerlink" href="#enforcement_61" title="Permanent link">&para;</a></h5>
<p>???</p>
<h3 id="es105-dont-divide-by-integer-zero"><a name="Res-zero"></a>ES.105: Don't divide by integer zero<a class="headerlink" href="#es105-dont-divide-by-integer-zero" title="Permanent link">&para;</a></h3>
<h5 id="reason_61">Reason<a class="headerlink" href="#reason_61" title="Permanent link">&para;</a></h5>
<p>The result is undefined and probably a crash.</p>
<h5 id="note_46">Note<a class="headerlink" href="#note_46" title="Permanent link">&para;</a></h5>
<p>This also applies to <code>%</code>.</p>
<h5 id="example-bad_34">Example, bad<a class="headerlink" href="#example-bad_34" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int divide(int a, int b)
{
    // BAD, should be checked (e.g., in a precondition)
    return a / b;
}
</code></pre></div>
<h5 id="example-good_4">Example, good<a class="headerlink" href="#example-good_4" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>int divide(int a, int b)
{
    // good, address via precondition (and replace with contracts once C++ gets them)
    Expects(b != 0);
    return a / b;
}

double divide(double a, double b)
{
    // good, address via using double instead
    return a / b;
}
</code></pre></div>
<p><strong>Alternative</strong>: For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type.</p>
<h5 id="enforcement_62">Enforcement<a class="headerlink" href="#enforcement_62" title="Permanent link">&para;</a></h5>
<ul>
<li>Flag division by an integral value that could be zero</li>
</ul>
<h3 id="es106-dont-try-to-avoid-negative-values-by-using-unsigned"><a name="Res-nonnegative"></a>ES.106: Don't try to avoid negative values by using <code>unsigned</code><a class="headerlink" href="#es106-dont-try-to-avoid-negative-values-by-using-unsigned" title="Permanent link">&para;</a></h3>
<h5 id="reason_62">Reason<a class="headerlink" href="#reason_62" title="Permanent link">&para;</a></h5>
<p>Choosing <code>unsigned</code> implies many changes to the usual behavior of integers, including modular arithmetic,
can suppress warnings related to overflow,
and opens the door for errors related to signed/unsigned mixes.
Using <code>unsigned</code> doesn't actually eliminate the possibility of negative values.</p>
<h5 id="example_67">Example<a class="headerlink" href="#example_67" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>unsigned int u1 = -2;   // Valid: the value of u1 is 4294967294
int i1 = -2;
unsigned int u2 = i1;   // Valid: the value of u2 is 4294967294
int i2 = u2;            // Valid: the value of i2 is -2
</code></pre></div>
<p>These problems with such (perfectly legal) constructs are hard to spot in real code and are the source of many real-world errors.
Consider:</p>
<div class="language-text highlight"><pre><span></span><code>unsigned area(unsigned height, unsigned width) { return height*width; } // [see also](#Ri-expects)
// ...
int height;
cin &gt;&gt; height;
auto a = area(height, 2);   // if the input is -2 a becomes 4294967292
</code></pre></div>
<p>Remember that <code>-1</code> when assigned to an <code>unsigned int</code> becomes the largest <code>unsigned int</code>.
Also, since unsigned arithmetic is modular arithmetic the multiplication didn't overflow, it wrapped around.</p>
<h5 id="example_68">Example<a class="headerlink" href="#example_68" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>unsigned max = 100000;    // &quot;accidental typo&quot;, I mean to say 10&#39;000
unsigned short x = 100;
while (x &lt; max) x += 100; // infinite loop
</code></pre></div>
<p>Had <code>x</code> been a signed <code>short</code>, we could have warned about the undefined behavior upon overflow.</p>
<h5 id="alternatives_1">Alternatives<a class="headerlink" href="#alternatives_1" title="Permanent link">&para;</a></h5>
<ul>
<li>use signed integers and check for <code>x &gt;= 0</code></li>
<li>use a positive integer type</li>
<li>use an integer subrange type</li>
<li><code>Assert(-1 &lt; x)</code></li>
</ul>
<p>For example</p>
<div class="language-text highlight"><pre><span></span><code>struct Positive {
    int val;
    Positive(int x) :val{x} { Assert(0 &lt; x); }
    operator int() { return val; }
};

int f(Positive arg) { return arg; }

int r1 = f(2);
int r2 = f(-2);  // throws
</code></pre></div>
<h5 id="note_47">Note<a class="headerlink" href="#note_47" title="Permanent link">&para;</a></h5>
<p>???</p>
<h5 id="enforcement_63">Enforcement<a class="headerlink" href="#enforcement_63" title="Permanent link">&para;</a></h5>
<p>See ES.100 Enforcements.</p>
<h3 id="es107-dont-use-unsigned-for-subscripts-prefer-gslindex"><a name="Res-subscripts"></a>ES.107: Don't use <code>unsigned</code> for subscripts, prefer <code>gsl::index</code><a class="headerlink" href="#es107-dont-use-unsigned-for-subscripts-prefer-gslindex" title="Permanent link">&para;</a></h3>
<h5 id="reason_63">Reason<a class="headerlink" href="#reason_63" title="Permanent link">&para;</a></h5>
<p>To avoid signed/unsigned confusion.
To enable better optimization.
To enable better error detection.
To avoid the pitfalls with <code>auto</code> and <code>int</code>.</p>
<h5 id="example-bad_35">Example, bad<a class="headerlink" href="#example-bad_35" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>vector&lt;int&gt; vec = /*...*/;

for (int i = 0; i &lt; vec.size(); i += 2)                    // might not be big enough
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (unsigned i = 0; i &lt; vec.size(); i += 2)               // risk wraparound
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (auto i = 0; i &lt; vec.size(); i += 2)                   // might not be big enough
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (vector&lt;int&gt;::size_type i = 0; i &lt; vec.size(); i += 2) // verbose
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (auto i = vec.size()-1; i &gt;= 0; i -= 2)                // bug
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (int i = vec.size()-1; i &gt;= 0; i -= 2)                 // might not be big enough
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
</code></pre></div>
<h5 id="example-good_5">Example, good<a class="headerlink" href="#example-good_5" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>vector&lt;int&gt; vec = /*...*/;

for (gsl::index i = 0; i &lt; vec.size(); i += 2)             // ok
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (gsl::index i = vec.size()-1; i &gt;= 0; i -= 2)          // ok
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
</code></pre></div>
<h5 id="note_48">Note<a class="headerlink" href="#note_48" title="Permanent link">&para;</a></h5>
<p>The built-in array allows signed subscripts.
The standard-library containers use unsigned subscripts.
Thus, no perfect and fully compatible solution is possible (unless and until the standard-library containers change to use signed subscripts someday in the future).
Given the known problems with unsigned and signed/unsigned mixtures, better stick to (signed) integers of a sufficient size, which is guaranteed by <code>gsl::index</code>.</p>
<h5 id="example_69">Example<a class="headerlink" href="#example_69" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>template&lt;typename T&gt;
struct My_container {
public:
    // ...
    T&amp; operator[](gsl::index i);    // not unsigned
    // ...
};
</code></pre></div>
<h5 id="example_70">Example<a class="headerlink" href="#example_70" title="Permanent link">&para;</a></h5>
<div class="language-text highlight"><pre><span></span><code>??? demonstrate improved code generation and potential for error detection ???
</code></pre></div>
<h5 id="alternatives_2">Alternatives<a class="headerlink" href="#alternatives_2" title="Permanent link">&para;</a></h5>
<p>Alternatives for users</p>
<ul>
<li>use algorithms</li>
<li>use range-for</li>
<li>use iterators/pointers</li>
</ul>
<h5 id="enforcement_64">Enforcement<a class="headerlink" href="#enforcement_64" title="Permanent link">&para;</a></h5>
<ul>
<li>Very tricky as long as the standard-library containers get it wrong.</li>
<li>(To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is <code>sizeof</code> or a call to container <code>.size()</code> and the other is <code>ptrdiff_t</code>.</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["content.code.copy"], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.56ea9cef.min.js"></script>
      
        <script src="../js/open_in_new_tab.js"></script>
      
    
  </body>
</html>